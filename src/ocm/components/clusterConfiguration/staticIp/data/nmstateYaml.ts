import { dump } from 'js-yaml';
import {
  Nmstate,
  NmstateDns,
  NmstateInterface,
  NmstateInterfaceType,
  NmstateProtocolConfig,
  NmstateProtocolConfigs,
  NmstateRoutesConfig,
} from './nmstateTypes';
import { FormViewNetworkWideValues, ProtocolVersion, StaticProtocolType } from './dataTypes';
import findLastIndex from 'lodash/findLastIndex';
import { getProtocolVersions } from './protocolVersion';
import { load } from 'js-yaml';

const ROUTE_DESTINATIONS = {
  ipv4: '0.0.0.0/0',
  ipv6: '::/0',
};
const TABLE_ID = 254;
export const YAML_COMMENT_CHAR = '#';
export const FORM_VIEW_PREFIX = 'generated by ui form view';

export const getMachineNetworkFieldName = (protocolVersion: ProtocolVersion): string => {
  return `${protocolVersion}MachineNetwork`;
};

export const getVlanNicName = (nicName: string, vlanId: number) => `${nicName}.${vlanId}`;

export const getProtocolVersionIdx = (protocolVersion: ProtocolVersion): number => {
  return protocolVersion === 'ipv4' ? 0 : 1;
};

export const yamlToNmstateObject = (yaml: string): Nmstate => {
  return load(yaml) as Nmstate;
};

export const getYamlComments = (yaml: string): string[] => {
  const lines = yaml.split('\n');
  const lastCommentIdx = findLastIndex(lines, (line) => line.startsWith(YAML_COMMENT_CHAR));
  return lines.slice(0, lastCommentIdx + 1).map((line) => line.slice(1));
};

export const toYamlWithComments = (json: object, comments: string[]) => {
  const yamlComments = comments.map((comment) => `${YAML_COMMENT_CHAR}${comment}`);
  return `${yamlComments.join('\n')}\n${dump(json)}`;
};

export const getMachineNetworks = (
  comments: string[],
): { [protocolVersion in ProtocolVersion]: string } => {
  const machineNetworks: { [protocolVersion in ProtocolVersion]: string } = {
    ipv4: '',
    ipv6: '',
  };
  for (const protocolVersion of getProtocolVersions()) {
    const line = comments.find((comment) =>
      comment.startsWith(getMachineNetworkFieldName(protocolVersion)),
    );
    if (line) {
      machineNetworks[protocolVersion] = line.split(' ')[1];
    }
  }
  return machineNetworks;
};

export const getProtocolType = (comments: string[]): StaticProtocolType | null => {
  const machineNetworks = getMachineNetworks(comments);
  if (machineNetworks['ipv4'] && machineNetworks['ipv6']) {
    return 'dualStack';
  }
  if (machineNetworks['ipv4']) {
    return 'ipv4';
  }
  return null;
};

export const getNmstateProtocolConfig = (
  ipAddress: string,
  prefixLength: number,
): NmstateProtocolConfig => {
  return {
    address: [
      {
        ip: ipAddress,
        'prefix-length': prefixLength,
      },
    ],
    enabled: true,
    dhcp: false,
  };
};

export const getDnsSection = (dns: string): NmstateDns => {
  return { config: { server: [dns] } };
};

export const getInterface = (
  nicName: string,
  protocolConfigs: NmstateProtocolConfigs,
  networkWide: FormViewNetworkWideValues,
): NmstateInterface => {
  if (networkWide.useVlan && networkWide.vlanId) {
    return {
      name: getVlanNicName(nicName, networkWide.vlanId),
      type: NmstateInterfaceType.VLAN,
      state: 'up',
      vlan: { 'base-iface': nicName, id: networkWide.vlanId },
      ...protocolConfigs,
    };
  } else {
    return {
      name: nicName,
      type: NmstateInterfaceType.ETHERNET,
      state: 'up',
      ...protocolConfigs,
    };
  }
};

export const getRouteConfig = (
  protocolVersion: ProtocolVersion,
  gatewayAddress: string,
  nicName: string,
): NmstateRoutesConfig => {
  return {
    destination: ROUTE_DESTINATIONS[protocolVersion],
    'next-hop-address': gatewayAddress,
    'next-hop-interface': nicName,
    'table-id': TABLE_ID,
  };
};

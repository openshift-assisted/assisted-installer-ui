/* tslint:disable */
/* eslint-disable */
/**
 * AssistedInstall
 * Assisted installation
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { BindHostParams } from '../models';
// @ts-ignore
import { Cluster } from '../models';
// @ts-ignore
import { ClusterCreateParams } from '../models';
// @ts-ignore
import { ClusterDefaultConfig } from '../models';
// @ts-ignore
import { ClusterList } from '../models';
// @ts-ignore
import { CompletionParams } from '../models';
// @ts-ignore
import { Credentials } from '../models';
// @ts-ignore
import { FeatureSupportLevels } from '../models';
// @ts-ignore
import { GetSupportedArchitectures200Response } from '../models';
// @ts-ignore
import { GetSupportedFeatures200Response } from '../models';
// @ts-ignore
import { Host } from '../models';
// @ts-ignore
import { HostCreateParams } from '../models';
// @ts-ignore
import { HostIgnitionParams } from '../models';
// @ts-ignore
import { HostList } from '../models';
// @ts-ignore
import { HostProgress } from '../models';
// @ts-ignore
import { HostRegistrationResponse } from '../models';
// @ts-ignore
import { HostUpdateParams } from '../models';
// @ts-ignore
import { IgnoredValidations } from '../models';
// @ts-ignore
import { ImportClusterParams } from '../models';
// @ts-ignore
import { InfraEnv } from '../models';
// @ts-ignore
import { InfraEnvCreateParams } from '../models';
// @ts-ignore
import { InfraEnvList } from '../models';
// @ts-ignore
import { InfraEnvUpdateParams } from '../models';
// @ts-ignore
import { InfraError } from '../models';
// @ts-ignore
import { InstallerArgsParams } from '../models';
// @ts-ignore
import { LogsProgressParams } from '../models';
// @ts-ignore
import { ModelError } from '../models';
// @ts-ignore
import { MonitoredOperatorsList } from '../models';
// @ts-ignore
import { OperatorMonitorReport } from '../models';
// @ts-ignore
import { PlatformType } from '../models';
// @ts-ignore
import { PreflightHardwareRequirements } from '../models';
// @ts-ignore
import { PresignedUrl } from '../models';
// @ts-ignore
import { StepReply } from '../models';
// @ts-ignore
import { Steps } from '../models';
// @ts-ignore
import { V2ClusterUpdateParams } from '../models';
/**
 * InstallerApi - axios parameter creator
 * @export
 */
export const InstallerApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Bind host to a cluster
     * @param {string} infraEnvId The infra-env of the host that is being bound.
     * @param {string} hostId The host that is being bound.
     * @param {BindHostParams} bindHostParams The parameters for the host binding.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bindHost: async (
      infraEnvId: string,
      hostId: string,
      bindHostParams: BindHostParams,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'infraEnvId' is not null or undefined
      assertParamExists('bindHost', 'infraEnvId', infraEnvId);
      // verify required parameter 'hostId' is not null or undefined
      assertParamExists('bindHost', 'hostId', hostId);
      // verify required parameter 'bindHostParams' is not null or undefined
      assertParamExists('bindHost', 'bindHostParams', bindHostParams);
      const localVarPath = `/v2/infra-envs/{infra_env_id}/hosts/{host_id}/actions/bind`
        .replace(`{${'infra_env_id'}}`, encodeURIComponent(String(infraEnvId)))
        .replace(`{${'host_id'}}`, encodeURIComponent(String(hostId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        bindHostParams,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes an infra-env.
     * @param {string} infraEnvId The infra-env to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deregisterInfraEnv: async (
      infraEnvId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'infraEnvId' is not null or undefined
      assertParamExists('deregisterInfraEnv', 'infraEnvId', infraEnvId);
      const localVarPath = `/v2/infra-envs/{infra_env_id}`.replace(
        `{${'infra_env_id'}}`,
        encodeURIComponent(String(infraEnvId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the initial ramdisk for minimal ISO based installations.
     * @param {string} infraEnvId The infra-env of the host that should be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadMinimalInitrd: async (
      infraEnvId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'infraEnvId' is not null or undefined
      assertParamExists('downloadMinimalInitrd', 'infraEnvId', infraEnvId);
      const localVarPath = `/v2/infra-envs/{infra_env_id}/downloads/minimal-initrd`.replace(
        `{${'infra_env_id'}}`,
        encodeURIComponent(String(infraEnvId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication urlAuth required
      await setApiKeyToObject(localVarQueryParameter, 'api_key', configuration);

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      // authentication imageAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Image-Token', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * A list of platforms that this cluster can support in its current configuration.
     * @param {string} clusterId The cluster whose platform types should be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClusterSupportedPlatforms: async (
      clusterId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterId' is not null or undefined
      assertParamExists('getClusterSupportedPlatforms', 'clusterId', clusterId);
      const localVarPath = `/v2/clusters/{cluster_id}/supported-platforms`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves the details of the infra-env.
     * @param {string} infraEnvId The infra-env to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInfraEnv: async (
      infraEnvId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'infraEnvId' is not null or undefined
      assertParamExists('getInfraEnv', 'infraEnvId', infraEnvId);
      const localVarPath = `/v2/infra-envs/{infra_env_id}`.replace(
        `{${'infra_env_id'}}`,
        encodeURIComponent(String(infraEnvId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication imageURLAuth required
      await setApiKeyToObject(localVarQueryParameter, 'image_token', configuration);

      // authentication urlAuth required
      await setApiKeyToObject(localVarQueryParameter, 'api_key', configuration);

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      // authentication imageAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Image-Token', configuration);

      // authentication agentAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Secret-Key', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates a new pre-signed image download URL for the infra-env.
     * @param {string} infraEnvId The infra-env to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInfraEnvDownloadURL: async (
      infraEnvId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'infraEnvId' is not null or undefined
      assertParamExists('getInfraEnvDownloadURL', 'infraEnvId', infraEnvId);
      const localVarPath = `/v2/infra-envs/{infra_env_id}/downloads/image-url`.replace(
        `{${'infra_env_id'}}`,
        encodeURIComponent(String(infraEnvId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates a new pre-signed download URL for the infra-env.
     * @param {string} infraEnvId The file\&#39;s infra-env.
     * @param {GetInfraEnvPresignedFileURLFileNameEnum} fileName The file to be downloaded.
     * @param {GetInfraEnvPresignedFileURLIpxeScriptTypeEnum} [ipxeScriptType] Specify the script type to be served for iPXE.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInfraEnvPresignedFileURL: async (
      infraEnvId: string,
      fileName: GetInfraEnvPresignedFileURLFileNameEnum,
      ipxeScriptType?: GetInfraEnvPresignedFileURLIpxeScriptTypeEnum,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'infraEnvId' is not null or undefined
      assertParamExists('getInfraEnvPresignedFileURL', 'infraEnvId', infraEnvId);
      // verify required parameter 'fileName' is not null or undefined
      assertParamExists('getInfraEnvPresignedFileURL', 'fileName', fileName);
      const localVarPath = `/v2/infra-envs/{infra_env_id}/downloads/files-presigned`.replace(
        `{${'infra_env_id'}}`,
        encodeURIComponent(String(infraEnvId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      if (fileName !== undefined) {
        localVarQueryParameter['file_name'] = fileName;
      }

      if (ipxeScriptType !== undefined) {
        localVarQueryParameter['ipxe_script_type'] = ipxeScriptType;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves the architecture support-levels for each OpenShift version.
     * @param {string} openshiftVersion Version of the OpenShift cluster.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSupportedArchitectures: async (
      openshiftVersion: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'openshiftVersion' is not null or undefined
      assertParamExists('getSupportedArchitectures', 'openshiftVersion', openshiftVersion);
      const localVarPath = `/v2/support-levels/architectures`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      if (openshiftVersion !== undefined) {
        localVarQueryParameter['openshift_version'] = openshiftVersion;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves the features support levels for each OpenShift version.
     * @param {string} openshiftVersion Version of the OpenShift cluster.
     * @param {GetSupportedFeaturesCpuArchitectureEnum} [cpuArchitecture] The CPU architecture of the image (x86_64/arm64/etc).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSupportedFeatures: async (
      openshiftVersion: string,
      cpuArchitecture?: GetSupportedFeaturesCpuArchitectureEnum,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'openshiftVersion' is not null or undefined
      assertParamExists('getSupportedFeatures', 'openshiftVersion', openshiftVersion);
      const localVarPath = `/v2/support-levels/features`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      if (openshiftVersion !== undefined) {
        localVarQueryParameter['openshift_version'] = openshiftVersion;
      }

      if (cpuArchitecture !== undefined) {
        localVarQueryParameter['cpu_architecture'] = cpuArchitecture;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of cluster hosts according to supplied filters.
     * @param {string} clusterId The cluster whose hosts should be retrieved.
     * @param {ListClusterHostsRoleEnum} [role] Role to request.
     * @param {string} [status] Hosts status to request.
     * @param {boolean} [withInventory] If true return the host\&#39;s inventory.
     * @param {boolean} [withConnectivity] If true return the host\&#39;s connectivity.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listClusterHosts: async (
      clusterId: string,
      role?: ListClusterHostsRoleEnum,
      status?: string,
      withInventory?: boolean,
      withConnectivity?: boolean,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterId' is not null or undefined
      assertParamExists('listClusterHosts', 'clusterId', clusterId);
      const localVarPath = `/v2/clusters/{cluster_id}/hosts`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      // authentication agentAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Secret-Key', configuration);

      if (role !== undefined) {
        localVarQueryParameter['role'] = role;
      }

      if (status !== undefined) {
        localVarQueryParameter['status'] = status;
      }

      if (withInventory !== undefined) {
        localVarQueryParameter['with-inventory'] = withInventory;
      }

      if (withConnectivity !== undefined) {
        localVarQueryParameter['with-connectivity'] = withConnectivity;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves the list of infra-envs.
     * @param {string} [clusterId] If provided, returns only infra-envs which directly reference this cluster.
     * @param {string} [owner] If provided, returns only infra-envs that are owned by the specified user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listInfraEnvs: async (
      clusterId?: string,
      owner?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v2/infra-envs`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      if (clusterId !== undefined) {
        localVarQueryParameter['cluster_id'] = clusterId;
      }

      if (owner !== undefined) {
        localVarQueryParameter['owner'] = owner;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Regenerate InfraEnv token signing key.
     * @param {string} infraEnvId The target InfraEnv.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    regenerateInfraEnvSigningKey: async (
      infraEnvId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'infraEnvId' is not null or undefined
      assertParamExists('regenerateInfraEnvSigningKey', 'infraEnvId', infraEnvId);
      const localVarPath = `/v2/infra-envs/{infra_env_id}/regenerate-signing-key`.replace(
        `{${'infra_env_id'}}`,
        encodeURIComponent(String(infraEnvId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates a new OpenShift Discovery ISO.
     * @param {InfraEnvCreateParams} infraenvCreateParams The parameters for the generated ISO.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerInfraEnv: async (
      infraenvCreateParams: InfraEnvCreateParams,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'infraenvCreateParams' is not null or undefined
      assertParamExists('registerInfraEnv', 'infraenvCreateParams', infraenvCreateParams);
      const localVarPath = `/v2/infra-envs`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        infraenvCreateParams,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Transforms installed cluster to a state which allows adding hosts.
     * @param {string} clusterId The cluster to transform.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transformClusterToAddingHosts: async (
      clusterId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterId' is not null or undefined
      assertParamExists('transformClusterToAddingHosts', 'clusterId', clusterId);
      const localVarPath = `/v2/clusters/{cluster_id}/actions/allow-add-hosts`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deprecated, maintained for legacy purposes. Does the same thing as allow-add-hosts. Use allow-add-hosts instead.
     * @param {string} clusterId The cluster to transform.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    transformClusterToDay2: async (
      clusterId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterId' is not null or undefined
      assertParamExists('transformClusterToDay2', 'clusterId', clusterId);
      const localVarPath = `/v2/clusters/{cluster_id}/actions/allow-add-workers`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Unbind host to a cluster
     * @param {string} infraEnvId The infra-env of the host that is being bound.
     * @param {string} hostId The host that is being bound.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unbindHost: async (
      infraEnvId: string,
      hostId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'infraEnvId' is not null or undefined
      assertParamExists('unbindHost', 'infraEnvId', infraEnvId);
      // verify required parameter 'hostId' is not null or undefined
      assertParamExists('unbindHost', 'hostId', hostId);
      const localVarPath = `/v2/infra-envs/{infra_env_id}/hosts/{host_id}/actions/unbind`
        .replace(`{${'infra_env_id'}}`, encodeURIComponent(String(infraEnvId)))
        .replace(`{${'host_id'}}`, encodeURIComponent(String(hostId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Updates an infra-env.
     * @param {string} infraEnvId The infra-env to be updated.
     * @param {InfraEnvUpdateParams} infraEnvUpdateParams The properties to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateInfraEnv: async (
      infraEnvId: string,
      infraEnvUpdateParams: InfraEnvUpdateParams,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'infraEnvId' is not null or undefined
      assertParamExists('updateInfraEnv', 'infraEnvId', infraEnvId);
      // verify required parameter 'infraEnvUpdateParams' is not null or undefined
      assertParamExists('updateInfraEnv', 'infraEnvUpdateParams', infraEnvUpdateParams);
      const localVarPath = `/v2/infra-envs/{infra_env_id}`.replace(
        `{${'infra_env_id'}}`,
        encodeURIComponent(String(infraEnvId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        infraEnvUpdateParams,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Cancels an ongoing installation.
     * @param {string} clusterId The cluster whose installation is to be canceled.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2CancelInstallation: async (
      clusterId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterId' is not null or undefined
      assertParamExists('v2CancelInstallation', 'clusterId', clusterId);
      const localVarPath = `/v2/clusters/{cluster_id}/actions/cancel`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Agent API to mark a finalizing installation as complete and progress to 100%.
     * @param {string} clusterId The cluster whose installation is being completing.
     * @param {CompletionParams} completionParams The final status of the cluster installation.
     * @param {string} [discoveryAgentVersion] The software version of the discovery agent that is completing the installation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2CompleteInstallation: async (
      clusterId: string,
      completionParams: CompletionParams,
      discoveryAgentVersion?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterId' is not null or undefined
      assertParamExists('v2CompleteInstallation', 'clusterId', clusterId);
      // verify required parameter 'completionParams' is not null or undefined
      assertParamExists('v2CompleteInstallation', 'completionParams', completionParams);
      const localVarPath = `/v2/clusters/{cluster_id}/actions/complete-installation`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication agentAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Secret-Key', configuration);

      if (discoveryAgentVersion != null) {
        localVarHeaderParameter['discovery_agent_version'] = String(discoveryAgentVersion);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        completionParams,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes an OpenShift cluster definition.
     * @param {string} clusterId The cluster to be deregistered.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2DeregisterCluster: async (
      clusterId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterId' is not null or undefined
      assertParamExists('v2DeregisterCluster', 'clusterId', clusterId);
      const localVarPath = `/v2/clusters/{cluster_id}`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deregisters an OpenShift host.
     * @param {string} infraEnvId The infra-env of the host that should be deregistered.
     * @param {string} hostId The host that should be deregistered.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2DeregisterHost: async (
      infraEnvId: string,
      hostId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'infraEnvId' is not null or undefined
      assertParamExists('v2DeregisterHost', 'infraEnvId', infraEnvId);
      // verify required parameter 'hostId' is not null or undefined
      assertParamExists('v2DeregisterHost', 'hostId', hostId);
      const localVarPath = `/v2/infra-envs/{infra_env_id}/hosts/{host_id}`
        .replace(`{${'infra_env_id'}}`, encodeURIComponent(String(infraEnvId)))
        .replace(`{${'host_id'}}`, encodeURIComponent(String(hostId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Downloads credentials relating to the installed/installing cluster.
     * @param {string} clusterId The cluster that owns the credential file that should be downloaded.
     * @param {V2DownloadClusterCredentialsFileNameEnum} fileName The credential file to be downloaded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2DownloadClusterCredentials: async (
      clusterId: string,
      fileName: V2DownloadClusterCredentialsFileNameEnum,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterId' is not null or undefined
      assertParamExists('v2DownloadClusterCredentials', 'clusterId', clusterId);
      // verify required parameter 'fileName' is not null or undefined
      assertParamExists('v2DownloadClusterCredentials', 'fileName', fileName);
      const localVarPath = `/v2/clusters/{cluster_id}/downloads/credentials`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication urlAuth required
      await setApiKeyToObject(localVarQueryParameter, 'api_key', configuration);

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      // authentication agentAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Secret-Key', configuration);

      if (fileName !== undefined) {
        localVarQueryParameter['file_name'] = fileName;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Downloads files relating to the installed/installing cluster.
     * @param {string} clusterId The cluster that owns the file that should be downloaded.
     * @param {V2DownloadClusterFilesFileNameEnum} fileName The file to be downloaded.
     * @param {string} [discoveryAgentVersion] The software version of the discovery agent that is downloading the file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2DownloadClusterFiles: async (
      clusterId: string,
      fileName: V2DownloadClusterFilesFileNameEnum,
      discoveryAgentVersion?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterId' is not null or undefined
      assertParamExists('v2DownloadClusterFiles', 'clusterId', clusterId);
      // verify required parameter 'fileName' is not null or undefined
      assertParamExists('v2DownloadClusterFiles', 'fileName', fileName);
      const localVarPath = `/v2/clusters/{cluster_id}/downloads/files`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication urlAuth required
      await setApiKeyToObject(localVarQueryParameter, 'api_key', configuration);

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      // authentication agentAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Secret-Key', configuration);

      if (fileName !== undefined) {
        localVarQueryParameter['file_name'] = fileName;
      }

      if (discoveryAgentVersion != null) {
        localVarHeaderParameter['discovery_agent_version'] = String(discoveryAgentVersion);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Download cluster logs.
     * @param {string} clusterId The cluster whose logs should be downloaded.
     * @param {V2DownloadClusterLogsLogsTypeEnum} [logsType] The type of logs to be downloaded.
     * @param {string} [hostId] A specific host in the cluster whose logs should be downloaded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2DownloadClusterLogs: async (
      clusterId: string,
      logsType?: V2DownloadClusterLogsLogsTypeEnum,
      hostId?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterId' is not null or undefined
      assertParamExists('v2DownloadClusterLogs', 'clusterId', clusterId);
      const localVarPath = `/v2/clusters/{cluster_id}/logs`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication urlAuth required
      await setApiKeyToObject(localVarQueryParameter, 'api_key', configuration);

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      if (logsType !== undefined) {
        localVarQueryParameter['logs_type'] = logsType;
      }

      if (hostId !== undefined) {
        localVarQueryParameter['host_id'] = hostId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Downloads the customized ignition file for this bound host, produces octet stream. For unbound host - error is returned
     * @param {string} infraEnvId The infra-env of the host whose ignition file should be downloaded.
     * @param {string} hostId The host whose ignition file should be downloaded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2DownloadHostIgnition: async (
      infraEnvId: string,
      hostId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'infraEnvId' is not null or undefined
      assertParamExists('v2DownloadHostIgnition', 'infraEnvId', infraEnvId);
      // verify required parameter 'hostId' is not null or undefined
      assertParamExists('v2DownloadHostIgnition', 'hostId', hostId);
      const localVarPath = `/v2/infra-env/{infra_env_id}/hosts/{host_id}/downloads/ignition`
        .replace(`{${'infra_env_id'}}`, encodeURIComponent(String(infraEnvId)))
        .replace(`{${'host_id'}}`, encodeURIComponent(String(hostId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      // authentication agentAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Secret-Key', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Downloads the customized ignition file for this host
     * @param {string} infraEnvId The infra-env whose file should be downloaded.
     * @param {V2DownloadInfraEnvFilesFileNameEnum} fileName The file to be downloaded.
     * @param {string} [mac] Mac address of the host running ipxe script.
     * @param {V2DownloadInfraEnvFilesIpxeScriptTypeEnum} [ipxeScriptType] Specify the script type to be served for iPXE.
     * @param {V2DownloadInfraEnvFilesDiscoveryIsoTypeEnum} [discoveryIsoType] Overrides the ISO type for the disovery ignition, either \&#39;full-iso\&#39; or \&#39;minimal-iso\&#39;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2DownloadInfraEnvFiles: async (
      infraEnvId: string,
      fileName: V2DownloadInfraEnvFilesFileNameEnum,
      mac?: string,
      ipxeScriptType?: V2DownloadInfraEnvFilesIpxeScriptTypeEnum,
      discoveryIsoType?: V2DownloadInfraEnvFilesDiscoveryIsoTypeEnum,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'infraEnvId' is not null or undefined
      assertParamExists('v2DownloadInfraEnvFiles', 'infraEnvId', infraEnvId);
      // verify required parameter 'fileName' is not null or undefined
      assertParamExists('v2DownloadInfraEnvFiles', 'fileName', fileName);
      const localVarPath = `/v2/infra-envs/{infra_env_id}/downloads/files`.replace(
        `{${'infra_env_id'}}`,
        encodeURIComponent(String(infraEnvId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication imageURLAuth required
      await setApiKeyToObject(localVarQueryParameter, 'image_token', configuration);

      // authentication urlAuth required
      await setApiKeyToObject(localVarQueryParameter, 'api_key', configuration);

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      // authentication imageAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Image-Token', configuration);

      // authentication agentAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Secret-Key', configuration);

      if (fileName !== undefined) {
        localVarQueryParameter['file_name'] = fileName;
      }

      if (mac !== undefined) {
        localVarQueryParameter['mac'] = mac;
      }

      if (ipxeScriptType !== undefined) {
        localVarQueryParameter['ipxe_script_type'] = ipxeScriptType;
      }

      if (discoveryIsoType !== undefined) {
        localVarQueryParameter['discovery_iso_type'] = discoveryIsoType;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves the details of the OpenShift cluster.
     * @param {string} clusterId The cluster to be retrieved.
     * @param {string} [discoveryAgentVersion] The software version of the discovery agent that is retrieving the cluster details.
     * @param {boolean} [getUnregisteredClusters] Whether to return clusters that have been unregistered.
     * @param {boolean} [excludeHosts] If true, do not include hosts.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2GetCluster: async (
      clusterId: string,
      discoveryAgentVersion?: string,
      getUnregisteredClusters?: boolean,
      excludeHosts?: boolean,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterId' is not null or undefined
      assertParamExists('v2GetCluster', 'clusterId', clusterId);
      const localVarPath = `/v2/clusters/{cluster_id}`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      // authentication agentAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Secret-Key', configuration);

      if (excludeHosts !== undefined) {
        localVarQueryParameter['exclude-hosts'] = excludeHosts;
      }

      if (discoveryAgentVersion != null) {
        localVarHeaderParameter['discovery_agent_version'] = String(discoveryAgentVersion);
      }

      if (getUnregisteredClusters != null) {
        localVarHeaderParameter['get_unregistered_clusters'] =
          typeof getUnregisteredClusters === 'string'
            ? getUnregisteredClusters
            : JSON.stringify(getUnregisteredClusters);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the default values for various cluster properties.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2GetClusterDefaultConfig: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v2/clusters/default-config`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the cluster\'s install config YAML.
     * @param {string} clusterId The cluster whose install config is being retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2GetClusterInstallConfig: async (
      clusterId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterId' is not null or undefined
      assertParamExists('v2GetClusterInstallConfig', 'clusterId', clusterId);
      const localVarPath = `/v2/clusters/{cluster_id}/install-config`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Fetch cluster specific UI settings.
     * @param {string} clusterId The cluster for which UI settings should be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2GetClusterUISettings: async (
      clusterId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterId' is not null or undefined
      assertParamExists('v2GetClusterUISettings', 'clusterId', clusterId);
      const localVarPath = `/v2/clusters/{cluster_id}/ui-settings`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the cluster admin credentials.
     * @param {string} clusterId The cluster whose admin credentials should be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2GetCredentials: async (
      clusterId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterId' is not null or undefined
      assertParamExists('v2GetCredentials', 'clusterId', clusterId);
      const localVarPath = `/v2/clusters/{cluster_id}/credentials`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves the details of the OpenShift host.
     * @param {string} infraEnvId The infra-env of the host that should be retrieved.
     * @param {string} hostId The host that should be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2GetHost: async (
      infraEnvId: string,
      hostId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'infraEnvId' is not null or undefined
      assertParamExists('v2GetHost', 'infraEnvId', infraEnvId);
      // verify required parameter 'hostId' is not null or undefined
      assertParamExists('v2GetHost', 'hostId', hostId);
      const localVarPath = `/v2/infra-envs/{infra_env_id}/hosts/{host_id}`
        .replace(`{${'infra_env_id'}}`, encodeURIComponent(String(infraEnvId)))
        .replace(`{${'host_id'}}`, encodeURIComponent(String(hostId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Fetch the ignition file for this host as a string. In case of unbound host produces an error
     * @param {string} infraEnvId The infra-env of the host whose ignition file should be obtained.
     * @param {string} hostId The host whose ignition file should be obtained.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2GetHostIgnition: async (
      infraEnvId: string,
      hostId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'infraEnvId' is not null or undefined
      assertParamExists('v2GetHostIgnition', 'infraEnvId', infraEnvId);
      // verify required parameter 'hostId' is not null or undefined
      assertParamExists('v2GetHostIgnition', 'hostId', hostId);
      const localVarPath = `/v2/infra-envs/{infra_env_id}/hosts/{host_id}/ignition`
        .replace(`{${'infra_env_id'}}`, encodeURIComponent(String(infraEnvId)))
        .replace(`{${'host_id'}}`, encodeURIComponent(String(hostId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Fetch the validations which are to be ignored for this cluster.
     * @param {string} clusterId The cluster whose failing validations should be ignored according to this list.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2GetIgnoredValidations: async (
      clusterId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterId' is not null or undefined
      assertParamExists('v2GetIgnoredValidations', 'clusterId', clusterId);
      const localVarPath = `/v2/clusters/{cluster_id}/ignored-validations`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves the next operations that the host agent needs to perform.
     * @param {string} infraEnvId The infra-env of the host that is retrieving instructions.
     * @param {string} hostId The host that is retrieving instructions.
     * @param {number} [timestamp] The time on the host as seconds since the Unix epoch.
     * @param {string} [discoveryAgentVersion] The software version of the discovery agent that is retrieving instructions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2GetNextSteps: async (
      infraEnvId: string,
      hostId: string,
      timestamp?: number,
      discoveryAgentVersion?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'infraEnvId' is not null or undefined
      assertParamExists('v2GetNextSteps', 'infraEnvId', infraEnvId);
      // verify required parameter 'hostId' is not null or undefined
      assertParamExists('v2GetNextSteps', 'hostId', hostId);
      const localVarPath = `/v2/infra-envs/{infra_env_id}/hosts/{host_id}/instructions`
        .replace(`{${'infra_env_id'}}`, encodeURIComponent(String(infraEnvId)))
        .replace(`{${'host_id'}}`, encodeURIComponent(String(hostId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication agentAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Secret-Key', configuration);

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (discoveryAgentVersion != null) {
        localVarHeaderParameter['discovery_agent_version'] = String(discoveryAgentVersion);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get preflight requirements for a cluster.
     * @param {string} clusterId The cluster to return preflight requirements for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2GetPreflightRequirements: async (
      clusterId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterId' is not null or undefined
      assertParamExists('v2GetPreflightRequirements', 'clusterId', clusterId);
      const localVarPath = `/v2/clusters/{cluster_id}/preflight-requirements`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the cluster admin credentials.
     * @param {string} clusterId The cluster that owns the file that should be downloaded.
     * @param {V2GetPresignedForClusterCredentialsFileNameEnum} fileName The file to be downloaded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2GetPresignedForClusterCredentials: async (
      clusterId: string,
      fileName: V2GetPresignedForClusterCredentialsFileNameEnum,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterId' is not null or undefined
      assertParamExists('v2GetPresignedForClusterCredentials', 'clusterId', clusterId);
      // verify required parameter 'fileName' is not null or undefined
      assertParamExists('v2GetPresignedForClusterCredentials', 'fileName', fileName);
      const localVarPath = `/v2/clusters/{cluster_id}/downloads/credentials-presigned`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      if (fileName !== undefined) {
        localVarQueryParameter['file_name'] = fileName;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves a pre-signed S3 URL for downloading cluster files.
     * @param {string} clusterId The cluster that owns the file that should be downloaded.
     * @param {V2GetPresignedForClusterFilesFileNameEnum} fileName The file to be downloaded.
     * @param {V2GetPresignedForClusterFilesLogsTypeEnum} [logsType] If downloading logs, the type of logs to download.
     * @param {string} [hostId] If downloading a file related to a host, the relevant host.
     * @param {string} [additionalName] If downloading a manifest, the file name, prefaced with folder name, for example, openshift/99-openshift-xyz.yaml.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2GetPresignedForClusterFiles: async (
      clusterId: string,
      fileName: V2GetPresignedForClusterFilesFileNameEnum,
      logsType?: V2GetPresignedForClusterFilesLogsTypeEnum,
      hostId?: string,
      additionalName?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterId' is not null or undefined
      assertParamExists('v2GetPresignedForClusterFiles', 'clusterId', clusterId);
      // verify required parameter 'fileName' is not null or undefined
      assertParamExists('v2GetPresignedForClusterFiles', 'fileName', fileName);
      const localVarPath = `/v2/clusters/{cluster_id}/downloads/files-presigned`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      if (fileName !== undefined) {
        localVarQueryParameter['file_name'] = fileName;
      }

      if (logsType !== undefined) {
        localVarQueryParameter['logs_type'] = logsType;
      }

      if (hostId !== undefined) {
        localVarQueryParameter['host_id'] = hostId;
      }

      if (additionalName !== undefined) {
        localVarQueryParameter['additional_name'] = additionalName;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Import an AI cluster using minimal data associated with existing OCP cluster, in order to allow adding day2 hosts to that cluster
     * @param {ImportClusterParams} newImportClusterParams Parameters for importing a OCP cluster for adding nodes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2ImportCluster: async (
      newImportClusterParams: ImportClusterParams,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'newImportClusterParams' is not null or undefined
      assertParamExists('v2ImportCluster', 'newImportClusterParams', newImportClusterParams);
      const localVarPath = `/v2/clusters/import`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        newImportClusterParams,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Installs the OpenShift cluster.
     * @param {string} clusterId The cluster to be installed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2InstallCluster: async (
      clusterId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterId' is not null or undefined
      assertParamExists('v2InstallCluster', 'clusterId', clusterId);
      const localVarPath = `/v2/clusters/{cluster_id}/actions/install`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * install specific host for day2 cluster.
     * @param {string} infraEnvId The infra-env of the host that is being installed.
     * @param {string} hostId The host that is being installed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2InstallHost: async (
      infraEnvId: string,
      hostId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'infraEnvId' is not null or undefined
      assertParamExists('v2InstallHost', 'infraEnvId', infraEnvId);
      // verify required parameter 'hostId' is not null or undefined
      assertParamExists('v2InstallHost', 'hostId', hostId);
      const localVarPath = `/v2/infra-envs/{infra_env_id}/hosts/{host_id}/actions/install`
        .replace(`{${'infra_env_id'}}`, encodeURIComponent(String(infraEnvId)))
        .replace(`{${'host_id'}}`, encodeURIComponent(String(hostId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves the list of OpenShift clusters.
     * @param {boolean} [getUnregisteredClusters] Whether to return clusters that have been unregistered.
     * @param {string} [openshiftClusterId] A specific cluster to retrieve.
     * @param {Array<string>} [amsSubscriptionIds] If non-empty, returned Clusters are filtered to those with matching subscription IDs.
     * @param {boolean} [withHosts] Include hosts in the returned list.
     * @param {string} [owner] If provided, returns only clusters that are owned by the specified user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2ListClusters: async (
      getUnregisteredClusters?: boolean,
      openshiftClusterId?: string,
      amsSubscriptionIds?: Array<string>,
      withHosts?: boolean,
      owner?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v2/clusters`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      if (openshiftClusterId !== undefined) {
        localVarQueryParameter['openshift_cluster_id'] = openshiftClusterId;
      }

      if (amsSubscriptionIds) {
        localVarQueryParameter['ams_subscription_ids'] = amsSubscriptionIds.join(
          COLLECTION_FORMATS.csv,
        );
      }

      if (withHosts !== undefined) {
        localVarQueryParameter['with_hosts'] = withHosts;
      }

      if (owner !== undefined) {
        localVarQueryParameter['owner'] = owner;
      }

      if (getUnregisteredClusters != null) {
        localVarHeaderParameter['get_unregistered_clusters'] =
          typeof getUnregisteredClusters === 'string'
            ? getUnregisteredClusters
            : JSON.stringify(getUnregisteredClusters);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * (DEPRECATED) Retrieves the support levels for features for each OpenShift version.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    v2ListFeatureSupportLevels: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v2/feature-support-levels`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves the list of OpenShift hosts that belong the infra-env.
     * @param {string} infraEnvId The infra-env that the hosts are asociated with.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2ListHosts: async (
      infraEnvId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'infraEnvId' is not null or undefined
      assertParamExists('v2ListHosts', 'infraEnvId', infraEnvId);
      const localVarPath = `/v2/infra-envs/{infra_env_id}/hosts`.replace(
        `{${'infra_env_id'}}`,
        encodeURIComponent(String(infraEnvId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      // authentication agentAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Secret-Key', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Lists operators to be monitored for a cluster.
     * @param {string} clusterId The cluster to return operators for.
     * @param {string} [operatorName] An operator in the specified cluster to return its data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2ListOfClusterOperators: async (
      clusterId: string,
      operatorName?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterId' is not null or undefined
      assertParamExists('v2ListOfClusterOperators', 'clusterId', clusterId);
      const localVarPath = `/v2/clusters/{cluster_id}/monitored-operators`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication agentAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Secret-Key', configuration);

      if (operatorName !== undefined) {
        localVarQueryParameter['operator_name'] = operatorName;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Posts the result of the operations from the host agent.
     * @param {string} infraEnvId The infra-env of the host that is posting results.
     * @param {string} hostId The host that is posting results.
     * @param {string} [discoveryAgentVersion] The software version of the discovery agent that is posting results.
     * @param {StepReply} [reply] The results to be posted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2PostStepReply: async (
      infraEnvId: string,
      hostId: string,
      discoveryAgentVersion?: string,
      reply?: StepReply,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'infraEnvId' is not null or undefined
      assertParamExists('v2PostStepReply', 'infraEnvId', infraEnvId);
      // verify required parameter 'hostId' is not null or undefined
      assertParamExists('v2PostStepReply', 'hostId', hostId);
      const localVarPath = `/v2/infra-envs/{infra_env_id}/hosts/{host_id}/instructions`
        .replace(`{${'infra_env_id'}}`, encodeURIComponent(String(infraEnvId)))
        .replace(`{${'host_id'}}`, encodeURIComponent(String(hostId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication agentAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Secret-Key', configuration);

      if (discoveryAgentVersion != null) {
        localVarHeaderParameter['discovery_agent_version'] = String(discoveryAgentVersion);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        reply,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates a new OpenShift cluster definition.
     * @param {ClusterCreateParams} newClusterParams The properties describing the new cluster.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2RegisterCluster: async (
      newClusterParams: ClusterCreateParams,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'newClusterParams' is not null or undefined
      assertParamExists('v2RegisterCluster', 'newClusterParams', newClusterParams);
      const localVarPath = `/v2/clusters`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        newClusterParams,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Registers a new OpenShift agent.
     * @param {string} infraEnvId The infra-env that the agent is associated with.
     * @param {HostCreateParams} newHostParams The description of the agent being registered.
     * @param {string} [discoveryAgentVersion] The software version of the discovery agent that is registering the agent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2RegisterHost: async (
      infraEnvId: string,
      newHostParams: HostCreateParams,
      discoveryAgentVersion?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'infraEnvId' is not null or undefined
      assertParamExists('v2RegisterHost', 'infraEnvId', infraEnvId);
      // verify required parameter 'newHostParams' is not null or undefined
      assertParamExists('v2RegisterHost', 'newHostParams', newHostParams);
      const localVarPath = `/v2/infra-envs/{infra_env_id}/hosts`.replace(
        `{${'infra_env_id'}}`,
        encodeURIComponent(String(infraEnvId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication agentAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Secret-Key', configuration);

      if (discoveryAgentVersion != null) {
        localVarHeaderParameter['discovery_agent_version'] = String(discoveryAgentVersion);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        newHostParams,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Controller API to report of monitored operators.
     * @param {string} clusterId The cluster whose operators are being monitored.
     * @param {OperatorMonitorReport} reportParams The operators monitor report.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2ReportMonitoredOperatorStatus: async (
      clusterId: string,
      reportParams: OperatorMonitorReport,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterId' is not null or undefined
      assertParamExists('v2ReportMonitoredOperatorStatus', 'clusterId', clusterId);
      // verify required parameter 'reportParams' is not null or undefined
      assertParamExists('v2ReportMonitoredOperatorStatus', 'reportParams', reportParams);
      const localVarPath = `/v2/clusters/{cluster_id}/monitored-operators`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication agentAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Secret-Key', configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        reportParams,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Resets a failed installation.
     * @param {string} clusterId The cluster whose installation is to be reset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2ResetCluster: async (
      clusterId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterId' is not null or undefined
      assertParamExists('v2ResetCluster', 'clusterId', clusterId);
      const localVarPath = `/v2/clusters/{cluster_id}/actions/reset`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * reset a failed host for day2 cluster.
     * @param {string} infraEnvId The infra-env of the host that is being reset.
     * @param {string} hostId The host that is being reset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2ResetHost: async (
      infraEnvId: string,
      hostId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'infraEnvId' is not null or undefined
      assertParamExists('v2ResetHost', 'infraEnvId', infraEnvId);
      // verify required parameter 'hostId' is not null or undefined
      assertParamExists('v2ResetHost', 'hostId', hostId);
      const localVarPath = `/v2/infra-envs/{infra_env_id}/hosts/{host_id}/actions/reset`
        .replace(`{${'infra_env_id'}}`, encodeURIComponent(String(infraEnvId)))
        .replace(`{${'host_id'}}`, encodeURIComponent(String(hostId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Reset failed host validation. It may be performed on any host validation with persistent validation result.
     * @summary Reset failed host validation.
     * @param {string} infraEnvId The infra-env of the host that its validation is being reset.
     * @param {string} hostId The host that its validation is being reset.
     * @param {string} validationId The id of the validation being reset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2ResetHostValidation: async (
      infraEnvId: string,
      hostId: string,
      validationId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'infraEnvId' is not null or undefined
      assertParamExists('v2ResetHostValidation', 'infraEnvId', infraEnvId);
      // verify required parameter 'hostId' is not null or undefined
      assertParamExists('v2ResetHostValidation', 'hostId', hostId);
      // verify required parameter 'validationId' is not null or undefined
      assertParamExists('v2ResetHostValidation', 'validationId', validationId);
      const localVarPath =
        `/v2/infra-envs/{infra_env_id}/hosts/{host_id}/actions/reset-validation/{validation_id}`
          .replace(`{${'infra_env_id'}}`, encodeURIComponent(String(infraEnvId)))
          .replace(`{${'host_id'}}`, encodeURIComponent(String(hostId)))
          .replace(`{${'validation_id'}}`, encodeURIComponent(String(validationId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Register the validations which are to be ignored for this cluster.
     * @param {string} clusterId The cluster whose failing validations should be ignored according to this list.
     * @param {IgnoredValidations} ignoredValidations The validations to be ignored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2SetIgnoredValidations: async (
      clusterId: string,
      ignoredValidations: IgnoredValidations,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterId' is not null or undefined
      assertParamExists('v2SetIgnoredValidations', 'clusterId', clusterId);
      // verify required parameter 'ignoredValidations' is not null or undefined
      assertParamExists('v2SetIgnoredValidations', 'ignoredValidations', ignoredValidations);
      const localVarPath = `/v2/clusters/{cluster_id}/ignored-validations`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        ignoredValidations,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Updates an OpenShift cluster definition.
     * @param {string} clusterId The cluster to be updated.
     * @param {V2ClusterUpdateParams} clusterUpdateParams The properties to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2UpdateCluster: async (
      clusterId: string,
      clusterUpdateParams: V2ClusterUpdateParams,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterId' is not null or undefined
      assertParamExists('v2UpdateCluster', 'clusterId', clusterId);
      // verify required parameter 'clusterUpdateParams' is not null or undefined
      assertParamExists('v2UpdateCluster', 'clusterUpdateParams', clusterUpdateParams);
      const localVarPath = `/v2/clusters/{cluster_id}`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        clusterUpdateParams,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Override values in the install config.
     * @param {string} clusterId The cluster whose install config is being updated.
     * @param {string} installConfigParams Install config overrides.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2UpdateClusterInstallConfig: async (
      clusterId: string,
      installConfigParams: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterId' is not null or undefined
      assertParamExists('v2UpdateClusterInstallConfig', 'clusterId', clusterId);
      // verify required parameter 'installConfigParams' is not null or undefined
      assertParamExists('v2UpdateClusterInstallConfig', 'installConfigParams', installConfigParams);
      const localVarPath = `/v2/clusters/{cluster_id}/install-config`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        installConfigParams,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update log collection state and progress.
     * @param {string} clusterId The cluster whose log progress is being updated.
     * @param {LogsProgressParams} logsProgressParams Parameters for updating log progress.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2UpdateClusterLogsProgress: async (
      clusterId: string,
      logsProgressParams: LogsProgressParams,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterId' is not null or undefined
      assertParamExists('v2UpdateClusterLogsProgress', 'clusterId', clusterId);
      // verify required parameter 'logsProgressParams' is not null or undefined
      assertParamExists('v2UpdateClusterLogsProgress', 'logsProgressParams', logsProgressParams);
      const localVarPath = `/v2/clusters/{cluster_id}/logs-progress`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication agentAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Secret-Key', configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        logsProgressParams,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update cluster specific UI settings.
     * @param {string} clusterId The cluster for which UI settings should be updated.
     * @param {string} uiSettings Settings for the installer UI.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2UpdateClusterUISettings: async (
      clusterId: string,
      uiSettings: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterId' is not null or undefined
      assertParamExists('v2UpdateClusterUISettings', 'clusterId', clusterId);
      // verify required parameter 'uiSettings' is not null or undefined
      assertParamExists('v2UpdateClusterUISettings', 'uiSettings', uiSettings);
      const localVarPath = `/v2/clusters/{cluster_id}/ui-settings`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        uiSettings,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update an Openshift host
     * @param {string} infraEnvId The infra-env ID of the host to be updated.
     * @param {string} hostId The host that should be updated.
     * @param {HostUpdateParams} hostUpdateParams The properties to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2UpdateHost: async (
      infraEnvId: string,
      hostId: string,
      hostUpdateParams: HostUpdateParams,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'infraEnvId' is not null or undefined
      assertParamExists('v2UpdateHost', 'infraEnvId', infraEnvId);
      // verify required parameter 'hostId' is not null or undefined
      assertParamExists('v2UpdateHost', 'hostId', hostId);
      // verify required parameter 'hostUpdateParams' is not null or undefined
      assertParamExists('v2UpdateHost', 'hostUpdateParams', hostUpdateParams);
      const localVarPath = `/v2/infra-envs/{infra_env_id}/hosts/{host_id}`
        .replace(`{${'infra_env_id'}}`, encodeURIComponent(String(infraEnvId)))
        .replace(`{${'host_id'}}`, encodeURIComponent(String(hostId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        hostUpdateParams,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Patch the ignition file for this host
     * @param {string} infraEnvId The infra-env of the host whose ignition file should be updated.
     * @param {string} hostId The host whose ignition file should be updated.
     * @param {HostIgnitionParams} hostIgnitionParams Ignition config overrides.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2UpdateHostIgnition: async (
      infraEnvId: string,
      hostId: string,
      hostIgnitionParams: HostIgnitionParams,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'infraEnvId' is not null or undefined
      assertParamExists('v2UpdateHostIgnition', 'infraEnvId', infraEnvId);
      // verify required parameter 'hostId' is not null or undefined
      assertParamExists('v2UpdateHostIgnition', 'hostId', hostId);
      // verify required parameter 'hostIgnitionParams' is not null or undefined
      assertParamExists('v2UpdateHostIgnition', 'hostIgnitionParams', hostIgnitionParams);
      const localVarPath = `/v2/infra-envs/{infra_env_id}/hosts/{host_id}/ignition`
        .replace(`{${'infra_env_id'}}`, encodeURIComponent(String(infraEnvId)))
        .replace(`{${'host_id'}}`, encodeURIComponent(String(hostId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        hostIgnitionParams,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update installation progress.
     * @param {string} infraEnvId The infra-env of the host being updated.
     * @param {string} hostId The ID of the host to update.
     * @param {HostProgress} hostProgress New progress value.
     * @param {string} [discoveryAgentVersion] The software version of the discovery agent that is updating progress.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2UpdateHostInstallProgress: async (
      infraEnvId: string,
      hostId: string,
      hostProgress: HostProgress,
      discoveryAgentVersion?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'infraEnvId' is not null or undefined
      assertParamExists('v2UpdateHostInstallProgress', 'infraEnvId', infraEnvId);
      // verify required parameter 'hostId' is not null or undefined
      assertParamExists('v2UpdateHostInstallProgress', 'hostId', hostId);
      // verify required parameter 'hostProgress' is not null or undefined
      assertParamExists('v2UpdateHostInstallProgress', 'hostProgress', hostProgress);
      const localVarPath = `/v2/infra-envs/{infra_env_id}/hosts/{host_id}/progress`
        .replace(`{${'infra_env_id'}}`, encodeURIComponent(String(infraEnvId)))
        .replace(`{${'host_id'}}`, encodeURIComponent(String(hostId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication agentAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Secret-Key', configuration);

      if (discoveryAgentVersion != null) {
        localVarHeaderParameter['discovery_agent_version'] = String(discoveryAgentVersion);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        hostProgress,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Updates a host\'s installer arguments.
     * @param {string} infraEnvId The infra-env of the host whose installer arguments should be updated.
     * @param {string} hostId The host whose installer arguments should be updated.
     * @param {InstallerArgsParams} installerArgsParams The updated installer arguments.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2UpdateHostInstallerArgs: async (
      infraEnvId: string,
      hostId: string,
      installerArgsParams: InstallerArgsParams,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'infraEnvId' is not null or undefined
      assertParamExists('v2UpdateHostInstallerArgs', 'infraEnvId', infraEnvId);
      // verify required parameter 'hostId' is not null or undefined
      assertParamExists('v2UpdateHostInstallerArgs', 'hostId', hostId);
      // verify required parameter 'installerArgsParams' is not null or undefined
      assertParamExists('v2UpdateHostInstallerArgs', 'installerArgsParams', installerArgsParams);
      const localVarPath = `/v2/infra-envs/{infra_env_id}/hosts/{host_id}/installer-args`
        .replace(`{${'infra_env_id'}}`, encodeURIComponent(String(infraEnvId)))
        .replace(`{${'host_id'}}`, encodeURIComponent(String(hostId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        installerArgsParams,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update log collection state and progress.
     * @param {string} infraEnvId The infra-env whose log progress is being updated.
     * @param {string} hostId The host whose log progress is being updated.
     * @param {LogsProgressParams} logsProgressParams Parameters for updating log progress.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2UpdateHostLogsProgress: async (
      infraEnvId: string,
      hostId: string,
      logsProgressParams: LogsProgressParams,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'infraEnvId' is not null or undefined
      assertParamExists('v2UpdateHostLogsProgress', 'infraEnvId', infraEnvId);
      // verify required parameter 'hostId' is not null or undefined
      assertParamExists('v2UpdateHostLogsProgress', 'hostId', hostId);
      // verify required parameter 'logsProgressParams' is not null or undefined
      assertParamExists('v2UpdateHostLogsProgress', 'logsProgressParams', logsProgressParams);
      const localVarPath = `/v2/infra-envs/{infra_env_id}/hosts/{host_id}/logs-progress`
        .replace(`{${'infra_env_id'}}`, encodeURIComponent(String(infraEnvId)))
        .replace(`{${'host_id'}}`, encodeURIComponent(String(hostId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication agentAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Secret-Key', configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        logsProgressParams,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Transfer the ingress certificate for the cluster.
     * @param {string} clusterId The cluster to associate with the ingress certificate.
     * @param {string} ingressCertParams The ingress certificate.
     * @param {string} [discoveryAgentVersion] The software version of the discovery agent that is uploading the ingress certificate.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2UploadClusterIngressCert: async (
      clusterId: string,
      ingressCertParams: string,
      discoveryAgentVersion?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterId' is not null or undefined
      assertParamExists('v2UploadClusterIngressCert', 'clusterId', clusterId);
      // verify required parameter 'ingressCertParams' is not null or undefined
      assertParamExists('v2UploadClusterIngressCert', 'ingressCertParams', ingressCertParams);
      const localVarPath = `/v2/clusters/{cluster_id}/uploads/ingress-cert`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication agentAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Secret-Key', configuration);

      if (discoveryAgentVersion != null) {
        localVarHeaderParameter['discovery_agent_version'] = String(discoveryAgentVersion);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        ingressCertParams,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Agent API to upload logs.
     * @param {string} clusterId The cluster whose logs should be uploaded.
     * @param {V2UploadLogsLogsTypeEnum} logsType The type of log file to be uploaded.
     * @param {string} [infraEnvId] The infra-env ID of the host.
     * @param {string} [hostId] The host whose logs should be uploaded.
     * @param {File} [upfile] The log file to be uploaded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2UploadLogs: async (
      clusterId: string,
      logsType: V2UploadLogsLogsTypeEnum,
      infraEnvId?: string,
      hostId?: string,
      upfile?: File,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterId' is not null or undefined
      assertParamExists('v2UploadLogs', 'clusterId', clusterId);
      // verify required parameter 'logsType' is not null or undefined
      assertParamExists('v2UploadLogs', 'logsType', logsType);
      const localVarPath = `/v2/clusters/{cluster_id}/logs`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

      // authentication agentAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Secret-Key', configuration);

      if (logsType !== undefined) {
        localVarQueryParameter['logs_type'] = logsType;
      }

      if (infraEnvId !== undefined) {
        localVarQueryParameter['infra_env_id'] = infraEnvId;
      }

      if (hostId !== undefined) {
        localVarQueryParameter['host_id'] = hostId;
      }

      if (upfile !== undefined) {
        localVarFormParams.append('upfile', upfile as any);
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * InstallerApi - functional programming interface
 * @export
 */
export const InstallerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = InstallerApiAxiosParamCreator(configuration);
  return {
    /**
     * Bind host to a cluster
     * @param {string} infraEnvId The infra-env of the host that is being bound.
     * @param {string} hostId The host that is being bound.
     * @param {BindHostParams} bindHostParams The parameters for the host binding.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bindHost(
      infraEnvId: string,
      hostId: string,
      bindHostParams: BindHostParams,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Host>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bindHost(
        infraEnvId,
        hostId,
        bindHostParams,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Deletes an infra-env.
     * @param {string} infraEnvId The infra-env to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deregisterInfraEnv(
      infraEnvId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deregisterInfraEnv(
        infraEnvId,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get the initial ramdisk for minimal ISO based installations.
     * @param {string} infraEnvId The infra-env of the host that should be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async downloadMinimalInitrd(
      infraEnvId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.downloadMinimalInitrd(
        infraEnvId,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * A list of platforms that this cluster can support in its current configuration.
     * @param {string} clusterId The cluster whose platform types should be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getClusterSupportedPlatforms(
      clusterId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PlatformType>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getClusterSupportedPlatforms(
        clusterId,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Retrieves the details of the infra-env.
     * @param {string} infraEnvId The infra-env to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getInfraEnv(
      infraEnvId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InfraEnv>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getInfraEnv(infraEnvId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Creates a new pre-signed image download URL for the infra-env.
     * @param {string} infraEnvId The infra-env to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getInfraEnvDownloadURL(
      infraEnvId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PresignedUrl>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getInfraEnvDownloadURL(
        infraEnvId,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Creates a new pre-signed download URL for the infra-env.
     * @param {string} infraEnvId The file\&#39;s infra-env.
     * @param {GetInfraEnvPresignedFileURLFileNameEnum} fileName The file to be downloaded.
     * @param {GetInfraEnvPresignedFileURLIpxeScriptTypeEnum} [ipxeScriptType] Specify the script type to be served for iPXE.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getInfraEnvPresignedFileURL(
      infraEnvId: string,
      fileName: GetInfraEnvPresignedFileURLFileNameEnum,
      ipxeScriptType?: GetInfraEnvPresignedFileURLIpxeScriptTypeEnum,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PresignedUrl>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getInfraEnvPresignedFileURL(
        infraEnvId,
        fileName,
        ipxeScriptType,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Retrieves the architecture support-levels for each OpenShift version.
     * @param {string} openshiftVersion Version of the OpenShift cluster.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSupportedArchitectures(
      openshiftVersion: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GetSupportedArchitectures200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSupportedArchitectures(
        openshiftVersion,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Retrieves the features support levels for each OpenShift version.
     * @param {string} openshiftVersion Version of the OpenShift cluster.
     * @param {GetSupportedFeaturesCpuArchitectureEnum} [cpuArchitecture] The CPU architecture of the image (x86_64/arm64/etc).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSupportedFeatures(
      openshiftVersion: string,
      cpuArchitecture?: GetSupportedFeaturesCpuArchitectureEnum,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSupportedFeatures200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSupportedFeatures(
        openshiftVersion,
        cpuArchitecture,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get a list of cluster hosts according to supplied filters.
     * @param {string} clusterId The cluster whose hosts should be retrieved.
     * @param {ListClusterHostsRoleEnum} [role] Role to request.
     * @param {string} [status] Hosts status to request.
     * @param {boolean} [withInventory] If true return the host\&#39;s inventory.
     * @param {boolean} [withConnectivity] If true return the host\&#39;s connectivity.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listClusterHosts(
      clusterId: string,
      role?: ListClusterHostsRoleEnum,
      status?: string,
      withInventory?: boolean,
      withConnectivity?: boolean,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HostList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listClusterHosts(
        clusterId,
        role,
        status,
        withInventory,
        withConnectivity,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Retrieves the list of infra-envs.
     * @param {string} [clusterId] If provided, returns only infra-envs which directly reference this cluster.
     * @param {string} [owner] If provided, returns only infra-envs that are owned by the specified user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listInfraEnvs(
      clusterId?: string,
      owner?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InfraEnvList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listInfraEnvs(
        clusterId,
        owner,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Regenerate InfraEnv token signing key.
     * @param {string} infraEnvId The target InfraEnv.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async regenerateInfraEnvSigningKey(
      infraEnvId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.regenerateInfraEnvSigningKey(
        infraEnvId,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Creates a new OpenShift Discovery ISO.
     * @param {InfraEnvCreateParams} infraenvCreateParams The parameters for the generated ISO.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async registerInfraEnv(
      infraenvCreateParams: InfraEnvCreateParams,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InfraEnv>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.registerInfraEnv(
        infraenvCreateParams,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Transforms installed cluster to a state which allows adding hosts.
     * @param {string} clusterId The cluster to transform.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async transformClusterToAddingHosts(
      clusterId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cluster>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.transformClusterToAddingHosts(
        clusterId,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Deprecated, maintained for legacy purposes. Does the same thing as allow-add-hosts. Use allow-add-hosts instead.
     * @param {string} clusterId The cluster to transform.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async transformClusterToDay2(
      clusterId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cluster>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.transformClusterToDay2(
        clusterId,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Unbind host to a cluster
     * @param {string} infraEnvId The infra-env of the host that is being bound.
     * @param {string} hostId The host that is being bound.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unbindHost(
      infraEnvId: string,
      hostId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Host>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.unbindHost(
        infraEnvId,
        hostId,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Updates an infra-env.
     * @param {string} infraEnvId The infra-env to be updated.
     * @param {InfraEnvUpdateParams} infraEnvUpdateParams The properties to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateInfraEnv(
      infraEnvId: string,
      infraEnvUpdateParams: InfraEnvUpdateParams,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InfraEnv>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateInfraEnv(
        infraEnvId,
        infraEnvUpdateParams,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Cancels an ongoing installation.
     * @param {string} clusterId The cluster whose installation is to be canceled.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2CancelInstallation(
      clusterId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cluster>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2CancelInstallation(
        clusterId,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Agent API to mark a finalizing installation as complete and progress to 100%.
     * @param {string} clusterId The cluster whose installation is being completing.
     * @param {CompletionParams} completionParams The final status of the cluster installation.
     * @param {string} [discoveryAgentVersion] The software version of the discovery agent that is completing the installation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2CompleteInstallation(
      clusterId: string,
      completionParams: CompletionParams,
      discoveryAgentVersion?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cluster>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2CompleteInstallation(
        clusterId,
        completionParams,
        discoveryAgentVersion,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Deletes an OpenShift cluster definition.
     * @param {string} clusterId The cluster to be deregistered.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2DeregisterCluster(
      clusterId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2DeregisterCluster(
        clusterId,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Deregisters an OpenShift host.
     * @param {string} infraEnvId The infra-env of the host that should be deregistered.
     * @param {string} hostId The host that should be deregistered.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2DeregisterHost(
      infraEnvId: string,
      hostId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2DeregisterHost(
        infraEnvId,
        hostId,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Downloads credentials relating to the installed/installing cluster.
     * @param {string} clusterId The cluster that owns the credential file that should be downloaded.
     * @param {V2DownloadClusterCredentialsFileNameEnum} fileName The credential file to be downloaded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2DownloadClusterCredentials(
      clusterId: string,
      fileName: V2DownloadClusterCredentialsFileNameEnum,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2DownloadClusterCredentials(
        clusterId,
        fileName,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Downloads files relating to the installed/installing cluster.
     * @param {string} clusterId The cluster that owns the file that should be downloaded.
     * @param {V2DownloadClusterFilesFileNameEnum} fileName The file to be downloaded.
     * @param {string} [discoveryAgentVersion] The software version of the discovery agent that is downloading the file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2DownloadClusterFiles(
      clusterId: string,
      fileName: V2DownloadClusterFilesFileNameEnum,
      discoveryAgentVersion?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2DownloadClusterFiles(
        clusterId,
        fileName,
        discoveryAgentVersion,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Download cluster logs.
     * @param {string} clusterId The cluster whose logs should be downloaded.
     * @param {V2DownloadClusterLogsLogsTypeEnum} [logsType] The type of logs to be downloaded.
     * @param {string} [hostId] A specific host in the cluster whose logs should be downloaded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2DownloadClusterLogs(
      clusterId: string,
      logsType?: V2DownloadClusterLogsLogsTypeEnum,
      hostId?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2DownloadClusterLogs(
        clusterId,
        logsType,
        hostId,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Downloads the customized ignition file for this bound host, produces octet stream. For unbound host - error is returned
     * @param {string} infraEnvId The infra-env of the host whose ignition file should be downloaded.
     * @param {string} hostId The host whose ignition file should be downloaded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2DownloadHostIgnition(
      infraEnvId: string,
      hostId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2DownloadHostIgnition(
        infraEnvId,
        hostId,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Downloads the customized ignition file for this host
     * @param {string} infraEnvId The infra-env whose file should be downloaded.
     * @param {V2DownloadInfraEnvFilesFileNameEnum} fileName The file to be downloaded.
     * @param {string} [mac] Mac address of the host running ipxe script.
     * @param {V2DownloadInfraEnvFilesIpxeScriptTypeEnum} [ipxeScriptType] Specify the script type to be served for iPXE.
     * @param {V2DownloadInfraEnvFilesDiscoveryIsoTypeEnum} [discoveryIsoType] Overrides the ISO type for the disovery ignition, either \&#39;full-iso\&#39; or \&#39;minimal-iso\&#39;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2DownloadInfraEnvFiles(
      infraEnvId: string,
      fileName: V2DownloadInfraEnvFilesFileNameEnum,
      mac?: string,
      ipxeScriptType?: V2DownloadInfraEnvFilesIpxeScriptTypeEnum,
      discoveryIsoType?: V2DownloadInfraEnvFilesDiscoveryIsoTypeEnum,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2DownloadInfraEnvFiles(
        infraEnvId,
        fileName,
        mac,
        ipxeScriptType,
        discoveryIsoType,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Retrieves the details of the OpenShift cluster.
     * @param {string} clusterId The cluster to be retrieved.
     * @param {string} [discoveryAgentVersion] The software version of the discovery agent that is retrieving the cluster details.
     * @param {boolean} [getUnregisteredClusters] Whether to return clusters that have been unregistered.
     * @param {boolean} [excludeHosts] If true, do not include hosts.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2GetCluster(
      clusterId: string,
      discoveryAgentVersion?: string,
      getUnregisteredClusters?: boolean,
      excludeHosts?: boolean,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cluster>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2GetCluster(
        clusterId,
        discoveryAgentVersion,
        getUnregisteredClusters,
        excludeHosts,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get the default values for various cluster properties.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2GetClusterDefaultConfig(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterDefaultConfig>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2GetClusterDefaultConfig(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get the cluster\'s install config YAML.
     * @param {string} clusterId The cluster whose install config is being retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2GetClusterInstallConfig(
      clusterId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2GetClusterInstallConfig(
        clusterId,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Fetch cluster specific UI settings.
     * @param {string} clusterId The cluster for which UI settings should be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2GetClusterUISettings(
      clusterId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2GetClusterUISettings(
        clusterId,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get the cluster admin credentials.
     * @param {string} clusterId The cluster whose admin credentials should be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2GetCredentials(
      clusterId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Credentials>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2GetCredentials(
        clusterId,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Retrieves the details of the OpenShift host.
     * @param {string} infraEnvId The infra-env of the host that should be retrieved.
     * @param {string} hostId The host that should be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2GetHost(
      infraEnvId: string,
      hostId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Host>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2GetHost(
        infraEnvId,
        hostId,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Fetch the ignition file for this host as a string. In case of unbound host produces an error
     * @param {string} infraEnvId The infra-env of the host whose ignition file should be obtained.
     * @param {string} hostId The host whose ignition file should be obtained.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2GetHostIgnition(
      infraEnvId: string,
      hostId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HostIgnitionParams>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2GetHostIgnition(
        infraEnvId,
        hostId,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Fetch the validations which are to be ignored for this cluster.
     * @param {string} clusterId The cluster whose failing validations should be ignored according to this list.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2GetIgnoredValidations(
      clusterId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IgnoredValidations>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2GetIgnoredValidations(
        clusterId,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Retrieves the next operations that the host agent needs to perform.
     * @param {string} infraEnvId The infra-env of the host that is retrieving instructions.
     * @param {string} hostId The host that is retrieving instructions.
     * @param {number} [timestamp] The time on the host as seconds since the Unix epoch.
     * @param {string} [discoveryAgentVersion] The software version of the discovery agent that is retrieving instructions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2GetNextSteps(
      infraEnvId: string,
      hostId: string,
      timestamp?: number,
      discoveryAgentVersion?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Steps>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2GetNextSteps(
        infraEnvId,
        hostId,
        timestamp,
        discoveryAgentVersion,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get preflight requirements for a cluster.
     * @param {string} clusterId The cluster to return preflight requirements for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2GetPreflightRequirements(
      clusterId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PreflightHardwareRequirements>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2GetPreflightRequirements(
        clusterId,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get the cluster admin credentials.
     * @param {string} clusterId The cluster that owns the file that should be downloaded.
     * @param {V2GetPresignedForClusterCredentialsFileNameEnum} fileName The file to be downloaded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2GetPresignedForClusterCredentials(
      clusterId: string,
      fileName: V2GetPresignedForClusterCredentialsFileNameEnum,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PresignedUrl>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2GetPresignedForClusterCredentials(
        clusterId,
        fileName,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Retrieves a pre-signed S3 URL for downloading cluster files.
     * @param {string} clusterId The cluster that owns the file that should be downloaded.
     * @param {V2GetPresignedForClusterFilesFileNameEnum} fileName The file to be downloaded.
     * @param {V2GetPresignedForClusterFilesLogsTypeEnum} [logsType] If downloading logs, the type of logs to download.
     * @param {string} [hostId] If downloading a file related to a host, the relevant host.
     * @param {string} [additionalName] If downloading a manifest, the file name, prefaced with folder name, for example, openshift/99-openshift-xyz.yaml.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2GetPresignedForClusterFiles(
      clusterId: string,
      fileName: V2GetPresignedForClusterFilesFileNameEnum,
      logsType?: V2GetPresignedForClusterFilesLogsTypeEnum,
      hostId?: string,
      additionalName?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PresignedUrl>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2GetPresignedForClusterFiles(
        clusterId,
        fileName,
        logsType,
        hostId,
        additionalName,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Import an AI cluster using minimal data associated with existing OCP cluster, in order to allow adding day2 hosts to that cluster
     * @param {ImportClusterParams} newImportClusterParams Parameters for importing a OCP cluster for adding nodes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2ImportCluster(
      newImportClusterParams: ImportClusterParams,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cluster>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2ImportCluster(
        newImportClusterParams,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Installs the OpenShift cluster.
     * @param {string} clusterId The cluster to be installed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2InstallCluster(
      clusterId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cluster>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2InstallCluster(
        clusterId,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * install specific host for day2 cluster.
     * @param {string} infraEnvId The infra-env of the host that is being installed.
     * @param {string} hostId The host that is being installed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2InstallHost(
      infraEnvId: string,
      hostId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Host>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2InstallHost(
        infraEnvId,
        hostId,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Retrieves the list of OpenShift clusters.
     * @param {boolean} [getUnregisteredClusters] Whether to return clusters that have been unregistered.
     * @param {string} [openshiftClusterId] A specific cluster to retrieve.
     * @param {Array<string>} [amsSubscriptionIds] If non-empty, returned Clusters are filtered to those with matching subscription IDs.
     * @param {boolean} [withHosts] Include hosts in the returned list.
     * @param {string} [owner] If provided, returns only clusters that are owned by the specified user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2ListClusters(
      getUnregisteredClusters?: boolean,
      openshiftClusterId?: string,
      amsSubscriptionIds?: Array<string>,
      withHosts?: boolean,
      owner?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2ListClusters(
        getUnregisteredClusters,
        openshiftClusterId,
        amsSubscriptionIds,
        withHosts,
        owner,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * (DEPRECATED) Retrieves the support levels for features for each OpenShift version.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async v2ListFeatureSupportLevels(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureSupportLevels>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2ListFeatureSupportLevels(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Retrieves the list of OpenShift hosts that belong the infra-env.
     * @param {string} infraEnvId The infra-env that the hosts are asociated with.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2ListHosts(
      infraEnvId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HostList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2ListHosts(infraEnvId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Lists operators to be monitored for a cluster.
     * @param {string} clusterId The cluster to return operators for.
     * @param {string} [operatorName] An operator in the specified cluster to return its data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2ListOfClusterOperators(
      clusterId: string,
      operatorName?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MonitoredOperatorsList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2ListOfClusterOperators(
        clusterId,
        operatorName,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Posts the result of the operations from the host agent.
     * @param {string} infraEnvId The infra-env of the host that is posting results.
     * @param {string} hostId The host that is posting results.
     * @param {string} [discoveryAgentVersion] The software version of the discovery agent that is posting results.
     * @param {StepReply} [reply] The results to be posted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2PostStepReply(
      infraEnvId: string,
      hostId: string,
      discoveryAgentVersion?: string,
      reply?: StepReply,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2PostStepReply(
        infraEnvId,
        hostId,
        discoveryAgentVersion,
        reply,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Creates a new OpenShift cluster definition.
     * @param {ClusterCreateParams} newClusterParams The properties describing the new cluster.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2RegisterCluster(
      newClusterParams: ClusterCreateParams,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cluster>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2RegisterCluster(
        newClusterParams,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Registers a new OpenShift agent.
     * @param {string} infraEnvId The infra-env that the agent is associated with.
     * @param {HostCreateParams} newHostParams The description of the agent being registered.
     * @param {string} [discoveryAgentVersion] The software version of the discovery agent that is registering the agent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2RegisterHost(
      infraEnvId: string,
      newHostParams: HostCreateParams,
      discoveryAgentVersion?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<HostRegistrationResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2RegisterHost(
        infraEnvId,
        newHostParams,
        discoveryAgentVersion,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Controller API to report of monitored operators.
     * @param {string} clusterId The cluster whose operators are being monitored.
     * @param {OperatorMonitorReport} reportParams The operators monitor report.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2ReportMonitoredOperatorStatus(
      clusterId: string,
      reportParams: OperatorMonitorReport,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2ReportMonitoredOperatorStatus(
        clusterId,
        reportParams,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Resets a failed installation.
     * @param {string} clusterId The cluster whose installation is to be reset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2ResetCluster(
      clusterId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cluster>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2ResetCluster(clusterId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * reset a failed host for day2 cluster.
     * @param {string} infraEnvId The infra-env of the host that is being reset.
     * @param {string} hostId The host that is being reset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2ResetHost(
      infraEnvId: string,
      hostId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Host>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2ResetHost(
        infraEnvId,
        hostId,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Reset failed host validation. It may be performed on any host validation with persistent validation result.
     * @summary Reset failed host validation.
     * @param {string} infraEnvId The infra-env of the host that its validation is being reset.
     * @param {string} hostId The host that its validation is being reset.
     * @param {string} validationId The id of the validation being reset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2ResetHostValidation(
      infraEnvId: string,
      hostId: string,
      validationId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Host>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2ResetHostValidation(
        infraEnvId,
        hostId,
        validationId,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Register the validations which are to be ignored for this cluster.
     * @param {string} clusterId The cluster whose failing validations should be ignored according to this list.
     * @param {IgnoredValidations} ignoredValidations The validations to be ignored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2SetIgnoredValidations(
      clusterId: string,
      ignoredValidations: IgnoredValidations,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IgnoredValidations>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2SetIgnoredValidations(
        clusterId,
        ignoredValidations,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Updates an OpenShift cluster definition.
     * @param {string} clusterId The cluster to be updated.
     * @param {V2ClusterUpdateParams} clusterUpdateParams The properties to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2UpdateCluster(
      clusterId: string,
      clusterUpdateParams: V2ClusterUpdateParams,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cluster>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2UpdateCluster(
        clusterId,
        clusterUpdateParams,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Override values in the install config.
     * @param {string} clusterId The cluster whose install config is being updated.
     * @param {string} installConfigParams Install config overrides.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2UpdateClusterInstallConfig(
      clusterId: string,
      installConfigParams: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2UpdateClusterInstallConfig(
        clusterId,
        installConfigParams,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Update log collection state and progress.
     * @param {string} clusterId The cluster whose log progress is being updated.
     * @param {LogsProgressParams} logsProgressParams Parameters for updating log progress.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2UpdateClusterLogsProgress(
      clusterId: string,
      logsProgressParams: LogsProgressParams,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2UpdateClusterLogsProgress(
        clusterId,
        logsProgressParams,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Update cluster specific UI settings.
     * @param {string} clusterId The cluster for which UI settings should be updated.
     * @param {string} uiSettings Settings for the installer UI.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2UpdateClusterUISettings(
      clusterId: string,
      uiSettings: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2UpdateClusterUISettings(
        clusterId,
        uiSettings,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Update an Openshift host
     * @param {string} infraEnvId The infra-env ID of the host to be updated.
     * @param {string} hostId The host that should be updated.
     * @param {HostUpdateParams} hostUpdateParams The properties to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2UpdateHost(
      infraEnvId: string,
      hostId: string,
      hostUpdateParams: HostUpdateParams,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Host>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2UpdateHost(
        infraEnvId,
        hostId,
        hostUpdateParams,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Patch the ignition file for this host
     * @param {string} infraEnvId The infra-env of the host whose ignition file should be updated.
     * @param {string} hostId The host whose ignition file should be updated.
     * @param {HostIgnitionParams} hostIgnitionParams Ignition config overrides.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2UpdateHostIgnition(
      infraEnvId: string,
      hostId: string,
      hostIgnitionParams: HostIgnitionParams,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2UpdateHostIgnition(
        infraEnvId,
        hostId,
        hostIgnitionParams,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Update installation progress.
     * @param {string} infraEnvId The infra-env of the host being updated.
     * @param {string} hostId The ID of the host to update.
     * @param {HostProgress} hostProgress New progress value.
     * @param {string} [discoveryAgentVersion] The software version of the discovery agent that is updating progress.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2UpdateHostInstallProgress(
      infraEnvId: string,
      hostId: string,
      hostProgress: HostProgress,
      discoveryAgentVersion?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2UpdateHostInstallProgress(
        infraEnvId,
        hostId,
        hostProgress,
        discoveryAgentVersion,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Updates a host\'s installer arguments.
     * @param {string} infraEnvId The infra-env of the host whose installer arguments should be updated.
     * @param {string} hostId The host whose installer arguments should be updated.
     * @param {InstallerArgsParams} installerArgsParams The updated installer arguments.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2UpdateHostInstallerArgs(
      infraEnvId: string,
      hostId: string,
      installerArgsParams: InstallerArgsParams,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Host>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2UpdateHostInstallerArgs(
        infraEnvId,
        hostId,
        installerArgsParams,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Update log collection state and progress.
     * @param {string} infraEnvId The infra-env whose log progress is being updated.
     * @param {string} hostId The host whose log progress is being updated.
     * @param {LogsProgressParams} logsProgressParams Parameters for updating log progress.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2UpdateHostLogsProgress(
      infraEnvId: string,
      hostId: string,
      logsProgressParams: LogsProgressParams,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2UpdateHostLogsProgress(
        infraEnvId,
        hostId,
        logsProgressParams,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Transfer the ingress certificate for the cluster.
     * @param {string} clusterId The cluster to associate with the ingress certificate.
     * @param {string} ingressCertParams The ingress certificate.
     * @param {string} [discoveryAgentVersion] The software version of the discovery agent that is uploading the ingress certificate.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2UploadClusterIngressCert(
      clusterId: string,
      ingressCertParams: string,
      discoveryAgentVersion?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2UploadClusterIngressCert(
        clusterId,
        ingressCertParams,
        discoveryAgentVersion,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Agent API to upload logs.
     * @param {string} clusterId The cluster whose logs should be uploaded.
     * @param {V2UploadLogsLogsTypeEnum} logsType The type of log file to be uploaded.
     * @param {string} [infraEnvId] The infra-env ID of the host.
     * @param {string} [hostId] The host whose logs should be uploaded.
     * @param {File} [upfile] The log file to be uploaded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2UploadLogs(
      clusterId: string,
      logsType: V2UploadLogsLogsTypeEnum,
      infraEnvId?: string,
      hostId?: string,
      upfile?: File,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2UploadLogs(
        clusterId,
        logsType,
        infraEnvId,
        hostId,
        upfile,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * InstallerApi - factory interface
 * @export
 */
export const InstallerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = InstallerApiFp(configuration);
  return {
    /**
     * Bind host to a cluster
     * @param {InstallerApiBindHostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bindHost(
      requestParameters: InstallerApiBindHostRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<Host> {
      return localVarFp
        .bindHost(
          requestParameters.infraEnvId,
          requestParameters.hostId,
          requestParameters.bindHostParams,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Deletes an infra-env.
     * @param {InstallerApiDeregisterInfraEnvRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deregisterInfraEnv(
      requestParameters: InstallerApiDeregisterInfraEnvRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .deregisterInfraEnv(requestParameters.infraEnvId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get the initial ramdisk for minimal ISO based installations.
     * @param {InstallerApiDownloadMinimalInitrdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadMinimalInitrd(
      requestParameters: InstallerApiDownloadMinimalInitrdRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<File> {
      return localVarFp
        .downloadMinimalInitrd(requestParameters.infraEnvId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * A list of platforms that this cluster can support in its current configuration.
     * @param {InstallerApiGetClusterSupportedPlatformsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClusterSupportedPlatforms(
      requestParameters: InstallerApiGetClusterSupportedPlatformsRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<Array<PlatformType>> {
      return localVarFp
        .getClusterSupportedPlatforms(requestParameters.clusterId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves the details of the infra-env.
     * @param {InstallerApiGetInfraEnvRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInfraEnv(
      requestParameters: InstallerApiGetInfraEnvRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<InfraEnv> {
      return localVarFp
        .getInfraEnv(requestParameters.infraEnvId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Creates a new pre-signed image download URL for the infra-env.
     * @param {InstallerApiGetInfraEnvDownloadURLRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInfraEnvDownloadURL(
      requestParameters: InstallerApiGetInfraEnvDownloadURLRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<PresignedUrl> {
      return localVarFp
        .getInfraEnvDownloadURL(requestParameters.infraEnvId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Creates a new pre-signed download URL for the infra-env.
     * @param {InstallerApiGetInfraEnvPresignedFileURLRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInfraEnvPresignedFileURL(
      requestParameters: InstallerApiGetInfraEnvPresignedFileURLRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<PresignedUrl> {
      return localVarFp
        .getInfraEnvPresignedFileURL(
          requestParameters.infraEnvId,
          requestParameters.fileName,
          requestParameters.ipxeScriptType,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves the architecture support-levels for each OpenShift version.
     * @param {InstallerApiGetSupportedArchitecturesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSupportedArchitectures(
      requestParameters: InstallerApiGetSupportedArchitecturesRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<GetSupportedArchitectures200Response> {
      return localVarFp
        .getSupportedArchitectures(requestParameters.openshiftVersion, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves the features support levels for each OpenShift version.
     * @param {InstallerApiGetSupportedFeaturesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSupportedFeatures(
      requestParameters: InstallerApiGetSupportedFeaturesRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<GetSupportedFeatures200Response> {
      return localVarFp
        .getSupportedFeatures(
          requestParameters.openshiftVersion,
          requestParameters.cpuArchitecture,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a list of cluster hosts according to supplied filters.
     * @param {InstallerApiListClusterHostsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listClusterHosts(
      requestParameters: InstallerApiListClusterHostsRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<HostList> {
      return localVarFp
        .listClusterHosts(
          requestParameters.clusterId,
          requestParameters.role,
          requestParameters.status,
          requestParameters.withInventory,
          requestParameters.withConnectivity,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves the list of infra-envs.
     * @param {InstallerApiListInfraEnvsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listInfraEnvs(
      requestParameters: InstallerApiListInfraEnvsRequest = {},
      options?: AxiosRequestConfig,
    ): AxiosPromise<InfraEnvList> {
      return localVarFp
        .listInfraEnvs(requestParameters.clusterId, requestParameters.owner, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Regenerate InfraEnv token signing key.
     * @param {InstallerApiRegenerateInfraEnvSigningKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    regenerateInfraEnvSigningKey(
      requestParameters: InstallerApiRegenerateInfraEnvSigningKeyRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .regenerateInfraEnvSigningKey(requestParameters.infraEnvId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Creates a new OpenShift Discovery ISO.
     * @param {InstallerApiRegisterInfraEnvRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerInfraEnv(
      requestParameters: InstallerApiRegisterInfraEnvRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<InfraEnv> {
      return localVarFp
        .registerInfraEnv(requestParameters.infraenvCreateParams, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Transforms installed cluster to a state which allows adding hosts.
     * @param {InstallerApiTransformClusterToAddingHostsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transformClusterToAddingHosts(
      requestParameters: InstallerApiTransformClusterToAddingHostsRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<Cluster> {
      return localVarFp
        .transformClusterToAddingHosts(requestParameters.clusterId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Deprecated, maintained for legacy purposes. Does the same thing as allow-add-hosts. Use allow-add-hosts instead.
     * @param {InstallerApiTransformClusterToDay2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    transformClusterToDay2(
      requestParameters: InstallerApiTransformClusterToDay2Request,
      options?: AxiosRequestConfig,
    ): AxiosPromise<Cluster> {
      return localVarFp
        .transformClusterToDay2(requestParameters.clusterId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Unbind host to a cluster
     * @param {InstallerApiUnbindHostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unbindHost(
      requestParameters: InstallerApiUnbindHostRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<Host> {
      return localVarFp
        .unbindHost(requestParameters.infraEnvId, requestParameters.hostId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Updates an infra-env.
     * @param {InstallerApiUpdateInfraEnvRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateInfraEnv(
      requestParameters: InstallerApiUpdateInfraEnvRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<InfraEnv> {
      return localVarFp
        .updateInfraEnv(
          requestParameters.infraEnvId,
          requestParameters.infraEnvUpdateParams,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Cancels an ongoing installation.
     * @param {InstallerApiV2CancelInstallationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2CancelInstallation(
      requestParameters: InstallerApiV2CancelInstallationRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<Cluster> {
      return localVarFp
        .v2CancelInstallation(requestParameters.clusterId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Agent API to mark a finalizing installation as complete and progress to 100%.
     * @param {InstallerApiV2CompleteInstallationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2CompleteInstallation(
      requestParameters: InstallerApiV2CompleteInstallationRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<Cluster> {
      return localVarFp
        .v2CompleteInstallation(
          requestParameters.clusterId,
          requestParameters.completionParams,
          requestParameters.discoveryAgentVersion,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Deletes an OpenShift cluster definition.
     * @param {InstallerApiV2DeregisterClusterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2DeregisterCluster(
      requestParameters: InstallerApiV2DeregisterClusterRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .v2DeregisterCluster(requestParameters.clusterId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Deregisters an OpenShift host.
     * @param {InstallerApiV2DeregisterHostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2DeregisterHost(
      requestParameters: InstallerApiV2DeregisterHostRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .v2DeregisterHost(requestParameters.infraEnvId, requestParameters.hostId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Downloads credentials relating to the installed/installing cluster.
     * @param {InstallerApiV2DownloadClusterCredentialsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2DownloadClusterCredentials(
      requestParameters: InstallerApiV2DownloadClusterCredentialsRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<File> {
      return localVarFp
        .v2DownloadClusterCredentials(
          requestParameters.clusterId,
          requestParameters.fileName,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Downloads files relating to the installed/installing cluster.
     * @param {InstallerApiV2DownloadClusterFilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2DownloadClusterFiles(
      requestParameters: InstallerApiV2DownloadClusterFilesRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<File> {
      return localVarFp
        .v2DownloadClusterFiles(
          requestParameters.clusterId,
          requestParameters.fileName,
          requestParameters.discoveryAgentVersion,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Download cluster logs.
     * @param {InstallerApiV2DownloadClusterLogsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2DownloadClusterLogs(
      requestParameters: InstallerApiV2DownloadClusterLogsRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<File> {
      return localVarFp
        .v2DownloadClusterLogs(
          requestParameters.clusterId,
          requestParameters.logsType,
          requestParameters.hostId,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Downloads the customized ignition file for this bound host, produces octet stream. For unbound host - error is returned
     * @param {InstallerApiV2DownloadHostIgnitionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2DownloadHostIgnition(
      requestParameters: InstallerApiV2DownloadHostIgnitionRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<File> {
      return localVarFp
        .v2DownloadHostIgnition(requestParameters.infraEnvId, requestParameters.hostId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Downloads the customized ignition file for this host
     * @param {InstallerApiV2DownloadInfraEnvFilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2DownloadInfraEnvFiles(
      requestParameters: InstallerApiV2DownloadInfraEnvFilesRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<File> {
      return localVarFp
        .v2DownloadInfraEnvFiles(
          requestParameters.infraEnvId,
          requestParameters.fileName,
          requestParameters.mac,
          requestParameters.ipxeScriptType,
          requestParameters.discoveryIsoType,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves the details of the OpenShift cluster.
     * @param {InstallerApiV2GetClusterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2GetCluster(
      requestParameters: InstallerApiV2GetClusterRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<Cluster> {
      return localVarFp
        .v2GetCluster(
          requestParameters.clusterId,
          requestParameters.discoveryAgentVersion,
          requestParameters.getUnregisteredClusters,
          requestParameters.excludeHosts,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get the default values for various cluster properties.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2GetClusterDefaultConfig(options?: AxiosRequestConfig): AxiosPromise<ClusterDefaultConfig> {
      return localVarFp
        .v2GetClusterDefaultConfig(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get the cluster\'s install config YAML.
     * @param {InstallerApiV2GetClusterInstallConfigRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2GetClusterInstallConfig(
      requestParameters: InstallerApiV2GetClusterInstallConfigRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<string> {
      return localVarFp
        .v2GetClusterInstallConfig(requestParameters.clusterId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Fetch cluster specific UI settings.
     * @param {InstallerApiV2GetClusterUISettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2GetClusterUISettings(
      requestParameters: InstallerApiV2GetClusterUISettingsRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<string> {
      return localVarFp
        .v2GetClusterUISettings(requestParameters.clusterId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get the cluster admin credentials.
     * @param {InstallerApiV2GetCredentialsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2GetCredentials(
      requestParameters: InstallerApiV2GetCredentialsRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<Credentials> {
      return localVarFp
        .v2GetCredentials(requestParameters.clusterId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves the details of the OpenShift host.
     * @param {InstallerApiV2GetHostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2GetHost(
      requestParameters: InstallerApiV2GetHostRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<Host> {
      return localVarFp
        .v2GetHost(requestParameters.infraEnvId, requestParameters.hostId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Fetch the ignition file for this host as a string. In case of unbound host produces an error
     * @param {InstallerApiV2GetHostIgnitionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2GetHostIgnition(
      requestParameters: InstallerApiV2GetHostIgnitionRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<HostIgnitionParams> {
      return localVarFp
        .v2GetHostIgnition(requestParameters.infraEnvId, requestParameters.hostId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Fetch the validations which are to be ignored for this cluster.
     * @param {InstallerApiV2GetIgnoredValidationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2GetIgnoredValidations(
      requestParameters: InstallerApiV2GetIgnoredValidationsRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<IgnoredValidations> {
      return localVarFp
        .v2GetIgnoredValidations(requestParameters.clusterId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves the next operations that the host agent needs to perform.
     * @param {InstallerApiV2GetNextStepsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2GetNextSteps(
      requestParameters: InstallerApiV2GetNextStepsRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<Steps> {
      return localVarFp
        .v2GetNextSteps(
          requestParameters.infraEnvId,
          requestParameters.hostId,
          requestParameters.timestamp,
          requestParameters.discoveryAgentVersion,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get preflight requirements for a cluster.
     * @param {InstallerApiV2GetPreflightRequirementsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2GetPreflightRequirements(
      requestParameters: InstallerApiV2GetPreflightRequirementsRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<PreflightHardwareRequirements> {
      return localVarFp
        .v2GetPreflightRequirements(requestParameters.clusterId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get the cluster admin credentials.
     * @param {InstallerApiV2GetPresignedForClusterCredentialsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2GetPresignedForClusterCredentials(
      requestParameters: InstallerApiV2GetPresignedForClusterCredentialsRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<PresignedUrl> {
      return localVarFp
        .v2GetPresignedForClusterCredentials(
          requestParameters.clusterId,
          requestParameters.fileName,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves a pre-signed S3 URL for downloading cluster files.
     * @param {InstallerApiV2GetPresignedForClusterFilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2GetPresignedForClusterFiles(
      requestParameters: InstallerApiV2GetPresignedForClusterFilesRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<PresignedUrl> {
      return localVarFp
        .v2GetPresignedForClusterFiles(
          requestParameters.clusterId,
          requestParameters.fileName,
          requestParameters.logsType,
          requestParameters.hostId,
          requestParameters.additionalName,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Import an AI cluster using minimal data associated with existing OCP cluster, in order to allow adding day2 hosts to that cluster
     * @param {InstallerApiV2ImportClusterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2ImportCluster(
      requestParameters: InstallerApiV2ImportClusterRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<Cluster> {
      return localVarFp
        .v2ImportCluster(requestParameters.newImportClusterParams, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Installs the OpenShift cluster.
     * @param {InstallerApiV2InstallClusterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2InstallCluster(
      requestParameters: InstallerApiV2InstallClusterRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<Cluster> {
      return localVarFp
        .v2InstallCluster(requestParameters.clusterId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * install specific host for day2 cluster.
     * @param {InstallerApiV2InstallHostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2InstallHost(
      requestParameters: InstallerApiV2InstallHostRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<Host> {
      return localVarFp
        .v2InstallHost(requestParameters.infraEnvId, requestParameters.hostId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves the list of OpenShift clusters.
     * @param {InstallerApiV2ListClustersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2ListClusters(
      requestParameters: InstallerApiV2ListClustersRequest = {},
      options?: AxiosRequestConfig,
    ): AxiosPromise<ClusterList> {
      return localVarFp
        .v2ListClusters(
          requestParameters.getUnregisteredClusters,
          requestParameters.openshiftClusterId,
          requestParameters.amsSubscriptionIds,
          requestParameters.withHosts,
          requestParameters.owner,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * (DEPRECATED) Retrieves the support levels for features for each OpenShift version.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    v2ListFeatureSupportLevels(options?: AxiosRequestConfig): AxiosPromise<FeatureSupportLevels> {
      return localVarFp
        .v2ListFeatureSupportLevels(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves the list of OpenShift hosts that belong the infra-env.
     * @param {InstallerApiV2ListHostsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2ListHosts(
      requestParameters: InstallerApiV2ListHostsRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<HostList> {
      return localVarFp
        .v2ListHosts(requestParameters.infraEnvId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Lists operators to be monitored for a cluster.
     * @param {InstallerApiV2ListOfClusterOperatorsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2ListOfClusterOperators(
      requestParameters: InstallerApiV2ListOfClusterOperatorsRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<MonitoredOperatorsList> {
      return localVarFp
        .v2ListOfClusterOperators(
          requestParameters.clusterId,
          requestParameters.operatorName,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Posts the result of the operations from the host agent.
     * @param {InstallerApiV2PostStepReplyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2PostStepReply(
      requestParameters: InstallerApiV2PostStepReplyRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .v2PostStepReply(
          requestParameters.infraEnvId,
          requestParameters.hostId,
          requestParameters.discoveryAgentVersion,
          requestParameters.reply,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Creates a new OpenShift cluster definition.
     * @param {InstallerApiV2RegisterClusterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2RegisterCluster(
      requestParameters: InstallerApiV2RegisterClusterRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<Cluster> {
      return localVarFp
        .v2RegisterCluster(requestParameters.newClusterParams, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Registers a new OpenShift agent.
     * @param {InstallerApiV2RegisterHostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2RegisterHost(
      requestParameters: InstallerApiV2RegisterHostRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<HostRegistrationResponse> {
      return localVarFp
        .v2RegisterHost(
          requestParameters.infraEnvId,
          requestParameters.newHostParams,
          requestParameters.discoveryAgentVersion,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Controller API to report of monitored operators.
     * @param {InstallerApiV2ReportMonitoredOperatorStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2ReportMonitoredOperatorStatus(
      requestParameters: InstallerApiV2ReportMonitoredOperatorStatusRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .v2ReportMonitoredOperatorStatus(
          requestParameters.clusterId,
          requestParameters.reportParams,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Resets a failed installation.
     * @param {InstallerApiV2ResetClusterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2ResetCluster(
      requestParameters: InstallerApiV2ResetClusterRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<Cluster> {
      return localVarFp
        .v2ResetCluster(requestParameters.clusterId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * reset a failed host for day2 cluster.
     * @param {InstallerApiV2ResetHostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2ResetHost(
      requestParameters: InstallerApiV2ResetHostRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<Host> {
      return localVarFp
        .v2ResetHost(requestParameters.infraEnvId, requestParameters.hostId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Reset failed host validation. It may be performed on any host validation with persistent validation result.
     * @summary Reset failed host validation.
     * @param {InstallerApiV2ResetHostValidationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2ResetHostValidation(
      requestParameters: InstallerApiV2ResetHostValidationRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<Host> {
      return localVarFp
        .v2ResetHostValidation(
          requestParameters.infraEnvId,
          requestParameters.hostId,
          requestParameters.validationId,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Register the validations which are to be ignored for this cluster.
     * @param {InstallerApiV2SetIgnoredValidationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2SetIgnoredValidations(
      requestParameters: InstallerApiV2SetIgnoredValidationsRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<IgnoredValidations> {
      return localVarFp
        .v2SetIgnoredValidations(
          requestParameters.clusterId,
          requestParameters.ignoredValidations,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Updates an OpenShift cluster definition.
     * @param {InstallerApiV2UpdateClusterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2UpdateCluster(
      requestParameters: InstallerApiV2UpdateClusterRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<Cluster> {
      return localVarFp
        .v2UpdateCluster(
          requestParameters.clusterId,
          requestParameters.clusterUpdateParams,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Override values in the install config.
     * @param {InstallerApiV2UpdateClusterInstallConfigRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2UpdateClusterInstallConfig(
      requestParameters: InstallerApiV2UpdateClusterInstallConfigRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .v2UpdateClusterInstallConfig(
          requestParameters.clusterId,
          requestParameters.installConfigParams,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Update log collection state and progress.
     * @param {InstallerApiV2UpdateClusterLogsProgressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2UpdateClusterLogsProgress(
      requestParameters: InstallerApiV2UpdateClusterLogsProgressRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .v2UpdateClusterLogsProgress(
          requestParameters.clusterId,
          requestParameters.logsProgressParams,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Update cluster specific UI settings.
     * @param {InstallerApiV2UpdateClusterUISettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2UpdateClusterUISettings(
      requestParameters: InstallerApiV2UpdateClusterUISettingsRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<string> {
      return localVarFp
        .v2UpdateClusterUISettings(
          requestParameters.clusterId,
          requestParameters.uiSettings,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Update an Openshift host
     * @param {InstallerApiV2UpdateHostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2UpdateHost(
      requestParameters: InstallerApiV2UpdateHostRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<Host> {
      return localVarFp
        .v2UpdateHost(
          requestParameters.infraEnvId,
          requestParameters.hostId,
          requestParameters.hostUpdateParams,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Patch the ignition file for this host
     * @param {InstallerApiV2UpdateHostIgnitionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2UpdateHostIgnition(
      requestParameters: InstallerApiV2UpdateHostIgnitionRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .v2UpdateHostIgnition(
          requestParameters.infraEnvId,
          requestParameters.hostId,
          requestParameters.hostIgnitionParams,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Update installation progress.
     * @param {InstallerApiV2UpdateHostInstallProgressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2UpdateHostInstallProgress(
      requestParameters: InstallerApiV2UpdateHostInstallProgressRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .v2UpdateHostInstallProgress(
          requestParameters.infraEnvId,
          requestParameters.hostId,
          requestParameters.hostProgress,
          requestParameters.discoveryAgentVersion,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Updates a host\'s installer arguments.
     * @param {InstallerApiV2UpdateHostInstallerArgsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2UpdateHostInstallerArgs(
      requestParameters: InstallerApiV2UpdateHostInstallerArgsRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<Host> {
      return localVarFp
        .v2UpdateHostInstallerArgs(
          requestParameters.infraEnvId,
          requestParameters.hostId,
          requestParameters.installerArgsParams,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Update log collection state and progress.
     * @param {InstallerApiV2UpdateHostLogsProgressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2UpdateHostLogsProgress(
      requestParameters: InstallerApiV2UpdateHostLogsProgressRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .v2UpdateHostLogsProgress(
          requestParameters.infraEnvId,
          requestParameters.hostId,
          requestParameters.logsProgressParams,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Transfer the ingress certificate for the cluster.
     * @param {InstallerApiV2UploadClusterIngressCertRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2UploadClusterIngressCert(
      requestParameters: InstallerApiV2UploadClusterIngressCertRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .v2UploadClusterIngressCert(
          requestParameters.clusterId,
          requestParameters.ingressCertParams,
          requestParameters.discoveryAgentVersion,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Agent API to upload logs.
     * @param {InstallerApiV2UploadLogsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2UploadLogs(
      requestParameters: InstallerApiV2UploadLogsRequest,
      options?: AxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .v2UploadLogs(
          requestParameters.clusterId,
          requestParameters.logsType,
          requestParameters.infraEnvId,
          requestParameters.hostId,
          requestParameters.upfile,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for bindHost operation in InstallerApi.
 * @export
 * @interface InstallerApiBindHostRequest
 */
export interface InstallerApiBindHostRequest {
  /**
   * The infra-env of the host that is being bound.
   * @type {string}
   * @memberof InstallerApiBindHost
   */
  readonly infraEnvId: string;

  /**
   * The host that is being bound.
   * @type {string}
   * @memberof InstallerApiBindHost
   */
  readonly hostId: string;

  /**
   * The parameters for the host binding.
   * @type {BindHostParams}
   * @memberof InstallerApiBindHost
   */
  readonly bindHostParams: BindHostParams;
}

/**
 * Request parameters for deregisterInfraEnv operation in InstallerApi.
 * @export
 * @interface InstallerApiDeregisterInfraEnvRequest
 */
export interface InstallerApiDeregisterInfraEnvRequest {
  /**
   * The infra-env to be deleted.
   * @type {string}
   * @memberof InstallerApiDeregisterInfraEnv
   */
  readonly infraEnvId: string;
}

/**
 * Request parameters for downloadMinimalInitrd operation in InstallerApi.
 * @export
 * @interface InstallerApiDownloadMinimalInitrdRequest
 */
export interface InstallerApiDownloadMinimalInitrdRequest {
  /**
   * The infra-env of the host that should be retrieved.
   * @type {string}
   * @memberof InstallerApiDownloadMinimalInitrd
   */
  readonly infraEnvId: string;
}

/**
 * Request parameters for getClusterSupportedPlatforms operation in InstallerApi.
 * @export
 * @interface InstallerApiGetClusterSupportedPlatformsRequest
 */
export interface InstallerApiGetClusterSupportedPlatformsRequest {
  /**
   * The cluster whose platform types should be retrieved.
   * @type {string}
   * @memberof InstallerApiGetClusterSupportedPlatforms
   */
  readonly clusterId: string;
}

/**
 * Request parameters for getInfraEnv operation in InstallerApi.
 * @export
 * @interface InstallerApiGetInfraEnvRequest
 */
export interface InstallerApiGetInfraEnvRequest {
  /**
   * The infra-env to be retrieved.
   * @type {string}
   * @memberof InstallerApiGetInfraEnv
   */
  readonly infraEnvId: string;
}

/**
 * Request parameters for getInfraEnvDownloadURL operation in InstallerApi.
 * @export
 * @interface InstallerApiGetInfraEnvDownloadURLRequest
 */
export interface InstallerApiGetInfraEnvDownloadURLRequest {
  /**
   * The infra-env to be retrieved.
   * @type {string}
   * @memberof InstallerApiGetInfraEnvDownloadURL
   */
  readonly infraEnvId: string;
}

/**
 * Request parameters for getInfraEnvPresignedFileURL operation in InstallerApi.
 * @export
 * @interface InstallerApiGetInfraEnvPresignedFileURLRequest
 */
export interface InstallerApiGetInfraEnvPresignedFileURLRequest {
  /**
   * The file\&#39;s infra-env.
   * @type {string}
   * @memberof InstallerApiGetInfraEnvPresignedFileURL
   */
  readonly infraEnvId: string;

  /**
   * The file to be downloaded.
   * @type {'discovery.ign' | 'ipxe-script'}
   * @memberof InstallerApiGetInfraEnvPresignedFileURL
   */
  readonly fileName: GetInfraEnvPresignedFileURLFileNameEnum;

  /**
   * Specify the script type to be served for iPXE.
   * @type {'discovery-image-always' | 'boot-order-control'}
   * @memberof InstallerApiGetInfraEnvPresignedFileURL
   */
  readonly ipxeScriptType?: GetInfraEnvPresignedFileURLIpxeScriptTypeEnum;
}

/**
 * Request parameters for getSupportedArchitectures operation in InstallerApi.
 * @export
 * @interface InstallerApiGetSupportedArchitecturesRequest
 */
export interface InstallerApiGetSupportedArchitecturesRequest {
  /**
   * Version of the OpenShift cluster.
   * @type {string}
   * @memberof InstallerApiGetSupportedArchitectures
   */
  readonly openshiftVersion: string;
}

/**
 * Request parameters for getSupportedFeatures operation in InstallerApi.
 * @export
 * @interface InstallerApiGetSupportedFeaturesRequest
 */
export interface InstallerApiGetSupportedFeaturesRequest {
  /**
   * Version of the OpenShift cluster.
   * @type {string}
   * @memberof InstallerApiGetSupportedFeatures
   */
  readonly openshiftVersion: string;

  /**
   * The CPU architecture of the image (x86_64/arm64/etc).
   * @type {'x86_64' | 'aarch64' | 'arm64' | 'ppc64le' | 's390x' | 'multi'}
   * @memberof InstallerApiGetSupportedFeatures
   */
  readonly cpuArchitecture?: GetSupportedFeaturesCpuArchitectureEnum;
}

/**
 * Request parameters for listClusterHosts operation in InstallerApi.
 * @export
 * @interface InstallerApiListClusterHostsRequest
 */
export interface InstallerApiListClusterHostsRequest {
  /**
   * The cluster whose hosts should be retrieved.
   * @type {string}
   * @memberof InstallerApiListClusterHosts
   */
  readonly clusterId: string;

  /**
   * Role to request.
   * @type {'master' | 'worker' | 'auto-assign'}
   * @memberof InstallerApiListClusterHosts
   */
  readonly role?: ListClusterHostsRoleEnum;

  /**
   * Hosts status to request.
   * @type {string}
   * @memberof InstallerApiListClusterHosts
   */
  readonly status?: string;

  /**
   * If true return the host\&#39;s inventory.
   * @type {boolean}
   * @memberof InstallerApiListClusterHosts
   */
  readonly withInventory?: boolean;

  /**
   * If true return the host\&#39;s connectivity.
   * @type {boolean}
   * @memberof InstallerApiListClusterHosts
   */
  readonly withConnectivity?: boolean;
}

/**
 * Request parameters for listInfraEnvs operation in InstallerApi.
 * @export
 * @interface InstallerApiListInfraEnvsRequest
 */
export interface InstallerApiListInfraEnvsRequest {
  /**
   * If provided, returns only infra-envs which directly reference this cluster.
   * @type {string}
   * @memberof InstallerApiListInfraEnvs
   */
  readonly clusterId?: string;

  /**
   * If provided, returns only infra-envs that are owned by the specified user.
   * @type {string}
   * @memberof InstallerApiListInfraEnvs
   */
  readonly owner?: string;
}

/**
 * Request parameters for regenerateInfraEnvSigningKey operation in InstallerApi.
 * @export
 * @interface InstallerApiRegenerateInfraEnvSigningKeyRequest
 */
export interface InstallerApiRegenerateInfraEnvSigningKeyRequest {
  /**
   * The target InfraEnv.
   * @type {string}
   * @memberof InstallerApiRegenerateInfraEnvSigningKey
   */
  readonly infraEnvId: string;
}

/**
 * Request parameters for registerInfraEnv operation in InstallerApi.
 * @export
 * @interface InstallerApiRegisterInfraEnvRequest
 */
export interface InstallerApiRegisterInfraEnvRequest {
  /**
   * The parameters for the generated ISO.
   * @type {InfraEnvCreateParams}
   * @memberof InstallerApiRegisterInfraEnv
   */
  readonly infraenvCreateParams: InfraEnvCreateParams;
}

/**
 * Request parameters for transformClusterToAddingHosts operation in InstallerApi.
 * @export
 * @interface InstallerApiTransformClusterToAddingHostsRequest
 */
export interface InstallerApiTransformClusterToAddingHostsRequest {
  /**
   * The cluster to transform.
   * @type {string}
   * @memberof InstallerApiTransformClusterToAddingHosts
   */
  readonly clusterId: string;
}

/**
 * Request parameters for transformClusterToDay2 operation in InstallerApi.
 * @export
 * @interface InstallerApiTransformClusterToDay2Request
 */
export interface InstallerApiTransformClusterToDay2Request {
  /**
   * The cluster to transform.
   * @type {string}
   * @memberof InstallerApiTransformClusterToDay2
   */
  readonly clusterId: string;
}

/**
 * Request parameters for unbindHost operation in InstallerApi.
 * @export
 * @interface InstallerApiUnbindHostRequest
 */
export interface InstallerApiUnbindHostRequest {
  /**
   * The infra-env of the host that is being bound.
   * @type {string}
   * @memberof InstallerApiUnbindHost
   */
  readonly infraEnvId: string;

  /**
   * The host that is being bound.
   * @type {string}
   * @memberof InstallerApiUnbindHost
   */
  readonly hostId: string;
}

/**
 * Request parameters for updateInfraEnv operation in InstallerApi.
 * @export
 * @interface InstallerApiUpdateInfraEnvRequest
 */
export interface InstallerApiUpdateInfraEnvRequest {
  /**
   * The infra-env to be updated.
   * @type {string}
   * @memberof InstallerApiUpdateInfraEnv
   */
  readonly infraEnvId: string;

  /**
   * The properties to update.
   * @type {InfraEnvUpdateParams}
   * @memberof InstallerApiUpdateInfraEnv
   */
  readonly infraEnvUpdateParams: InfraEnvUpdateParams;
}

/**
 * Request parameters for v2CancelInstallation operation in InstallerApi.
 * @export
 * @interface InstallerApiV2CancelInstallationRequest
 */
export interface InstallerApiV2CancelInstallationRequest {
  /**
   * The cluster whose installation is to be canceled.
   * @type {string}
   * @memberof InstallerApiV2CancelInstallation
   */
  readonly clusterId: string;
}

/**
 * Request parameters for v2CompleteInstallation operation in InstallerApi.
 * @export
 * @interface InstallerApiV2CompleteInstallationRequest
 */
export interface InstallerApiV2CompleteInstallationRequest {
  /**
   * The cluster whose installation is being completing.
   * @type {string}
   * @memberof InstallerApiV2CompleteInstallation
   */
  readonly clusterId: string;

  /**
   * The final status of the cluster installation.
   * @type {CompletionParams}
   * @memberof InstallerApiV2CompleteInstallation
   */
  readonly completionParams: CompletionParams;

  /**
   * The software version of the discovery agent that is completing the installation.
   * @type {string}
   * @memberof InstallerApiV2CompleteInstallation
   */
  readonly discoveryAgentVersion?: string;
}

/**
 * Request parameters for v2DeregisterCluster operation in InstallerApi.
 * @export
 * @interface InstallerApiV2DeregisterClusterRequest
 */
export interface InstallerApiV2DeregisterClusterRequest {
  /**
   * The cluster to be deregistered.
   * @type {string}
   * @memberof InstallerApiV2DeregisterCluster
   */
  readonly clusterId: string;
}

/**
 * Request parameters for v2DeregisterHost operation in InstallerApi.
 * @export
 * @interface InstallerApiV2DeregisterHostRequest
 */
export interface InstallerApiV2DeregisterHostRequest {
  /**
   * The infra-env of the host that should be deregistered.
   * @type {string}
   * @memberof InstallerApiV2DeregisterHost
   */
  readonly infraEnvId: string;

  /**
   * The host that should be deregistered.
   * @type {string}
   * @memberof InstallerApiV2DeregisterHost
   */
  readonly hostId: string;
}

/**
 * Request parameters for v2DownloadClusterCredentials operation in InstallerApi.
 * @export
 * @interface InstallerApiV2DownloadClusterCredentialsRequest
 */
export interface InstallerApiV2DownloadClusterCredentialsRequest {
  /**
   * The cluster that owns the credential file that should be downloaded.
   * @type {string}
   * @memberof InstallerApiV2DownloadClusterCredentials
   */
  readonly clusterId: string;

  /**
   * The credential file to be downloaded.
   * @type {'kubeadmin-password' | 'kubeconfig' | 'kubeconfig-noingress'}
   * @memberof InstallerApiV2DownloadClusterCredentials
   */
  readonly fileName: V2DownloadClusterCredentialsFileNameEnum;
}

/**
 * Request parameters for v2DownloadClusterFiles operation in InstallerApi.
 * @export
 * @interface InstallerApiV2DownloadClusterFilesRequest
 */
export interface InstallerApiV2DownloadClusterFilesRequest {
  /**
   * The cluster that owns the file that should be downloaded.
   * @type {string}
   * @memberof InstallerApiV2DownloadClusterFiles
   */
  readonly clusterId: string;

  /**
   * The file to be downloaded.
   * @type {'bootstrap.ign' | 'master.ign' | 'metadata.json' | 'worker.ign' | 'install-config.yaml' | 'custom_manifests.json' | 'custom_manifests.yaml'}
   * @memberof InstallerApiV2DownloadClusterFiles
   */
  readonly fileName: V2DownloadClusterFilesFileNameEnum;

  /**
   * The software version of the discovery agent that is downloading the file.
   * @type {string}
   * @memberof InstallerApiV2DownloadClusterFiles
   */
  readonly discoveryAgentVersion?: string;
}

/**
 * Request parameters for v2DownloadClusterLogs operation in InstallerApi.
 * @export
 * @interface InstallerApiV2DownloadClusterLogsRequest
 */
export interface InstallerApiV2DownloadClusterLogsRequest {
  /**
   * The cluster whose logs should be downloaded.
   * @type {string}
   * @memberof InstallerApiV2DownloadClusterLogs
   */
  readonly clusterId: string;

  /**
   * The type of logs to be downloaded.
   * @type {'host' | 'controller' | 'all'}
   * @memberof InstallerApiV2DownloadClusterLogs
   */
  readonly logsType?: V2DownloadClusterLogsLogsTypeEnum;

  /**
   * A specific host in the cluster whose logs should be downloaded.
   * @type {string}
   * @memberof InstallerApiV2DownloadClusterLogs
   */
  readonly hostId?: string;
}

/**
 * Request parameters for v2DownloadHostIgnition operation in InstallerApi.
 * @export
 * @interface InstallerApiV2DownloadHostIgnitionRequest
 */
export interface InstallerApiV2DownloadHostIgnitionRequest {
  /**
   * The infra-env of the host whose ignition file should be downloaded.
   * @type {string}
   * @memberof InstallerApiV2DownloadHostIgnition
   */
  readonly infraEnvId: string;

  /**
   * The host whose ignition file should be downloaded.
   * @type {string}
   * @memberof InstallerApiV2DownloadHostIgnition
   */
  readonly hostId: string;
}

/**
 * Request parameters for v2DownloadInfraEnvFiles operation in InstallerApi.
 * @export
 * @interface InstallerApiV2DownloadInfraEnvFilesRequest
 */
export interface InstallerApiV2DownloadInfraEnvFilesRequest {
  /**
   * The infra-env whose file should be downloaded.
   * @type {string}
   * @memberof InstallerApiV2DownloadInfraEnvFiles
   */
  readonly infraEnvId: string;

  /**
   * The file to be downloaded.
   * @type {'discovery.ign' | 'ipxe-script' | 'static-network-config'}
   * @memberof InstallerApiV2DownloadInfraEnvFiles
   */
  readonly fileName: V2DownloadInfraEnvFilesFileNameEnum;

  /**
   * Mac address of the host running ipxe script.
   * @type {string}
   * @memberof InstallerApiV2DownloadInfraEnvFiles
   */
  readonly mac?: string;

  /**
   * Specify the script type to be served for iPXE.
   * @type {'discovery-image-always' | 'boot-order-control'}
   * @memberof InstallerApiV2DownloadInfraEnvFiles
   */
  readonly ipxeScriptType?: V2DownloadInfraEnvFilesIpxeScriptTypeEnum;

  /**
   * Overrides the ISO type for the disovery ignition, either \&#39;full-iso\&#39; or \&#39;minimal-iso\&#39;.
   * @type {'full-iso' | 'minimal-iso'}
   * @memberof InstallerApiV2DownloadInfraEnvFiles
   */
  readonly discoveryIsoType?: V2DownloadInfraEnvFilesDiscoveryIsoTypeEnum;
}

/**
 * Request parameters for v2GetCluster operation in InstallerApi.
 * @export
 * @interface InstallerApiV2GetClusterRequest
 */
export interface InstallerApiV2GetClusterRequest {
  /**
   * The cluster to be retrieved.
   * @type {string}
   * @memberof InstallerApiV2GetCluster
   */
  readonly clusterId: string;

  /**
   * The software version of the discovery agent that is retrieving the cluster details.
   * @type {string}
   * @memberof InstallerApiV2GetCluster
   */
  readonly discoveryAgentVersion?: string;

  /**
   * Whether to return clusters that have been unregistered.
   * @type {boolean}
   * @memberof InstallerApiV2GetCluster
   */
  readonly getUnregisteredClusters?: boolean;

  /**
   * If true, do not include hosts.
   * @type {boolean}
   * @memberof InstallerApiV2GetCluster
   */
  readonly excludeHosts?: boolean;
}

/**
 * Request parameters for v2GetClusterInstallConfig operation in InstallerApi.
 * @export
 * @interface InstallerApiV2GetClusterInstallConfigRequest
 */
export interface InstallerApiV2GetClusterInstallConfigRequest {
  /**
   * The cluster whose install config is being retrieved.
   * @type {string}
   * @memberof InstallerApiV2GetClusterInstallConfig
   */
  readonly clusterId: string;
}

/**
 * Request parameters for v2GetClusterUISettings operation in InstallerApi.
 * @export
 * @interface InstallerApiV2GetClusterUISettingsRequest
 */
export interface InstallerApiV2GetClusterUISettingsRequest {
  /**
   * The cluster for which UI settings should be retrieved.
   * @type {string}
   * @memberof InstallerApiV2GetClusterUISettings
   */
  readonly clusterId: string;
}

/**
 * Request parameters for v2GetCredentials operation in InstallerApi.
 * @export
 * @interface InstallerApiV2GetCredentialsRequest
 */
export interface InstallerApiV2GetCredentialsRequest {
  /**
   * The cluster whose admin credentials should be retrieved.
   * @type {string}
   * @memberof InstallerApiV2GetCredentials
   */
  readonly clusterId: string;
}

/**
 * Request parameters for v2GetHost operation in InstallerApi.
 * @export
 * @interface InstallerApiV2GetHostRequest
 */
export interface InstallerApiV2GetHostRequest {
  /**
   * The infra-env of the host that should be retrieved.
   * @type {string}
   * @memberof InstallerApiV2GetHost
   */
  readonly infraEnvId: string;

  /**
   * The host that should be retrieved.
   * @type {string}
   * @memberof InstallerApiV2GetHost
   */
  readonly hostId: string;
}

/**
 * Request parameters for v2GetHostIgnition operation in InstallerApi.
 * @export
 * @interface InstallerApiV2GetHostIgnitionRequest
 */
export interface InstallerApiV2GetHostIgnitionRequest {
  /**
   * The infra-env of the host whose ignition file should be obtained.
   * @type {string}
   * @memberof InstallerApiV2GetHostIgnition
   */
  readonly infraEnvId: string;

  /**
   * The host whose ignition file should be obtained.
   * @type {string}
   * @memberof InstallerApiV2GetHostIgnition
   */
  readonly hostId: string;
}

/**
 * Request parameters for v2GetIgnoredValidations operation in InstallerApi.
 * @export
 * @interface InstallerApiV2GetIgnoredValidationsRequest
 */
export interface InstallerApiV2GetIgnoredValidationsRequest {
  /**
   * The cluster whose failing validations should be ignored according to this list.
   * @type {string}
   * @memberof InstallerApiV2GetIgnoredValidations
   */
  readonly clusterId: string;
}

/**
 * Request parameters for v2GetNextSteps operation in InstallerApi.
 * @export
 * @interface InstallerApiV2GetNextStepsRequest
 */
export interface InstallerApiV2GetNextStepsRequest {
  /**
   * The infra-env of the host that is retrieving instructions.
   * @type {string}
   * @memberof InstallerApiV2GetNextSteps
   */
  readonly infraEnvId: string;

  /**
   * The host that is retrieving instructions.
   * @type {string}
   * @memberof InstallerApiV2GetNextSteps
   */
  readonly hostId: string;

  /**
   * The time on the host as seconds since the Unix epoch.
   * @type {number}
   * @memberof InstallerApiV2GetNextSteps
   */
  readonly timestamp?: number;

  /**
   * The software version of the discovery agent that is retrieving instructions.
   * @type {string}
   * @memberof InstallerApiV2GetNextSteps
   */
  readonly discoveryAgentVersion?: string;
}

/**
 * Request parameters for v2GetPreflightRequirements operation in InstallerApi.
 * @export
 * @interface InstallerApiV2GetPreflightRequirementsRequest
 */
export interface InstallerApiV2GetPreflightRequirementsRequest {
  /**
   * The cluster to return preflight requirements for.
   * @type {string}
   * @memberof InstallerApiV2GetPreflightRequirements
   */
  readonly clusterId: string;
}

/**
 * Request parameters for v2GetPresignedForClusterCredentials operation in InstallerApi.
 * @export
 * @interface InstallerApiV2GetPresignedForClusterCredentialsRequest
 */
export interface InstallerApiV2GetPresignedForClusterCredentialsRequest {
  /**
   * The cluster that owns the file that should be downloaded.
   * @type {string}
   * @memberof InstallerApiV2GetPresignedForClusterCredentials
   */
  readonly clusterId: string;

  /**
   * The file to be downloaded.
   * @type {'kubeadmin-password' | 'kubeconfig' | 'kubeconfig-noingress'}
   * @memberof InstallerApiV2GetPresignedForClusterCredentials
   */
  readonly fileName: V2GetPresignedForClusterCredentialsFileNameEnum;
}

/**
 * Request parameters for v2GetPresignedForClusterFiles operation in InstallerApi.
 * @export
 * @interface InstallerApiV2GetPresignedForClusterFilesRequest
 */
export interface InstallerApiV2GetPresignedForClusterFilesRequest {
  /**
   * The cluster that owns the file that should be downloaded.
   * @type {string}
   * @memberof InstallerApiV2GetPresignedForClusterFiles
   */
  readonly clusterId: string;

  /**
   * The file to be downloaded.
   * @type {'bootstrap.ign' | 'master.ign' | 'metadata.json' | 'worker.ign' | 'install-config.yaml' | 'logs' | 'manifests'}
   * @memberof InstallerApiV2GetPresignedForClusterFiles
   */
  readonly fileName: V2GetPresignedForClusterFilesFileNameEnum;

  /**
   * If downloading logs, the type of logs to download.
   * @type {'host' | 'controller' | 'all'}
   * @memberof InstallerApiV2GetPresignedForClusterFiles
   */
  readonly logsType?: V2GetPresignedForClusterFilesLogsTypeEnum;

  /**
   * If downloading a file related to a host, the relevant host.
   * @type {string}
   * @memberof InstallerApiV2GetPresignedForClusterFiles
   */
  readonly hostId?: string;

  /**
   * If downloading a manifest, the file name, prefaced with folder name, for example, openshift/99-openshift-xyz.yaml.
   * @type {string}
   * @memberof InstallerApiV2GetPresignedForClusterFiles
   */
  readonly additionalName?: string;
}

/**
 * Request parameters for v2ImportCluster operation in InstallerApi.
 * @export
 * @interface InstallerApiV2ImportClusterRequest
 */
export interface InstallerApiV2ImportClusterRequest {
  /**
   * Parameters for importing a OCP cluster for adding nodes.
   * @type {ImportClusterParams}
   * @memberof InstallerApiV2ImportCluster
   */
  readonly newImportClusterParams: ImportClusterParams;
}

/**
 * Request parameters for v2InstallCluster operation in InstallerApi.
 * @export
 * @interface InstallerApiV2InstallClusterRequest
 */
export interface InstallerApiV2InstallClusterRequest {
  /**
   * The cluster to be installed.
   * @type {string}
   * @memberof InstallerApiV2InstallCluster
   */
  readonly clusterId: string;
}

/**
 * Request parameters for v2InstallHost operation in InstallerApi.
 * @export
 * @interface InstallerApiV2InstallHostRequest
 */
export interface InstallerApiV2InstallHostRequest {
  /**
   * The infra-env of the host that is being installed.
   * @type {string}
   * @memberof InstallerApiV2InstallHost
   */
  readonly infraEnvId: string;

  /**
   * The host that is being installed.
   * @type {string}
   * @memberof InstallerApiV2InstallHost
   */
  readonly hostId: string;
}

/**
 * Request parameters for v2ListClusters operation in InstallerApi.
 * @export
 * @interface InstallerApiV2ListClustersRequest
 */
export interface InstallerApiV2ListClustersRequest {
  /**
   * Whether to return clusters that have been unregistered.
   * @type {boolean}
   * @memberof InstallerApiV2ListClusters
   */
  readonly getUnregisteredClusters?: boolean;

  /**
   * A specific cluster to retrieve.
   * @type {string}
   * @memberof InstallerApiV2ListClusters
   */
  readonly openshiftClusterId?: string;

  /**
   * If non-empty, returned Clusters are filtered to those with matching subscription IDs.
   * @type {Array<string>}
   * @memberof InstallerApiV2ListClusters
   */
  readonly amsSubscriptionIds?: Array<string>;

  /**
   * Include hosts in the returned list.
   * @type {boolean}
   * @memberof InstallerApiV2ListClusters
   */
  readonly withHosts?: boolean;

  /**
   * If provided, returns only clusters that are owned by the specified user.
   * @type {string}
   * @memberof InstallerApiV2ListClusters
   */
  readonly owner?: string;
}

/**
 * Request parameters for v2ListHosts operation in InstallerApi.
 * @export
 * @interface InstallerApiV2ListHostsRequest
 */
export interface InstallerApiV2ListHostsRequest {
  /**
   * The infra-env that the hosts are asociated with.
   * @type {string}
   * @memberof InstallerApiV2ListHosts
   */
  readonly infraEnvId: string;
}

/**
 * Request parameters for v2ListOfClusterOperators operation in InstallerApi.
 * @export
 * @interface InstallerApiV2ListOfClusterOperatorsRequest
 */
export interface InstallerApiV2ListOfClusterOperatorsRequest {
  /**
   * The cluster to return operators for.
   * @type {string}
   * @memberof InstallerApiV2ListOfClusterOperators
   */
  readonly clusterId: string;

  /**
   * An operator in the specified cluster to return its data.
   * @type {string}
   * @memberof InstallerApiV2ListOfClusterOperators
   */
  readonly operatorName?: string;
}

/**
 * Request parameters for v2PostStepReply operation in InstallerApi.
 * @export
 * @interface InstallerApiV2PostStepReplyRequest
 */
export interface InstallerApiV2PostStepReplyRequest {
  /**
   * The infra-env of the host that is posting results.
   * @type {string}
   * @memberof InstallerApiV2PostStepReply
   */
  readonly infraEnvId: string;

  /**
   * The host that is posting results.
   * @type {string}
   * @memberof InstallerApiV2PostStepReply
   */
  readonly hostId: string;

  /**
   * The software version of the discovery agent that is posting results.
   * @type {string}
   * @memberof InstallerApiV2PostStepReply
   */
  readonly discoveryAgentVersion?: string;

  /**
   * The results to be posted.
   * @type {StepReply}
   * @memberof InstallerApiV2PostStepReply
   */
  readonly reply?: StepReply;
}

/**
 * Request parameters for v2RegisterCluster operation in InstallerApi.
 * @export
 * @interface InstallerApiV2RegisterClusterRequest
 */
export interface InstallerApiV2RegisterClusterRequest {
  /**
   * The properties describing the new cluster.
   * @type {ClusterCreateParams}
   * @memberof InstallerApiV2RegisterCluster
   */
  readonly newClusterParams: ClusterCreateParams;
}

/**
 * Request parameters for v2RegisterHost operation in InstallerApi.
 * @export
 * @interface InstallerApiV2RegisterHostRequest
 */
export interface InstallerApiV2RegisterHostRequest {
  /**
   * The infra-env that the agent is associated with.
   * @type {string}
   * @memberof InstallerApiV2RegisterHost
   */
  readonly infraEnvId: string;

  /**
   * The description of the agent being registered.
   * @type {HostCreateParams}
   * @memberof InstallerApiV2RegisterHost
   */
  readonly newHostParams: HostCreateParams;

  /**
   * The software version of the discovery agent that is registering the agent.
   * @type {string}
   * @memberof InstallerApiV2RegisterHost
   */
  readonly discoveryAgentVersion?: string;
}

/**
 * Request parameters for v2ReportMonitoredOperatorStatus operation in InstallerApi.
 * @export
 * @interface InstallerApiV2ReportMonitoredOperatorStatusRequest
 */
export interface InstallerApiV2ReportMonitoredOperatorStatusRequest {
  /**
   * The cluster whose operators are being monitored.
   * @type {string}
   * @memberof InstallerApiV2ReportMonitoredOperatorStatus
   */
  readonly clusterId: string;

  /**
   * The operators monitor report.
   * @type {OperatorMonitorReport}
   * @memberof InstallerApiV2ReportMonitoredOperatorStatus
   */
  readonly reportParams: OperatorMonitorReport;
}

/**
 * Request parameters for v2ResetCluster operation in InstallerApi.
 * @export
 * @interface InstallerApiV2ResetClusterRequest
 */
export interface InstallerApiV2ResetClusterRequest {
  /**
   * The cluster whose installation is to be reset.
   * @type {string}
   * @memberof InstallerApiV2ResetCluster
   */
  readonly clusterId: string;
}

/**
 * Request parameters for v2ResetHost operation in InstallerApi.
 * @export
 * @interface InstallerApiV2ResetHostRequest
 */
export interface InstallerApiV2ResetHostRequest {
  /**
   * The infra-env of the host that is being reset.
   * @type {string}
   * @memberof InstallerApiV2ResetHost
   */
  readonly infraEnvId: string;

  /**
   * The host that is being reset.
   * @type {string}
   * @memberof InstallerApiV2ResetHost
   */
  readonly hostId: string;
}

/**
 * Request parameters for v2ResetHostValidation operation in InstallerApi.
 * @export
 * @interface InstallerApiV2ResetHostValidationRequest
 */
export interface InstallerApiV2ResetHostValidationRequest {
  /**
   * The infra-env of the host that its validation is being reset.
   * @type {string}
   * @memberof InstallerApiV2ResetHostValidation
   */
  readonly infraEnvId: string;

  /**
   * The host that its validation is being reset.
   * @type {string}
   * @memberof InstallerApiV2ResetHostValidation
   */
  readonly hostId: string;

  /**
   * The id of the validation being reset.
   * @type {string}
   * @memberof InstallerApiV2ResetHostValidation
   */
  readonly validationId: string;
}

/**
 * Request parameters for v2SetIgnoredValidations operation in InstallerApi.
 * @export
 * @interface InstallerApiV2SetIgnoredValidationsRequest
 */
export interface InstallerApiV2SetIgnoredValidationsRequest {
  /**
   * The cluster whose failing validations should be ignored according to this list.
   * @type {string}
   * @memberof InstallerApiV2SetIgnoredValidations
   */
  readonly clusterId: string;

  /**
   * The validations to be ignored.
   * @type {IgnoredValidations}
   * @memberof InstallerApiV2SetIgnoredValidations
   */
  readonly ignoredValidations: IgnoredValidations;
}

/**
 * Request parameters for v2UpdateCluster operation in InstallerApi.
 * @export
 * @interface InstallerApiV2UpdateClusterRequest
 */
export interface InstallerApiV2UpdateClusterRequest {
  /**
   * The cluster to be updated.
   * @type {string}
   * @memberof InstallerApiV2UpdateCluster
   */
  readonly clusterId: string;

  /**
   * The properties to update.
   * @type {V2ClusterUpdateParams}
   * @memberof InstallerApiV2UpdateCluster
   */
  readonly clusterUpdateParams: V2ClusterUpdateParams;
}

/**
 * Request parameters for v2UpdateClusterInstallConfig operation in InstallerApi.
 * @export
 * @interface InstallerApiV2UpdateClusterInstallConfigRequest
 */
export interface InstallerApiV2UpdateClusterInstallConfigRequest {
  /**
   * The cluster whose install config is being updated.
   * @type {string}
   * @memberof InstallerApiV2UpdateClusterInstallConfig
   */
  readonly clusterId: string;

  /**
   * Install config overrides.
   * @type {string}
   * @memberof InstallerApiV2UpdateClusterInstallConfig
   */
  readonly installConfigParams: string;
}

/**
 * Request parameters for v2UpdateClusterLogsProgress operation in InstallerApi.
 * @export
 * @interface InstallerApiV2UpdateClusterLogsProgressRequest
 */
export interface InstallerApiV2UpdateClusterLogsProgressRequest {
  /**
   * The cluster whose log progress is being updated.
   * @type {string}
   * @memberof InstallerApiV2UpdateClusterLogsProgress
   */
  readonly clusterId: string;

  /**
   * Parameters for updating log progress.
   * @type {LogsProgressParams}
   * @memberof InstallerApiV2UpdateClusterLogsProgress
   */
  readonly logsProgressParams: LogsProgressParams;
}

/**
 * Request parameters for v2UpdateClusterUISettings operation in InstallerApi.
 * @export
 * @interface InstallerApiV2UpdateClusterUISettingsRequest
 */
export interface InstallerApiV2UpdateClusterUISettingsRequest {
  /**
   * The cluster for which UI settings should be updated.
   * @type {string}
   * @memberof InstallerApiV2UpdateClusterUISettings
   */
  readonly clusterId: string;

  /**
   * Settings for the installer UI.
   * @type {string}
   * @memberof InstallerApiV2UpdateClusterUISettings
   */
  readonly uiSettings: string;
}

/**
 * Request parameters for v2UpdateHost operation in InstallerApi.
 * @export
 * @interface InstallerApiV2UpdateHostRequest
 */
export interface InstallerApiV2UpdateHostRequest {
  /**
   * The infra-env ID of the host to be updated.
   * @type {string}
   * @memberof InstallerApiV2UpdateHost
   */
  readonly infraEnvId: string;

  /**
   * The host that should be updated.
   * @type {string}
   * @memberof InstallerApiV2UpdateHost
   */
  readonly hostId: string;

  /**
   * The properties to update.
   * @type {HostUpdateParams}
   * @memberof InstallerApiV2UpdateHost
   */
  readonly hostUpdateParams: HostUpdateParams;
}

/**
 * Request parameters for v2UpdateHostIgnition operation in InstallerApi.
 * @export
 * @interface InstallerApiV2UpdateHostIgnitionRequest
 */
export interface InstallerApiV2UpdateHostIgnitionRequest {
  /**
   * The infra-env of the host whose ignition file should be updated.
   * @type {string}
   * @memberof InstallerApiV2UpdateHostIgnition
   */
  readonly infraEnvId: string;

  /**
   * The host whose ignition file should be updated.
   * @type {string}
   * @memberof InstallerApiV2UpdateHostIgnition
   */
  readonly hostId: string;

  /**
   * Ignition config overrides.
   * @type {HostIgnitionParams}
   * @memberof InstallerApiV2UpdateHostIgnition
   */
  readonly hostIgnitionParams: HostIgnitionParams;
}

/**
 * Request parameters for v2UpdateHostInstallProgress operation in InstallerApi.
 * @export
 * @interface InstallerApiV2UpdateHostInstallProgressRequest
 */
export interface InstallerApiV2UpdateHostInstallProgressRequest {
  /**
   * The infra-env of the host being updated.
   * @type {string}
   * @memberof InstallerApiV2UpdateHostInstallProgress
   */
  readonly infraEnvId: string;

  /**
   * The ID of the host to update.
   * @type {string}
   * @memberof InstallerApiV2UpdateHostInstallProgress
   */
  readonly hostId: string;

  /**
   * New progress value.
   * @type {HostProgress}
   * @memberof InstallerApiV2UpdateHostInstallProgress
   */
  readonly hostProgress: HostProgress;

  /**
   * The software version of the discovery agent that is updating progress.
   * @type {string}
   * @memberof InstallerApiV2UpdateHostInstallProgress
   */
  readonly discoveryAgentVersion?: string;
}

/**
 * Request parameters for v2UpdateHostInstallerArgs operation in InstallerApi.
 * @export
 * @interface InstallerApiV2UpdateHostInstallerArgsRequest
 */
export interface InstallerApiV2UpdateHostInstallerArgsRequest {
  /**
   * The infra-env of the host whose installer arguments should be updated.
   * @type {string}
   * @memberof InstallerApiV2UpdateHostInstallerArgs
   */
  readonly infraEnvId: string;

  /**
   * The host whose installer arguments should be updated.
   * @type {string}
   * @memberof InstallerApiV2UpdateHostInstallerArgs
   */
  readonly hostId: string;

  /**
   * The updated installer arguments.
   * @type {InstallerArgsParams}
   * @memberof InstallerApiV2UpdateHostInstallerArgs
   */
  readonly installerArgsParams: InstallerArgsParams;
}

/**
 * Request parameters for v2UpdateHostLogsProgress operation in InstallerApi.
 * @export
 * @interface InstallerApiV2UpdateHostLogsProgressRequest
 */
export interface InstallerApiV2UpdateHostLogsProgressRequest {
  /**
   * The infra-env whose log progress is being updated.
   * @type {string}
   * @memberof InstallerApiV2UpdateHostLogsProgress
   */
  readonly infraEnvId: string;

  /**
   * The host whose log progress is being updated.
   * @type {string}
   * @memberof InstallerApiV2UpdateHostLogsProgress
   */
  readonly hostId: string;

  /**
   * Parameters for updating log progress.
   * @type {LogsProgressParams}
   * @memberof InstallerApiV2UpdateHostLogsProgress
   */
  readonly logsProgressParams: LogsProgressParams;
}

/**
 * Request parameters for v2UploadClusterIngressCert operation in InstallerApi.
 * @export
 * @interface InstallerApiV2UploadClusterIngressCertRequest
 */
export interface InstallerApiV2UploadClusterIngressCertRequest {
  /**
   * The cluster to associate with the ingress certificate.
   * @type {string}
   * @memberof InstallerApiV2UploadClusterIngressCert
   */
  readonly clusterId: string;

  /**
   * The ingress certificate.
   * @type {string}
   * @memberof InstallerApiV2UploadClusterIngressCert
   */
  readonly ingressCertParams: string;

  /**
   * The software version of the discovery agent that is uploading the ingress certificate.
   * @type {string}
   * @memberof InstallerApiV2UploadClusterIngressCert
   */
  readonly discoveryAgentVersion?: string;
}

/**
 * Request parameters for v2UploadLogs operation in InstallerApi.
 * @export
 * @interface InstallerApiV2UploadLogsRequest
 */
export interface InstallerApiV2UploadLogsRequest {
  /**
   * The cluster whose logs should be uploaded.
   * @type {string}
   * @memberof InstallerApiV2UploadLogs
   */
  readonly clusterId: string;

  /**
   * The type of log file to be uploaded.
   * @type {'host' | 'controller'}
   * @memberof InstallerApiV2UploadLogs
   */
  readonly logsType: V2UploadLogsLogsTypeEnum;

  /**
   * The infra-env ID of the host.
   * @type {string}
   * @memberof InstallerApiV2UploadLogs
   */
  readonly infraEnvId?: string;

  /**
   * The host whose logs should be uploaded.
   * @type {string}
   * @memberof InstallerApiV2UploadLogs
   */
  readonly hostId?: string;

  /**
   * The log file to be uploaded.
   * @type {File}
   * @memberof InstallerApiV2UploadLogs
   */
  readonly upfile?: File;
}

/**
 * InstallerApi - object-oriented interface
 * @export
 * @class InstallerApi
 * @extends {BaseAPI}
 */
export class InstallerApi extends BaseAPI {
  /**
   * Bind host to a cluster
   * @param {InstallerApiBindHostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public bindHost(requestParameters: InstallerApiBindHostRequest, options?: AxiosRequestConfig) {
    return InstallerApiFp(this.configuration)
      .bindHost(
        requestParameters.infraEnvId,
        requestParameters.hostId,
        requestParameters.bindHostParams,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes an infra-env.
   * @param {InstallerApiDeregisterInfraEnvRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public deregisterInfraEnv(
    requestParameters: InstallerApiDeregisterInfraEnvRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .deregisterInfraEnv(requestParameters.infraEnvId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get the initial ramdisk for minimal ISO based installations.
   * @param {InstallerApiDownloadMinimalInitrdRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public downloadMinimalInitrd(
    requestParameters: InstallerApiDownloadMinimalInitrdRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .downloadMinimalInitrd(requestParameters.infraEnvId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * A list of platforms that this cluster can support in its current configuration.
   * @param {InstallerApiGetClusterSupportedPlatformsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public getClusterSupportedPlatforms(
    requestParameters: InstallerApiGetClusterSupportedPlatformsRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .getClusterSupportedPlatforms(requestParameters.clusterId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves the details of the infra-env.
   * @param {InstallerApiGetInfraEnvRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public getInfraEnv(
    requestParameters: InstallerApiGetInfraEnvRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .getInfraEnv(requestParameters.infraEnvId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates a new pre-signed image download URL for the infra-env.
   * @param {InstallerApiGetInfraEnvDownloadURLRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public getInfraEnvDownloadURL(
    requestParameters: InstallerApiGetInfraEnvDownloadURLRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .getInfraEnvDownloadURL(requestParameters.infraEnvId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates a new pre-signed download URL for the infra-env.
   * @param {InstallerApiGetInfraEnvPresignedFileURLRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public getInfraEnvPresignedFileURL(
    requestParameters: InstallerApiGetInfraEnvPresignedFileURLRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .getInfraEnvPresignedFileURL(
        requestParameters.infraEnvId,
        requestParameters.fileName,
        requestParameters.ipxeScriptType,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves the architecture support-levels for each OpenShift version.
   * @param {InstallerApiGetSupportedArchitecturesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public getSupportedArchitectures(
    requestParameters: InstallerApiGetSupportedArchitecturesRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .getSupportedArchitectures(requestParameters.openshiftVersion, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves the features support levels for each OpenShift version.
   * @param {InstallerApiGetSupportedFeaturesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public getSupportedFeatures(
    requestParameters: InstallerApiGetSupportedFeaturesRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .getSupportedFeatures(
        requestParameters.openshiftVersion,
        requestParameters.cpuArchitecture,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a list of cluster hosts according to supplied filters.
   * @param {InstallerApiListClusterHostsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public listClusterHosts(
    requestParameters: InstallerApiListClusterHostsRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .listClusterHosts(
        requestParameters.clusterId,
        requestParameters.role,
        requestParameters.status,
        requestParameters.withInventory,
        requestParameters.withConnectivity,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves the list of infra-envs.
   * @param {InstallerApiListInfraEnvsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public listInfraEnvs(
    requestParameters: InstallerApiListInfraEnvsRequest = {},
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .listInfraEnvs(requestParameters.clusterId, requestParameters.owner, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Regenerate InfraEnv token signing key.
   * @param {InstallerApiRegenerateInfraEnvSigningKeyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public regenerateInfraEnvSigningKey(
    requestParameters: InstallerApiRegenerateInfraEnvSigningKeyRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .regenerateInfraEnvSigningKey(requestParameters.infraEnvId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates a new OpenShift Discovery ISO.
   * @param {InstallerApiRegisterInfraEnvRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public registerInfraEnv(
    requestParameters: InstallerApiRegisterInfraEnvRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .registerInfraEnv(requestParameters.infraenvCreateParams, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Transforms installed cluster to a state which allows adding hosts.
   * @param {InstallerApiTransformClusterToAddingHostsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public transformClusterToAddingHosts(
    requestParameters: InstallerApiTransformClusterToAddingHostsRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .transformClusterToAddingHosts(requestParameters.clusterId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deprecated, maintained for legacy purposes. Does the same thing as allow-add-hosts. Use allow-add-hosts instead.
   * @param {InstallerApiTransformClusterToDay2Request} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public transformClusterToDay2(
    requestParameters: InstallerApiTransformClusterToDay2Request,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .transformClusterToDay2(requestParameters.clusterId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Unbind host to a cluster
   * @param {InstallerApiUnbindHostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public unbindHost(
    requestParameters: InstallerApiUnbindHostRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .unbindHost(requestParameters.infraEnvId, requestParameters.hostId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Updates an infra-env.
   * @param {InstallerApiUpdateInfraEnvRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public updateInfraEnv(
    requestParameters: InstallerApiUpdateInfraEnvRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .updateInfraEnv(requestParameters.infraEnvId, requestParameters.infraEnvUpdateParams, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Cancels an ongoing installation.
   * @param {InstallerApiV2CancelInstallationRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public v2CancelInstallation(
    requestParameters: InstallerApiV2CancelInstallationRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .v2CancelInstallation(requestParameters.clusterId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Agent API to mark a finalizing installation as complete and progress to 100%.
   * @param {InstallerApiV2CompleteInstallationRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public v2CompleteInstallation(
    requestParameters: InstallerApiV2CompleteInstallationRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .v2CompleteInstallation(
        requestParameters.clusterId,
        requestParameters.completionParams,
        requestParameters.discoveryAgentVersion,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes an OpenShift cluster definition.
   * @param {InstallerApiV2DeregisterClusterRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public v2DeregisterCluster(
    requestParameters: InstallerApiV2DeregisterClusterRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .v2DeregisterCluster(requestParameters.clusterId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deregisters an OpenShift host.
   * @param {InstallerApiV2DeregisterHostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public v2DeregisterHost(
    requestParameters: InstallerApiV2DeregisterHostRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .v2DeregisterHost(requestParameters.infraEnvId, requestParameters.hostId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Downloads credentials relating to the installed/installing cluster.
   * @param {InstallerApiV2DownloadClusterCredentialsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public v2DownloadClusterCredentials(
    requestParameters: InstallerApiV2DownloadClusterCredentialsRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .v2DownloadClusterCredentials(
        requestParameters.clusterId,
        requestParameters.fileName,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Downloads files relating to the installed/installing cluster.
   * @param {InstallerApiV2DownloadClusterFilesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public v2DownloadClusterFiles(
    requestParameters: InstallerApiV2DownloadClusterFilesRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .v2DownloadClusterFiles(
        requestParameters.clusterId,
        requestParameters.fileName,
        requestParameters.discoveryAgentVersion,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Download cluster logs.
   * @param {InstallerApiV2DownloadClusterLogsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public v2DownloadClusterLogs(
    requestParameters: InstallerApiV2DownloadClusterLogsRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .v2DownloadClusterLogs(
        requestParameters.clusterId,
        requestParameters.logsType,
        requestParameters.hostId,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Downloads the customized ignition file for this bound host, produces octet stream. For unbound host - error is returned
   * @param {InstallerApiV2DownloadHostIgnitionRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public v2DownloadHostIgnition(
    requestParameters: InstallerApiV2DownloadHostIgnitionRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .v2DownloadHostIgnition(requestParameters.infraEnvId, requestParameters.hostId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Downloads the customized ignition file for this host
   * @param {InstallerApiV2DownloadInfraEnvFilesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public v2DownloadInfraEnvFiles(
    requestParameters: InstallerApiV2DownloadInfraEnvFilesRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .v2DownloadInfraEnvFiles(
        requestParameters.infraEnvId,
        requestParameters.fileName,
        requestParameters.mac,
        requestParameters.ipxeScriptType,
        requestParameters.discoveryIsoType,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves the details of the OpenShift cluster.
   * @param {InstallerApiV2GetClusterRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public v2GetCluster(
    requestParameters: InstallerApiV2GetClusterRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .v2GetCluster(
        requestParameters.clusterId,
        requestParameters.discoveryAgentVersion,
        requestParameters.getUnregisteredClusters,
        requestParameters.excludeHosts,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get the default values for various cluster properties.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public v2GetClusterDefaultConfig(options?: AxiosRequestConfig) {
    return InstallerApiFp(this.configuration)
      .v2GetClusterDefaultConfig(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get the cluster\'s install config YAML.
   * @param {InstallerApiV2GetClusterInstallConfigRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public v2GetClusterInstallConfig(
    requestParameters: InstallerApiV2GetClusterInstallConfigRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .v2GetClusterInstallConfig(requestParameters.clusterId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Fetch cluster specific UI settings.
   * @param {InstallerApiV2GetClusterUISettingsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public v2GetClusterUISettings(
    requestParameters: InstallerApiV2GetClusterUISettingsRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .v2GetClusterUISettings(requestParameters.clusterId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get the cluster admin credentials.
   * @param {InstallerApiV2GetCredentialsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public v2GetCredentials(
    requestParameters: InstallerApiV2GetCredentialsRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .v2GetCredentials(requestParameters.clusterId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves the details of the OpenShift host.
   * @param {InstallerApiV2GetHostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public v2GetHost(requestParameters: InstallerApiV2GetHostRequest, options?: AxiosRequestConfig) {
    return InstallerApiFp(this.configuration)
      .v2GetHost(requestParameters.infraEnvId, requestParameters.hostId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Fetch the ignition file for this host as a string. In case of unbound host produces an error
   * @param {InstallerApiV2GetHostIgnitionRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public v2GetHostIgnition(
    requestParameters: InstallerApiV2GetHostIgnitionRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .v2GetHostIgnition(requestParameters.infraEnvId, requestParameters.hostId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Fetch the validations which are to be ignored for this cluster.
   * @param {InstallerApiV2GetIgnoredValidationsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public v2GetIgnoredValidations(
    requestParameters: InstallerApiV2GetIgnoredValidationsRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .v2GetIgnoredValidations(requestParameters.clusterId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves the next operations that the host agent needs to perform.
   * @param {InstallerApiV2GetNextStepsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public v2GetNextSteps(
    requestParameters: InstallerApiV2GetNextStepsRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .v2GetNextSteps(
        requestParameters.infraEnvId,
        requestParameters.hostId,
        requestParameters.timestamp,
        requestParameters.discoveryAgentVersion,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get preflight requirements for a cluster.
   * @param {InstallerApiV2GetPreflightRequirementsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public v2GetPreflightRequirements(
    requestParameters: InstallerApiV2GetPreflightRequirementsRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .v2GetPreflightRequirements(requestParameters.clusterId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get the cluster admin credentials.
   * @param {InstallerApiV2GetPresignedForClusterCredentialsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public v2GetPresignedForClusterCredentials(
    requestParameters: InstallerApiV2GetPresignedForClusterCredentialsRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .v2GetPresignedForClusterCredentials(
        requestParameters.clusterId,
        requestParameters.fileName,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves a pre-signed S3 URL for downloading cluster files.
   * @param {InstallerApiV2GetPresignedForClusterFilesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public v2GetPresignedForClusterFiles(
    requestParameters: InstallerApiV2GetPresignedForClusterFilesRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .v2GetPresignedForClusterFiles(
        requestParameters.clusterId,
        requestParameters.fileName,
        requestParameters.logsType,
        requestParameters.hostId,
        requestParameters.additionalName,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Import an AI cluster using minimal data associated with existing OCP cluster, in order to allow adding day2 hosts to that cluster
   * @param {InstallerApiV2ImportClusterRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public v2ImportCluster(
    requestParameters: InstallerApiV2ImportClusterRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .v2ImportCluster(requestParameters.newImportClusterParams, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Installs the OpenShift cluster.
   * @param {InstallerApiV2InstallClusterRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public v2InstallCluster(
    requestParameters: InstallerApiV2InstallClusterRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .v2InstallCluster(requestParameters.clusterId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * install specific host for day2 cluster.
   * @param {InstallerApiV2InstallHostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public v2InstallHost(
    requestParameters: InstallerApiV2InstallHostRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .v2InstallHost(requestParameters.infraEnvId, requestParameters.hostId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves the list of OpenShift clusters.
   * @param {InstallerApiV2ListClustersRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public v2ListClusters(
    requestParameters: InstallerApiV2ListClustersRequest = {},
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .v2ListClusters(
        requestParameters.getUnregisteredClusters,
        requestParameters.openshiftClusterId,
        requestParameters.amsSubscriptionIds,
        requestParameters.withHosts,
        requestParameters.owner,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * (DEPRECATED) Retrieves the support levels for features for each OpenShift version.
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public v2ListFeatureSupportLevels(options?: AxiosRequestConfig) {
    return InstallerApiFp(this.configuration)
      .v2ListFeatureSupportLevels(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves the list of OpenShift hosts that belong the infra-env.
   * @param {InstallerApiV2ListHostsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public v2ListHosts(
    requestParameters: InstallerApiV2ListHostsRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .v2ListHosts(requestParameters.infraEnvId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Lists operators to be monitored for a cluster.
   * @param {InstallerApiV2ListOfClusterOperatorsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public v2ListOfClusterOperators(
    requestParameters: InstallerApiV2ListOfClusterOperatorsRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .v2ListOfClusterOperators(
        requestParameters.clusterId,
        requestParameters.operatorName,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Posts the result of the operations from the host agent.
   * @param {InstallerApiV2PostStepReplyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public v2PostStepReply(
    requestParameters: InstallerApiV2PostStepReplyRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .v2PostStepReply(
        requestParameters.infraEnvId,
        requestParameters.hostId,
        requestParameters.discoveryAgentVersion,
        requestParameters.reply,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates a new OpenShift cluster definition.
   * @param {InstallerApiV2RegisterClusterRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public v2RegisterCluster(
    requestParameters: InstallerApiV2RegisterClusterRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .v2RegisterCluster(requestParameters.newClusterParams, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Registers a new OpenShift agent.
   * @param {InstallerApiV2RegisterHostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public v2RegisterHost(
    requestParameters: InstallerApiV2RegisterHostRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .v2RegisterHost(
        requestParameters.infraEnvId,
        requestParameters.newHostParams,
        requestParameters.discoveryAgentVersion,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Controller API to report of monitored operators.
   * @param {InstallerApiV2ReportMonitoredOperatorStatusRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public v2ReportMonitoredOperatorStatus(
    requestParameters: InstallerApiV2ReportMonitoredOperatorStatusRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .v2ReportMonitoredOperatorStatus(
        requestParameters.clusterId,
        requestParameters.reportParams,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Resets a failed installation.
   * @param {InstallerApiV2ResetClusterRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public v2ResetCluster(
    requestParameters: InstallerApiV2ResetClusterRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .v2ResetCluster(requestParameters.clusterId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * reset a failed host for day2 cluster.
   * @param {InstallerApiV2ResetHostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public v2ResetHost(
    requestParameters: InstallerApiV2ResetHostRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .v2ResetHost(requestParameters.infraEnvId, requestParameters.hostId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Reset failed host validation. It may be performed on any host validation with persistent validation result.
   * @summary Reset failed host validation.
   * @param {InstallerApiV2ResetHostValidationRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public v2ResetHostValidation(
    requestParameters: InstallerApiV2ResetHostValidationRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .v2ResetHostValidation(
        requestParameters.infraEnvId,
        requestParameters.hostId,
        requestParameters.validationId,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Register the validations which are to be ignored for this cluster.
   * @param {InstallerApiV2SetIgnoredValidationsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public v2SetIgnoredValidations(
    requestParameters: InstallerApiV2SetIgnoredValidationsRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .v2SetIgnoredValidations(
        requestParameters.clusterId,
        requestParameters.ignoredValidations,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Updates an OpenShift cluster definition.
   * @param {InstallerApiV2UpdateClusterRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public v2UpdateCluster(
    requestParameters: InstallerApiV2UpdateClusterRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .v2UpdateCluster(requestParameters.clusterId, requestParameters.clusterUpdateParams, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Override values in the install config.
   * @param {InstallerApiV2UpdateClusterInstallConfigRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public v2UpdateClusterInstallConfig(
    requestParameters: InstallerApiV2UpdateClusterInstallConfigRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .v2UpdateClusterInstallConfig(
        requestParameters.clusterId,
        requestParameters.installConfigParams,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update log collection state and progress.
   * @param {InstallerApiV2UpdateClusterLogsProgressRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public v2UpdateClusterLogsProgress(
    requestParameters: InstallerApiV2UpdateClusterLogsProgressRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .v2UpdateClusterLogsProgress(
        requestParameters.clusterId,
        requestParameters.logsProgressParams,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update cluster specific UI settings.
   * @param {InstallerApiV2UpdateClusterUISettingsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public v2UpdateClusterUISettings(
    requestParameters: InstallerApiV2UpdateClusterUISettingsRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .v2UpdateClusterUISettings(requestParameters.clusterId, requestParameters.uiSettings, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update an Openshift host
   * @param {InstallerApiV2UpdateHostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public v2UpdateHost(
    requestParameters: InstallerApiV2UpdateHostRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .v2UpdateHost(
        requestParameters.infraEnvId,
        requestParameters.hostId,
        requestParameters.hostUpdateParams,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Patch the ignition file for this host
   * @param {InstallerApiV2UpdateHostIgnitionRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public v2UpdateHostIgnition(
    requestParameters: InstallerApiV2UpdateHostIgnitionRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .v2UpdateHostIgnition(
        requestParameters.infraEnvId,
        requestParameters.hostId,
        requestParameters.hostIgnitionParams,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update installation progress.
   * @param {InstallerApiV2UpdateHostInstallProgressRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public v2UpdateHostInstallProgress(
    requestParameters: InstallerApiV2UpdateHostInstallProgressRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .v2UpdateHostInstallProgress(
        requestParameters.infraEnvId,
        requestParameters.hostId,
        requestParameters.hostProgress,
        requestParameters.discoveryAgentVersion,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Updates a host\'s installer arguments.
   * @param {InstallerApiV2UpdateHostInstallerArgsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public v2UpdateHostInstallerArgs(
    requestParameters: InstallerApiV2UpdateHostInstallerArgsRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .v2UpdateHostInstallerArgs(
        requestParameters.infraEnvId,
        requestParameters.hostId,
        requestParameters.installerArgsParams,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update log collection state and progress.
   * @param {InstallerApiV2UpdateHostLogsProgressRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public v2UpdateHostLogsProgress(
    requestParameters: InstallerApiV2UpdateHostLogsProgressRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .v2UpdateHostLogsProgress(
        requestParameters.infraEnvId,
        requestParameters.hostId,
        requestParameters.logsProgressParams,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Transfer the ingress certificate for the cluster.
   * @param {InstallerApiV2UploadClusterIngressCertRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public v2UploadClusterIngressCert(
    requestParameters: InstallerApiV2UploadClusterIngressCertRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .v2UploadClusterIngressCert(
        requestParameters.clusterId,
        requestParameters.ingressCertParams,
        requestParameters.discoveryAgentVersion,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Agent API to upload logs.
   * @param {InstallerApiV2UploadLogsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public v2UploadLogs(
    requestParameters: InstallerApiV2UploadLogsRequest,
    options?: AxiosRequestConfig,
  ) {
    return InstallerApiFp(this.configuration)
      .v2UploadLogs(
        requestParameters.clusterId,
        requestParameters.logsType,
        requestParameters.infraEnvId,
        requestParameters.hostId,
        requestParameters.upfile,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 * @enum {string}
 */
export enum GetInfraEnvPresignedFileURLFileNameEnum {
  DiscoveryIgn = 'discovery.ign',
  IpxeScript = 'ipxe-script',
}
/**
 * @export
 * @enum {string}
 */
export enum GetInfraEnvPresignedFileURLIpxeScriptTypeEnum {
  DiscoveryImageAlways = 'discovery-image-always',
  BootOrderControl = 'boot-order-control',
}
/**
 * @export
 * @enum {string}
 */
export enum GetSupportedFeaturesCpuArchitectureEnum {
  X8664 = 'x86_64',
  Aarch64 = 'aarch64',
  Arm64 = 'arm64',
  Ppc64le = 'ppc64le',
  S390x = 's390x',
  Multi = 'multi',
}
/**
 * @export
 * @enum {string}
 */
export enum ListClusterHostsRoleEnum {
  Master = 'master',
  Worker = 'worker',
  AutoAssign = 'auto-assign',
}
/**
 * @export
 * @enum {string}
 */
export enum V2DownloadClusterCredentialsFileNameEnum {
  KubeadminPassword = 'kubeadmin-password',
  Kubeconfig = 'kubeconfig',
  KubeconfigNoingress = 'kubeconfig-noingress',
}
/**
 * @export
 * @enum {string}
 */
export enum V2DownloadClusterFilesFileNameEnum {
  BootstrapIgn = 'bootstrap.ign',
  MasterIgn = 'master.ign',
  MetadataJson = 'metadata.json',
  WorkerIgn = 'worker.ign',
  InstallConfigYaml = 'install-config.yaml',
  CustomManifestsJson = 'custom_manifests.json',
  CustomManifestsYaml = 'custom_manifests.yaml',
}
/**
 * @export
 * @enum {string}
 */
export enum V2DownloadClusterLogsLogsTypeEnum {
  Host = 'host',
  Controller = 'controller',
  All = 'all',
}
/**
 * @export
 * @enum {string}
 */
export enum V2DownloadInfraEnvFilesFileNameEnum {
  DiscoveryIgn = 'discovery.ign',
  IpxeScript = 'ipxe-script',
  StaticNetworkConfig = 'static-network-config',
}
/**
 * @export
 * @enum {string}
 */
export enum V2DownloadInfraEnvFilesIpxeScriptTypeEnum {
  DiscoveryImageAlways = 'discovery-image-always',
  BootOrderControl = 'boot-order-control',
}
/**
 * @export
 * @enum {string}
 */
export enum V2DownloadInfraEnvFilesDiscoveryIsoTypeEnum {
  FullIso = 'full-iso',
  MinimalIso = 'minimal-iso',
}
/**
 * @export
 * @enum {string}
 */
export enum V2GetPresignedForClusterCredentialsFileNameEnum {
  KubeadminPassword = 'kubeadmin-password',
  Kubeconfig = 'kubeconfig',
  KubeconfigNoingress = 'kubeconfig-noingress',
}
/**
 * @export
 * @enum {string}
 */
export enum V2GetPresignedForClusterFilesFileNameEnum {
  BootstrapIgn = 'bootstrap.ign',
  MasterIgn = 'master.ign',
  MetadataJson = 'metadata.json',
  WorkerIgn = 'worker.ign',
  InstallConfigYaml = 'install-config.yaml',
  Logs = 'logs',
  Manifests = 'manifests',
}
/**
 * @export
 * @enum {string}
 */
export enum V2GetPresignedForClusterFilesLogsTypeEnum {
  Host = 'host',
  Controller = 'controller',
  All = 'all',
}
/**
 * @export
 * @enum {string}
 */
export enum V2UploadLogsLogsTypeEnum {
  Host = 'host',
  Controller = 'controller',
}

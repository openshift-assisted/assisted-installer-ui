/* tslint:disable */
/* eslint-disable */
/**
 * clusters_mgmt
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * Contact: ocm-feedback@redhat.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AWS } from '../models';
// @ts-ignore
import { AWSInfrastructureAccessRole } from '../models';
// @ts-ignore
import { AWSInfrastructureAccessRoleGrant } from '../models';
// @ts-ignore
import { AddOn } from '../models';
// @ts-ignore
import { AddOnInstallation } from '../models';
// @ts-ignore
import { AddOnVersion } from '../models';
// @ts-ignore
import { AddonUpgradePolicy } from '../models';
// @ts-ignore
import { AddonUpgradePolicyState } from '../models';
// @ts-ignore
import { AlertsInfo } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1AddonsAddonIdVersionsGet200Response } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1AddonsGet200Response } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1AwsInfrastructureAccessRolesGet200Response } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1AwsInquiriesMachineTypesPost200Response } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1AwsInquiriesRegionsPost200Response } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1AwsInquiriesStsCredentialRequestsGet200Response } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1AwsInquiriesStsPoliciesGet200Response } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1AwsInquiriesVpcsPost200Response } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1CloudProvidersCloudProviderIdAvailableRegionsPost200Response } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1CloudProvidersCloudProviderIdRegionsGet200Response } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1CloudProvidersGet200Response } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesGet200Response } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1ClustersClusterIdAddonsGet200Response } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsGet200Response } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsGet200Response } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesGet200Response } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsGet200Response } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsGet200Response } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsGet200Response } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1ClustersClusterIdGateAgreementsGet200Response } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1ClustersClusterIdGroupsGet200Response } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersGet200Response } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1ClustersClusterIdIdentityProvidersGet200Response } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersGet200Response } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersImportPost200Response } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersImportPostRequest } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1ClustersClusterIdInflightChecksGet200Response } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1ClustersClusterIdIngressesGet200Response } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsGet200Response } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1ClustersClusterIdLogsGet200Response } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1ClustersClusterIdMachinePoolsGet200Response } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1ClustersClusterIdNodePoolsGet200Response } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesGet200Response } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1ClustersClusterIdStsOperatorRolesGet200Response } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1ClustersClusterIdTuningConfigsGet200Response } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1ClustersClusterIdUpgradePoliciesGet200Response } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1ClustersGet200Response } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1DnsDomainsGet200Response } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1FlavoursGet200Response } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1GcpInquiriesEncryptionKeysPost200Response } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1GcpInquiriesKeyRingsPost200Response } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1LimitedSupportReasonTemplatesGet200Response } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1MachineTypesGet200Response } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1OidcConfigsGet200Response } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1PendingDeleteClustersGet200Response } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1ProductsGet200Response } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1ProvisionShardsGet200Response } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1TrustedIpAddressesGet200Response } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1VersionGatesGet200Response } from '../models';
// @ts-ignore
import { ApiClustersMgmtV1VersionsGet200Response } from '../models';
// @ts-ignore
import { CPUTotalsNodeRoleOSMetricNode } from '../models';
// @ts-ignore
import { CloudProvider } from '../models';
// @ts-ignore
import { CloudProviderData } from '../models';
// @ts-ignore
import { CloudRegion } from '../models';
// @ts-ignore
import { Cluster } from '../models';
// @ts-ignore
import { ClusterAutoscaler } from '../models';
// @ts-ignore
import { ClusterCredentials } from '../models';
// @ts-ignore
import { ClusterOperatorsInfo } from '../models';
// @ts-ignore
import { ClusterResources } from '../models';
// @ts-ignore
import { ClusterStatus } from '../models';
// @ts-ignore
import { ControlPlaneUpgradePolicy } from '../models';
// @ts-ignore
import { DNSDomain } from '../models';
// @ts-ignore
import { DeleteProtection } from '../models';
// @ts-ignore
import { Environment } from '../models';
// @ts-ignore
import { Event } from '../models';
// @ts-ignore
import { ExternalConfiguration } from '../models';
// @ts-ignore
import { Flavour } from '../models';
// @ts-ignore
import { Group } from '../models';
// @ts-ignore
import { HTPasswdUser } from '../models';
// @ts-ignore
import { HypershiftConfig } from '../models';
// @ts-ignore
import { IdentityProvider } from '../models';
// @ts-ignore
import { InflightCheck } from '../models';
// @ts-ignore
import { Ingress } from '../models';
// @ts-ignore
import { Label } from '../models';
// @ts-ignore
import { LimitedSupportReason } from '../models';
// @ts-ignore
import { LimitedSupportReasonTemplate } from '../models';
// @ts-ignore
import { Log } from '../models';
// @ts-ignore
import { MachinePool } from '../models';
// @ts-ignore
import { MachineType } from '../models';
// @ts-ignore
import { Manifest } from '../models';
// @ts-ignore
import { Metadata } from '../models';
// @ts-ignore
import { NetworkVerification } from '../models';
// @ts-ignore
import { NodePool } from '../models';
// @ts-ignore
import { NodePoolUpgradePolicy } from '../models';
// @ts-ignore
import { NodesInfo } from '../models';
// @ts-ignore
import { OidcConfig } from '../models';
// @ts-ignore
import { OperatorIAMRole } from '../models';
// @ts-ignore
import { PendingDeleteCluster } from '../models';
// @ts-ignore
import { PrivateLinkConfiguration } from '../models';
// @ts-ignore
import { PrivateLinkPrincipal } from '../models';
// @ts-ignore
import { Product } from '../models';
// @ts-ignore
import { ProvisionShard } from '../models';
// @ts-ignore
import { SocketTotalsNodeRoleOSMetricNode } from '../models';
// @ts-ignore
import { StsSupportJumpRole } from '../models';
// @ts-ignore
import { SubnetNetworkVerification } from '../models';
// @ts-ignore
import { Syncset } from '../models';
// @ts-ignore
import { TrustedIp } from '../models';
// @ts-ignore
import { TuningConfig } from '../models';
// @ts-ignore
import { UpgradePolicy } from '../models';
// @ts-ignore
import { UpgradePolicyState } from '../models';
// @ts-ignore
import { User } from '../models';
// @ts-ignore
import { Version } from '../models';
// @ts-ignore
import { VersionGate } from '../models';
// @ts-ignore
import { VersionGateAgreement } from '../models';
/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes the add-on.
         * @param {string} addonId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsAddonIdDelete: async (addonId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addonId' is not null or undefined
            assertParamExists('apiClustersMgmtV1AddonsAddonIdDelete', 'addonId', addonId)
            const localVarPath = `/api/clusters_mgmt/v1/addons/{addon_id}`
                .replace(`{${"addon_id"}}`, encodeURIComponent(String(addonId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the add-on.
         * @param {string} addonId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsAddonIdGet: async (addonId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addonId' is not null or undefined
            assertParamExists('apiClustersMgmtV1AddonsAddonIdGet', 'addonId', addonId)
            const localVarPath = `/api/clusters_mgmt/v1/addons/{addon_id}`
                .replace(`{${"addon_id"}}`, encodeURIComponent(String(addonId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the add-on.
         * @param {string} addonId 
         * @param {AddOn} [addOn] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsAddonIdPatch: async (addonId: string, addOn?: AddOn, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addonId' is not null or undefined
            assertParamExists('apiClustersMgmtV1AddonsAddonIdPatch', 'addonId', addonId)
            const localVarPath = `/api/clusters_mgmt/v1/addons/{addon_id}`
                .replace(`{${"addon_id"}}`, encodeURIComponent(String(addonId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addOn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of add-on versions.
         * @param {string} addonId 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to sort the add-on versions descending by id the value should be:  &#x60;&#x60;&#x60;sql id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the add-on version instead of the names of the columns of a table. For example, in order to retrieve all the add-on versions with an id starting with &#x60;0.1&#x60; the value should be:  &#x60;&#x60;&#x60;sql id like \&#39;0.1.%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the add-on versions that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsAddonIdVersionsGet: async (addonId: string, order?: string, page?: number, search?: string, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addonId' is not null or undefined
            assertParamExists('apiClustersMgmtV1AddonsAddonIdVersionsGet', 'addonId', addonId)
            const localVarPath = `/api/clusters_mgmt/v1/addons/{addon_id}/versions`
                .replace(`{${"addon_id"}}`, encodeURIComponent(String(addonId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new add-on version and add it to the collection of add-ons.
         * @param {string} addonId 
         * @param {AddOnVersion} [addOnVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsAddonIdVersionsPost: async (addonId: string, addOnVersion?: AddOnVersion, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addonId' is not null or undefined
            assertParamExists('apiClustersMgmtV1AddonsAddonIdVersionsPost', 'addonId', addonId)
            const localVarPath = `/api/clusters_mgmt/v1/addons/{addon_id}/versions`
                .replace(`{${"addon_id"}}`, encodeURIComponent(String(addonId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addOnVersion, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the add-on version.
         * @param {string} addonId 
         * @param {string} versionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsAddonIdVersionsVersionIdDelete: async (addonId: string, versionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addonId' is not null or undefined
            assertParamExists('apiClustersMgmtV1AddonsAddonIdVersionsVersionIdDelete', 'addonId', addonId)
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('apiClustersMgmtV1AddonsAddonIdVersionsVersionIdDelete', 'versionId', versionId)
            const localVarPath = `/api/clusters_mgmt/v1/addons/{addon_id}/versions/{version_id}`
                .replace(`{${"addon_id"}}`, encodeURIComponent(String(addonId)))
                .replace(`{${"version_id"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the add-on version.
         * @param {string} addonId 
         * @param {string} versionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsAddonIdVersionsVersionIdGet: async (addonId: string, versionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addonId' is not null or undefined
            assertParamExists('apiClustersMgmtV1AddonsAddonIdVersionsVersionIdGet', 'addonId', addonId)
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('apiClustersMgmtV1AddonsAddonIdVersionsVersionIdGet', 'versionId', versionId)
            const localVarPath = `/api/clusters_mgmt/v1/addons/{addon_id}/versions/{version_id}`
                .replace(`{${"addon_id"}}`, encodeURIComponent(String(addonId)))
                .replace(`{${"version_id"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the add-on version.
         * @param {string} addonId 
         * @param {string} versionId 
         * @param {AddOnVersion} [addOnVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsAddonIdVersionsVersionIdPatch: async (addonId: string, versionId: string, addOnVersion?: AddOnVersion, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addonId' is not null or undefined
            assertParamExists('apiClustersMgmtV1AddonsAddonIdVersionsVersionIdPatch', 'addonId', addonId)
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('apiClustersMgmtV1AddonsAddonIdVersionsVersionIdPatch', 'versionId', versionId)
            const localVarPath = `/api/clusters_mgmt/v1/addons/{addon_id}/versions/{version_id}`
                .replace(`{${"addon_id"}}`, encodeURIComponent(String(addonId)))
                .replace(`{${"version_id"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addOnVersion, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of add-ons.
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to sort the add-ons descending by name the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to retrieve all the add-ons with a name starting with &#x60;my&#x60; the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the add-ons that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsGet: async (order?: string, page?: number, search?: string, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/addons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new add-on and add it to the collection of add-ons.
         * @param {AddOn} [addOn] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsPost: async (addOn?: AddOn, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/addons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addOn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the aws infrastructure access role.
         * @param {string} awsInfrastructureAccessRoleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AwsInfrastructureAccessRolesAwsInfrastructureAccessRoleIdGet: async (awsInfrastructureAccessRoleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'awsInfrastructureAccessRoleId' is not null or undefined
            assertParamExists('apiClustersMgmtV1AwsInfrastructureAccessRolesAwsInfrastructureAccessRoleIdGet', 'awsInfrastructureAccessRoleId', awsInfrastructureAccessRoleId)
            const localVarPath = `/api/clusters_mgmt/v1/aws_infrastructure_access_roles/{aws_infrastructure_access_role_id}`
                .replace(`{${"aws_infrastructure_access_role_id"}}`, encodeURIComponent(String(awsInfrastructureAccessRoleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the role instead of the names of the columns of a table. For example, in order to sort the roles descending by dislay_name the value should be:  &#x60;&#x60;&#x60;sql display_name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the role instead of the names of the columns of a table. For example, in order to retrieve all the role with a name starting with &#x60;my&#x60;the value should be:  &#x60;&#x60;&#x60;sql display_name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the roles that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AwsInfrastructureAccessRolesGet: async (order?: string, page?: number, search?: string, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/aws_infrastructure_access_roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of machine types in the provided region.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {CloudProviderData} [cloudProviderData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AwsInquiriesMachineTypesPost: async (page?: number, size?: number, cloudProviderData?: CloudProviderData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/aws_inquiries/machine_types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloudProviderData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of available regions of the cloud provider. IMPORTANT: This list doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider.
         * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
         * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider.
         * @param {CloudProviderData} [cloudProviderData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AwsInquiriesRegionsPost: async (page?: number, size?: number, cloudProviderData?: CloudProviderData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/aws_inquiries/regions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloudProviderData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of policies.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AwsInquiriesStsCredentialRequestsGet: async (page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/aws_inquiries/sts_credential_requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of policies.
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the awsstspolicies instead of the names of the columns of a table. For example, in order to sort the policies descending by operator type identifier the value should be:  &#x60;&#x60;&#x60;sql orderBy id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the awsstspolicies instead of the names of the columns of a table. For example, in order to retrieve all the policies of type  &#x60;operatorrole&#x60; should be:  &#x60;&#x60;&#x60;sql policy_type like \&#39;OperatorRole%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the policies  will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AwsInquiriesStsPoliciesGet: async (order?: string, page?: number, search?: string, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/aws_inquiries/sts_policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of available vpcs of the cloud provider for specific region. IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available vpcs of the provider.
         * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
         * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of vpcs of the provider.
         * @param {CloudProviderData} [cloudProviderData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AwsInquiriesVpcsPost: async (page?: number, size?: number, cloudProviderData?: CloudProviderData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/aws_inquiries/vpcs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloudProviderData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of available regions of the cloud provider.  IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider.
         * @param {string} cloudProviderId 
         * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
         * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider.
         * @param {AWS} [aWS] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1CloudProvidersCloudProviderIdAvailableRegionsPost: async (cloudProviderId: string, page?: number, size?: number, aWS?: AWS, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cloudProviderId' is not null or undefined
            assertParamExists('apiClustersMgmtV1CloudProvidersCloudProviderIdAvailableRegionsPost', 'cloudProviderId', cloudProviderId)
            const localVarPath = `/api/clusters_mgmt/v1/cloud_providers/{cloud_provider_id}/available_regions`
                .replace(`{${"cloud_provider_id"}}`, encodeURIComponent(String(cloudProviderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aWS, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the cloud provider.
         * @param {string} cloudProviderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1CloudProvidersCloudProviderIdGet: async (cloudProviderId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cloudProviderId' is not null or undefined
            assertParamExists('apiClustersMgmtV1CloudProvidersCloudProviderIdGet', 'cloudProviderId', cloudProviderId)
            const localVarPath = `/api/clusters_mgmt/v1/cloud_providers/{cloud_provider_id}`
                .replace(`{${"cloud_provider_id"}}`, encodeURIComponent(String(cloudProviderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of regions of the cloud provider.  IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of regions of the provider.
         * @param {string} cloudProviderId 
         * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
         * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsGet: async (cloudProviderId: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cloudProviderId' is not null or undefined
            assertParamExists('apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsGet', 'cloudProviderId', cloudProviderId)
            const localVarPath = `/api/clusters_mgmt/v1/cloud_providers/{cloud_provider_id}/regions`
                .replace(`{${"cloud_provider_id"}}`, encodeURIComponent(String(cloudProviderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a cloud region to the database.
         * @param {string} cloudProviderId 
         * @param {CloudRegion} [cloudRegion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsPost: async (cloudProviderId: string, cloudRegion?: CloudRegion, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cloudProviderId' is not null or undefined
            assertParamExists('apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsPost', 'cloudProviderId', cloudProviderId)
            const localVarPath = `/api/clusters_mgmt/v1/cloud_providers/{cloud_provider_id}/regions`
                .replace(`{${"cloud_provider_id"}}`, encodeURIComponent(String(cloudProviderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloudRegion, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the region.
         * @param {string} cloudProviderId 
         * @param {string} regionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdDelete: async (cloudProviderId: string, regionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cloudProviderId' is not null or undefined
            assertParamExists('apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdDelete', 'cloudProviderId', cloudProviderId)
            // verify required parameter 'regionId' is not null or undefined
            assertParamExists('apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdDelete', 'regionId', regionId)
            const localVarPath = `/api/clusters_mgmt/v1/cloud_providers/{cloud_provider_id}/regions/{region_id}`
                .replace(`{${"cloud_provider_id"}}`, encodeURIComponent(String(cloudProviderId)))
                .replace(`{${"region_id"}}`, encodeURIComponent(String(regionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the region.
         * @param {string} cloudProviderId 
         * @param {string} regionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdGet: async (cloudProviderId: string, regionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cloudProviderId' is not null or undefined
            assertParamExists('apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdGet', 'cloudProviderId', cloudProviderId)
            // verify required parameter 'regionId' is not null or undefined
            assertParamExists('apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdGet', 'regionId', regionId)
            const localVarPath = `/api/clusters_mgmt/v1/cloud_providers/{cloud_provider_id}/regions/{region_id}`
                .replace(`{${"cloud_provider_id"}}`, encodeURIComponent(String(cloudProviderId)))
                .replace(`{${"region_id"}}`, encodeURIComponent(String(regionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the region.
         * @param {string} cloudProviderId 
         * @param {string} regionId 
         * @param {CloudRegion} [cloudRegion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdPatch: async (cloudProviderId: string, regionId: string, cloudRegion?: CloudRegion, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cloudProviderId' is not null or undefined
            assertParamExists('apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdPatch', 'cloudProviderId', cloudProviderId)
            // verify required parameter 'regionId' is not null or undefined
            assertParamExists('apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdPatch', 'regionId', regionId)
            const localVarPath = `/api/clusters_mgmt/v1/cloud_providers/{cloud_provider_id}/regions/{region_id}`
                .replace(`{${"cloud_provider_id"}}`, encodeURIComponent(String(cloudProviderId)))
                .replace(`{${"region_id"}}`, encodeURIComponent(String(regionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloudRegion, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of cloud providers.
         * @param {boolean} [fetchRegions] If true, includes the regions on each provider in the output. Could slow request response time.
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the cloud provider instead of the names of the columns of a table. For example, in order to sort the clusters descending by name identifier the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the cloud provider instead of the names of the columns of a table. For example, in order to retrieve all the cloud providers with a name starting with &#x60;A&#x60; the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;A%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the clusters that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1CloudProvidersGet: async (fetchRegions?: boolean, order?: string, page?: number, search?: string, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/cloud_providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fetchRegions !== undefined) {
                localVarQueryParameter['fetchRegions'] = fetchRegions;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {string} addonInquiryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonInquiriesAddonInquiryIdGet: async (clusterId: string, addonInquiryId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAddonInquiriesAddonInquiryIdGet', 'clusterId', clusterId)
            // verify required parameter 'addonInquiryId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAddonInquiriesAddonInquiryIdGet', 'addonInquiryId', addonInquiryId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/addon_inquiries/{addon_inquiry_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"addon_inquiry_id"}}`, encodeURIComponent(String(addonInquiryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to sort the add-ons descending by name the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to retrieve all the add-ons with a name starting with &#x60;my&#x60; the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the add-ons that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonInquiriesGet: async (clusterId: string, order?: string, page?: number, search?: string, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAddonInquiriesGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/addon_inquiries`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the addon upgrade policy.
         * @param {string} clusterId 
         * @param {string} addonUpgradePolicyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdDelete: async (clusterId: string, addonUpgradePolicyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdDelete', 'clusterId', clusterId)
            // verify required parameter 'addonUpgradePolicyId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdDelete', 'addonUpgradePolicyId', addonUpgradePolicyId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/addon_upgrade_policies/{addon_upgrade_policy_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"addon_upgrade_policy_id"}}`, encodeURIComponent(String(addonUpgradePolicyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the addon upgrade policy.
         * @param {string} clusterId 
         * @param {string} addonUpgradePolicyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdGet: async (clusterId: string, addonUpgradePolicyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdGet', 'clusterId', clusterId)
            // verify required parameter 'addonUpgradePolicyId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdGet', 'addonUpgradePolicyId', addonUpgradePolicyId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/addon_upgrade_policies/{addon_upgrade_policy_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"addon_upgrade_policy_id"}}`, encodeURIComponent(String(addonUpgradePolicyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the addon upgrade policy.
         * @param {string} clusterId 
         * @param {string} addonUpgradePolicyId 
         * @param {AddonUpgradePolicy} [addonUpgradePolicy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdPatch: async (clusterId: string, addonUpgradePolicyId: string, addonUpgradePolicy?: AddonUpgradePolicy, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdPatch', 'clusterId', clusterId)
            // verify required parameter 'addonUpgradePolicyId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdPatch', 'addonUpgradePolicyId', addonUpgradePolicyId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/addon_upgrade_policies/{addon_upgrade_policy_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"addon_upgrade_policy_id"}}`, encodeURIComponent(String(addonUpgradePolicyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addonUpgradePolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the upgrade policy state.
         * @param {string} clusterId 
         * @param {string} addonUpgradePolicyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdStateGet: async (clusterId: string, addonUpgradePolicyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdStateGet', 'clusterId', clusterId)
            // verify required parameter 'addonUpgradePolicyId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdStateGet', 'addonUpgradePolicyId', addonUpgradePolicyId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/addon_upgrade_policies/{addon_upgrade_policy_id}/state`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"addon_upgrade_policy_id"}}`, encodeURIComponent(String(addonUpgradePolicyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the upgrade policy state.
         * @param {string} clusterId 
         * @param {string} addonUpgradePolicyId 
         * @param {AddonUpgradePolicyState} [addonUpgradePolicyState] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdStatePatch: async (clusterId: string, addonUpgradePolicyId: string, addonUpgradePolicyState?: AddonUpgradePolicyState, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdStatePatch', 'clusterId', clusterId)
            // verify required parameter 'addonUpgradePolicyId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdStatePatch', 'addonUpgradePolicyId', addonUpgradePolicyId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/addon_upgrade_policies/{addon_upgrade_policy_id}/state`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"addon_upgrade_policy_id"}}`, encodeURIComponent(String(addonUpgradePolicyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addonUpgradePolicyState, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of addon upgrade policies.
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesGet: async (clusterId: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/addon_upgrade_policies`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new addon upgrade policy to the cluster.
         * @param {string} clusterId 
         * @param {AddonUpgradePolicy} [addonUpgradePolicy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesPost: async (clusterId: string, addonUpgradePolicy?: AddonUpgradePolicy, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesPost', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/addon_upgrade_policies`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addonUpgradePolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an add-on installation and remove it from the collection of add-on installations on the cluster.
         * @param {string} clusterId 
         * @param {string} addoninstallationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdDelete: async (clusterId: string, addoninstallationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdDelete', 'clusterId', clusterId)
            // verify required parameter 'addoninstallationId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdDelete', 'addoninstallationId', addoninstallationId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/addons/{addoninstallation_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"addoninstallation_id"}}`, encodeURIComponent(String(addoninstallationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the add-on installation.
         * @param {string} clusterId 
         * @param {string} addoninstallationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdGet: async (clusterId: string, addoninstallationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdGet', 'clusterId', clusterId)
            // verify required parameter 'addoninstallationId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdGet', 'addoninstallationId', addoninstallationId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/addons/{addoninstallation_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"addoninstallation_id"}}`, encodeURIComponent(String(addoninstallationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the add-on installation.
         * @param {string} clusterId 
         * @param {string} addoninstallationId 
         * @param {AddOnInstallation} [addOnInstallation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdPatch: async (clusterId: string, addoninstallationId: string, addOnInstallation?: AddOnInstallation, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdPatch', 'clusterId', clusterId)
            // verify required parameter 'addoninstallationId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdPatch', 'addoninstallationId', addoninstallationId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/addons/{addoninstallation_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"addoninstallation_id"}}`, encodeURIComponent(String(addoninstallationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addOnInstallation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of add-on installations.
         * @param {string} clusterId 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the add-on installation instead of the names of the columns of a table. For example, in order to sort the add-on installations descending by name the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the add-on installation instead of the names of the columns of a table. For example, in order to retrieve all the add-on installations with a name starting with &#x60;my&#x60; the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the add-on installations that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonsGet: async (clusterId: string, order?: string, page?: number, search?: string, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAddonsGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/addons`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new add-on installation and add it to the collection of add-on installations on the cluster.
         * @param {string} clusterId 
         * @param {AddOnInstallation} [addOnInstallation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonsPost: async (clusterId: string, addOnInstallation?: AddOnInstallation, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAddonsPost', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/addons`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addOnInstallation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the cluster autoscaler.
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAutoscalerDelete: async (clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAutoscalerDelete', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/autoscaler`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the autoscaler of a cluster.
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAutoscalerGet: async (clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAutoscalerGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/autoscaler`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the cluster autoscaler.
         * @param {string} clusterId 
         * @param {ClusterAutoscaler} [clusterAutoscaler] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAutoscalerPatch: async (clusterId: string, clusterAutoscaler?: ClusterAutoscaler, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAutoscalerPatch', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/autoscaler`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clusterAutoscaler, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new cluster autoscaler object.
         * @param {string} clusterId 
         * @param {ClusterAutoscaler} [clusterAutoscaler] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAutoscalerPost: async (clusterId: string, clusterAutoscaler?: ClusterAutoscaler, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAutoscalerPost', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/autoscaler`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clusterAutoscaler, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the AWS infrastructure access role grant.
         * @param {string} clusterId 
         * @param {string} awsInfrastructureAccessRoleGrantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdDelete: async (clusterId: string, awsInfrastructureAccessRoleGrantId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdDelete', 'clusterId', clusterId)
            // verify required parameter 'awsInfrastructureAccessRoleGrantId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdDelete', 'awsInfrastructureAccessRoleGrantId', awsInfrastructureAccessRoleGrantId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/aws_infrastructure_access_role_grants/{aws_infrastructure_access_role_grant_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"aws_infrastructure_access_role_grant_id"}}`, encodeURIComponent(String(awsInfrastructureAccessRoleGrantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the AWS infrastructure access role grant.
         * @param {string} clusterId 
         * @param {string} awsInfrastructureAccessRoleGrantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdGet: async (clusterId: string, awsInfrastructureAccessRoleGrantId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdGet', 'clusterId', clusterId)
            // verify required parameter 'awsInfrastructureAccessRoleGrantId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdGet', 'awsInfrastructureAccessRoleGrantId', awsInfrastructureAccessRoleGrantId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/aws_infrastructure_access_role_grants/{aws_infrastructure_access_role_grant_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"aws_infrastructure_access_role_grant_id"}}`, encodeURIComponent(String(awsInfrastructureAccessRoleGrantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of AWS infrastructure access role grants.
         * @param {string} clusterId 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the AWS infrastructure access role grant instead of the names of the columns of a table. For example, in order to sort the AWS infrastructure access role grants descending by user ARN the value should be:  &#x60;&#x60;&#x60;sql user_arn desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the AWS infrastructure access role grant instead of the names of the columns of a table. For example, in order to retrieve all the AWS infrastructure access role grants with a user ARN starting with &#x60;user&#x60; the value should be:  &#x60;&#x60;&#x60;sql user_arn like \&#39;%user\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the AWS infrastructure access role grants that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsGet: async (clusterId: string, order?: string, page?: number, search?: string, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/aws_infrastructure_access_role_grants`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new AWS infrastructure access role grant and add it to the collection of AWS infrastructure access role grants on the cluster.
         * @param {string} clusterId 
         * @param {AWSInfrastructureAccessRoleGrant} [aWSInfrastructureAccessRoleGrant] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsPost: async (clusterId: string, aWSInfrastructureAccessRoleGrant?: AWSInfrastructureAccessRoleGrant, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsPost', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/aws_infrastructure_access_role_grants`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aWSInfrastructureAccessRoleGrant, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the configuration for the Private Link.
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationGet: async (clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/aws/private_link_configuration`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of principals.
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the role binding instead of the names of the columns of a table. For example, in order to retrieve role bindings with role_id AuthenticatedUser:  &#x60;&#x60;&#x60;sql role_id &#x3D; \&#39;AuthenticatedUser\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the items that the user has permission to see will be returned.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsGet: async (clusterId: string, page?: number, search?: string, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/aws/private_link_configuration/principals`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new principal for the Private Link.
         * @param {string} clusterId 
         * @param {PrivateLinkPrincipal} [privateLinkPrincipal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPost: async (clusterId: string, privateLinkPrincipal?: PrivateLinkPrincipal, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPost', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/aws/private_link_configuration/principals`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(privateLinkPrincipal, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the principal.
         * @param {string} clusterId 
         * @param {string} principalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPrincipalIdDelete: async (clusterId: string, principalId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPrincipalIdDelete', 'clusterId', clusterId)
            // verify required parameter 'principalId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPrincipalIdDelete', 'principalId', principalId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/aws/private_link_configuration/principals/{principal_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"principal_id"}}`, encodeURIComponent(String(principalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the principal.
         * @param {string} clusterId 
         * @param {string} principalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPrincipalIdGet: async (clusterId: string, principalId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPrincipalIdGet', 'clusterId', clusterId)
            // verify required parameter 'principalId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPrincipalIdGet', 'principalId', principalId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/aws/private_link_configuration/principals/{principal_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"principal_id"}}`, encodeURIComponent(String(principalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the clusterdeployment.
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdClusterdeploymentDelete: async (clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdClusterdeploymentDelete', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/clusterdeployment`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the upgrade policy for the control plane.
         * @param {string} clusterId 
         * @param {string} controlPlaneUpgradePolicyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdDelete: async (clusterId: string, controlPlaneUpgradePolicyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdDelete', 'clusterId', clusterId)
            // verify required parameter 'controlPlaneUpgradePolicyId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdDelete', 'controlPlaneUpgradePolicyId', controlPlaneUpgradePolicyId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/control_plane/upgrade_policies/{control_plane_upgrade_policy_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"control_plane_upgrade_policy_id"}}`, encodeURIComponent(String(controlPlaneUpgradePolicyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the upgrade policy for the control plane.
         * @param {string} clusterId 
         * @param {string} controlPlaneUpgradePolicyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdGet: async (clusterId: string, controlPlaneUpgradePolicyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdGet', 'clusterId', clusterId)
            // verify required parameter 'controlPlaneUpgradePolicyId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdGet', 'controlPlaneUpgradePolicyId', controlPlaneUpgradePolicyId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/control_plane/upgrade_policies/{control_plane_upgrade_policy_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"control_plane_upgrade_policy_id"}}`, encodeURIComponent(String(controlPlaneUpgradePolicyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the upgrade policy for the control plane.
         * @param {string} clusterId 
         * @param {string} controlPlaneUpgradePolicyId 
         * @param {ControlPlaneUpgradePolicy} [controlPlaneUpgradePolicy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdPatch: async (clusterId: string, controlPlaneUpgradePolicyId: string, controlPlaneUpgradePolicy?: ControlPlaneUpgradePolicy, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdPatch', 'clusterId', clusterId)
            // verify required parameter 'controlPlaneUpgradePolicyId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdPatch', 'controlPlaneUpgradePolicyId', controlPlaneUpgradePolicyId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/control_plane/upgrade_policies/{control_plane_upgrade_policy_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"control_plane_upgrade_policy_id"}}`, encodeURIComponent(String(controlPlaneUpgradePolicyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(controlPlaneUpgradePolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of upgrade policies for the control plane.
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesGet: async (clusterId: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/control_plane/upgrade_policies`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new upgrade policy to the control plane of the cluster.
         * @param {string} clusterId 
         * @param {ControlPlaneUpgradePolicy} [controlPlaneUpgradePolicy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesPost: async (clusterId: string, controlPlaneUpgradePolicy?: ControlPlaneUpgradePolicy, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesPost', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/control_plane/upgrade_policies`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(controlPlaneUpgradePolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the credentials of a cluster.
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdCredentialsGet: async (clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdCredentialsGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/credentials`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the cluster.
         * @param {string} clusterId 
         * @param {boolean} [deprovision] If false it will only delete from OCM but not the actual cluster resources. false is only allowed for OCP clusters. true by default.
         * @param {boolean} [dryRun] Dry run flag is used to check if the operation can be completed, but won\&#39;t delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdDelete: async (clusterId: string, deprovision?: boolean, dryRun?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdDelete', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (deprovision !== undefined) {
                localVarQueryParameter['deprovision'] = deprovision;
            }

            if (dryRun !== undefined) {
                localVarQueryParameter['dry_run'] = dryRun;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdDeleteProtectionGet: async (clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdDeleteProtectionGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/delete_protection`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {DeleteProtection} [deleteProtection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdDeleteProtectionPatch: async (clusterId: string, deleteProtection?: DeleteProtection, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdDeleteProtectionPatch', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/delete_protection`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteProtection, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the external configuration.
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationGet: async (clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdExternalConfigurationGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/external_configuration`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of labels.
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsGet: async (clusterId: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/external_configuration/labels`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the label.
         * @param {string} clusterId 
         * @param {string} labelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdDelete: async (clusterId: string, labelId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdDelete', 'clusterId', clusterId)
            // verify required parameter 'labelId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdDelete', 'labelId', labelId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/external_configuration/labels/{label_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"label_id"}}`, encodeURIComponent(String(labelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the label.
         * @param {string} clusterId 
         * @param {string} labelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdGet: async (clusterId: string, labelId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdGet', 'clusterId', clusterId)
            // verify required parameter 'labelId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdGet', 'labelId', labelId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/external_configuration/labels/{label_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"label_id"}}`, encodeURIComponent(String(labelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the label.
         * @param {string} clusterId 
         * @param {string} labelId 
         * @param {Label} [label] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdPatch: async (clusterId: string, labelId: string, label?: Label, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdPatch', 'clusterId', clusterId)
            // verify required parameter 'labelId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdPatch', 'labelId', labelId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/external_configuration/labels/{label_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"label_id"}}`, encodeURIComponent(String(labelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(label, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new label to the cluster.
         * @param {string} clusterId 
         * @param {Label} [label] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsPost: async (clusterId: string, label?: Label, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsPost', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/external_configuration/labels`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(label, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of manifests.
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsGet: async (clusterId: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/external_configuration/manifests`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the manifest.
         * @param {string} clusterId 
         * @param {string} manifestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdDelete: async (clusterId: string, manifestId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdDelete', 'clusterId', clusterId)
            // verify required parameter 'manifestId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdDelete', 'manifestId', manifestId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/external_configuration/manifests/{manifest_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"manifest_id"}}`, encodeURIComponent(String(manifestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the manifest.
         * @param {string} clusterId 
         * @param {string} manifestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdGet: async (clusterId: string, manifestId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdGet', 'clusterId', clusterId)
            // verify required parameter 'manifestId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdGet', 'manifestId', manifestId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/external_configuration/manifests/{manifest_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"manifest_id"}}`, encodeURIComponent(String(manifestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the manifest.
         * @param {string} clusterId 
         * @param {string} manifestId 
         * @param {Manifest} [manifest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdPatch: async (clusterId: string, manifestId: string, manifest?: Manifest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdPatch', 'clusterId', clusterId)
            // verify required parameter 'manifestId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdPatch', 'manifestId', manifestId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/external_configuration/manifests/{manifest_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"manifest_id"}}`, encodeURIComponent(String(manifestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(manifest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new manifest to a cluster.
         * @param {string} clusterId 
         * @param {Manifest} [manifest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsPost: async (clusterId: string, manifest?: Manifest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsPost', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/external_configuration/manifests`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(manifest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of syncsets.
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsGet: async (clusterId: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/external_configuration/syncsets`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new syncset to the cluster.
         * @param {string} clusterId 
         * @param {Syncset} [syncset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsPost: async (clusterId: string, syncset?: Syncset, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsPost', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/external_configuration/syncsets`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(syncset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the syncset.
         * @param {string} clusterId 
         * @param {string} syncsetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdDelete: async (clusterId: string, syncsetId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdDelete', 'clusterId', clusterId)
            // verify required parameter 'syncsetId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdDelete', 'syncsetId', syncsetId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/external_configuration/syncsets/{syncset_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"syncset_id"}}`, encodeURIComponent(String(syncsetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the syncset.
         * @param {string} clusterId 
         * @param {string} syncsetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdGet: async (clusterId: string, syncsetId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdGet', 'clusterId', clusterId)
            // verify required parameter 'syncsetId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdGet', 'syncsetId', syncsetId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/external_configuration/syncsets/{syncset_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"syncset_id"}}`, encodeURIComponent(String(syncsetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the syncset.
         * @param {string} clusterId 
         * @param {string} syncsetId 
         * @param {Syncset} [syncset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdPatch: async (clusterId: string, syncsetId: string, syncset?: Syncset, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdPatch', 'clusterId', clusterId)
            // verify required parameter 'syncsetId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdPatch', 'syncsetId', syncsetId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/external_configuration/syncsets/{syncset_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"syncset_id"}}`, encodeURIComponent(String(syncsetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(syncset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of reasons.
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGateAgreementsGet: async (clusterId: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdGateAgreementsGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/gate_agreements`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new agreed version gate to the cluster.
         * @param {string} clusterId 
         * @param {VersionGateAgreement} [versionGateAgreement] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGateAgreementsPost: async (clusterId: string, versionGateAgreement?: VersionGateAgreement, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdGateAgreementsPost', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/gate_agreements`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(versionGateAgreement, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the version gate agreement.
         * @param {string} clusterId 
         * @param {string} versionGateAgreementId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdDelete: async (clusterId: string, versionGateAgreementId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdDelete', 'clusterId', clusterId)
            // verify required parameter 'versionGateAgreementId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdDelete', 'versionGateAgreementId', versionGateAgreementId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/gate_agreements/{version_gate_agreement_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"version_gate_agreement_id"}}`, encodeURIComponent(String(versionGateAgreementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the version gate agreement.
         * @param {string} clusterId 
         * @param {string} versionGateAgreementId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdGet: async (clusterId: string, versionGateAgreementId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdGet', 'clusterId', clusterId)
            // verify required parameter 'versionGateAgreementId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdGet', 'versionGateAgreementId', versionGateAgreementId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/gate_agreements/{version_gate_agreement_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"version_gate_agreement_id"}}`, encodeURIComponent(String(versionGateAgreementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the cluster.
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGet: async (clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of groups.
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGroupsGet: async (clusterId: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdGroupsGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/groups`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the group.
         * @param {string} clusterId 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGroupsGroupIdGet: async (clusterId: string, groupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdGroupsGroupIdGet', 'clusterId', clusterId)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdGroupsGroupIdGet', 'groupId', groupId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/groups/{group_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of users.
         * @param {string} clusterId 
         * @param {string} groupId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersGet: async (clusterId: string, groupId: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersGet', 'clusterId', clusterId)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersGet', 'groupId', groupId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/groups/{group_id}/users`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new user to the group.
         * @param {string} clusterId 
         * @param {string} groupId 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersPost: async (clusterId: string, groupId: string, user?: User, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersPost', 'clusterId', clusterId)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersPost', 'groupId', groupId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/groups/{group_id}/users`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the user.
         * @param {string} clusterId 
         * @param {string} groupId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdDelete: async (clusterId: string, groupId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdDelete', 'clusterId', clusterId)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdDelete', 'groupId', groupId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdDelete', 'userId', userId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/groups/{group_id}/users/{user_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the user.
         * @param {string} clusterId 
         * @param {string} groupId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdGet: async (clusterId: string, groupId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdGet', 'clusterId', clusterId)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdGet', 'groupId', groupId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdGet', 'userId', userId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/groups/{group_id}/users/{user_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Initiates cluster hibernation. While hibernating a cluster will not consume any cloud provider infrastructure but will be counted for quota.
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdHibernatePost: async (clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdHibernatePost', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/hibernate`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the Hypershift details for a single cluster.
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdHypershiftGet: async (clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdHypershiftGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/hypershift`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of identity providers.
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersGet: async (clusterId: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIdentityProvidersGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/identity_providers`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the identity provider.
         * @param {string} clusterId 
         * @param {string} identityProviderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdDelete: async (clusterId: string, identityProviderId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdDelete', 'clusterId', clusterId)
            // verify required parameter 'identityProviderId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdDelete', 'identityProviderId', identityProviderId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/identity_providers/{identity_provider_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"identity_provider_id"}}`, encodeURIComponent(String(identityProviderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the identity provider.
         * @param {string} clusterId 
         * @param {string} identityProviderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdGet: async (clusterId: string, identityProviderId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdGet', 'clusterId', clusterId)
            // verify required parameter 'identityProviderId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdGet', 'identityProviderId', identityProviderId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/identity_providers/{identity_provider_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"identity_provider_id"}}`, encodeURIComponent(String(identityProviderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of _HTPasswd_ IDP users.
         * @param {string} clusterId 
         * @param {string} identityProviderId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersGet: async (clusterId: string, identityProviderId: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersGet', 'clusterId', clusterId)
            // verify required parameter 'identityProviderId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersGet', 'identityProviderId', identityProviderId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/identity_providers/{identity_provider_id}/htpasswd_users`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"identity_provider_id"}}`, encodeURIComponent(String(identityProviderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the user.
         * @param {string} clusterId 
         * @param {string} identityProviderId 
         * @param {string} htpasswdUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdDelete: async (clusterId: string, identityProviderId: string, htpasswdUserId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdDelete', 'clusterId', clusterId)
            // verify required parameter 'identityProviderId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdDelete', 'identityProviderId', identityProviderId)
            // verify required parameter 'htpasswdUserId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdDelete', 'htpasswdUserId', htpasswdUserId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/identity_providers/{identity_provider_id}/htpasswd_users/{htpasswd_user_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"identity_provider_id"}}`, encodeURIComponent(String(identityProviderId)))
                .replace(`{${"htpasswd_user_id"}}`, encodeURIComponent(String(htpasswdUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the user.
         * @param {string} clusterId 
         * @param {string} identityProviderId 
         * @param {string} htpasswdUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdGet: async (clusterId: string, identityProviderId: string, htpasswdUserId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdGet', 'clusterId', clusterId)
            // verify required parameter 'identityProviderId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdGet', 'identityProviderId', identityProviderId)
            // verify required parameter 'htpasswdUserId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdGet', 'htpasswdUserId', htpasswdUserId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/identity_providers/{identity_provider_id}/htpasswd_users/{htpasswd_user_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"identity_provider_id"}}`, encodeURIComponent(String(identityProviderId)))
                .replace(`{${"htpasswd_user_id"}}`, encodeURIComponent(String(htpasswdUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the user\'s password. The username is not editable
         * @param {string} clusterId 
         * @param {string} identityProviderId 
         * @param {string} htpasswdUserId 
         * @param {HTPasswdUser} [hTPasswdUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdPatch: async (clusterId: string, identityProviderId: string, htpasswdUserId: string, hTPasswdUser?: HTPasswdUser, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdPatch', 'clusterId', clusterId)
            // verify required parameter 'identityProviderId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdPatch', 'identityProviderId', identityProviderId)
            // verify required parameter 'htpasswdUserId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdPatch', 'htpasswdUserId', htpasswdUserId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/identity_providers/{identity_provider_id}/htpasswd_users/{htpasswd_user_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"identity_provider_id"}}`, encodeURIComponent(String(identityProviderId)))
                .replace(`{${"htpasswd_user_id"}}`, encodeURIComponent(String(htpasswdUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(hTPasswdUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds multiple new users to the _HTPasswd_ file.
         * @param {string} clusterId 
         * @param {string} identityProviderId 
         * @param {ApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersImportPostRequest} [apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersImportPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersImportPost: async (clusterId: string, identityProviderId: string, apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersImportPostRequest?: ApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersImportPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersImportPost', 'clusterId', clusterId)
            // verify required parameter 'identityProviderId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersImportPost', 'identityProviderId', identityProviderId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/identity_providers/{identity_provider_id}/htpasswd_users/import`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"identity_provider_id"}}`, encodeURIComponent(String(identityProviderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersImportPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new user to the _HTPasswd_ file.
         * @param {string} clusterId 
         * @param {string} identityProviderId 
         * @param {HTPasswdUser} [hTPasswdUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersPost: async (clusterId: string, identityProviderId: string, hTPasswdUser?: HTPasswdUser, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersPost', 'clusterId', clusterId)
            // verify required parameter 'identityProviderId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersPost', 'identityProviderId', identityProviderId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/identity_providers/{identity_provider_id}/htpasswd_users`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"identity_provider_id"}}`, encodeURIComponent(String(identityProviderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(hTPasswdUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update identity provider in the cluster.
         * @param {string} clusterId 
         * @param {string} identityProviderId 
         * @param {IdentityProvider} [identityProvider] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdPatch: async (clusterId: string, identityProviderId: string, identityProvider?: IdentityProvider, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdPatch', 'clusterId', clusterId)
            // verify required parameter 'identityProviderId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdPatch', 'identityProviderId', identityProviderId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/identity_providers/{identity_provider_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"identity_provider_id"}}`, encodeURIComponent(String(identityProviderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(identityProvider, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new identity provider to the cluster.
         * @param {string} clusterId 
         * @param {IdentityProvider} [identityProvider] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersPost: async (clusterId: string, identityProvider?: IdentityProvider, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIdentityProvidersPost', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/identity_providers`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(identityProvider, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of inflight checks.
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdInflightChecksGet: async (clusterId: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdInflightChecksGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/inflight_checks`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the inflight check.
         * @param {string} clusterId 
         * @param {string} inflightCheckId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdInflightChecksInflightCheckIdGet: async (clusterId: string, inflightCheckId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdInflightChecksInflightCheckIdGet', 'clusterId', clusterId)
            // verify required parameter 'inflightCheckId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdInflightChecksInflightCheckIdGet', 'inflightCheckId', inflightCheckId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/inflight_checks/{inflight_check_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"inflight_check_id"}}`, encodeURIComponent(String(inflightCheckId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of ingresses.
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIngressesGet: async (clusterId: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIngressesGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/ingresses`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the ingress.
         * @param {string} clusterId 
         * @param {string} ingressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIngressesIngressIdDelete: async (clusterId: string, ingressId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIngressesIngressIdDelete', 'clusterId', clusterId)
            // verify required parameter 'ingressId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIngressesIngressIdDelete', 'ingressId', ingressId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/ingresses/{ingress_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"ingress_id"}}`, encodeURIComponent(String(ingressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the ingress.
         * @param {string} clusterId 
         * @param {string} ingressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIngressesIngressIdGet: async (clusterId: string, ingressId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIngressesIngressIdGet', 'clusterId', clusterId)
            // verify required parameter 'ingressId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIngressesIngressIdGet', 'ingressId', ingressId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/ingresses/{ingress_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"ingress_id"}}`, encodeURIComponent(String(ingressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the ingress.
         * @param {string} clusterId 
         * @param {string} ingressId 
         * @param {Ingress} [ingress] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIngressesIngressIdPatch: async (clusterId: string, ingressId: string, ingress?: Ingress, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIngressesIngressIdPatch', 'clusterId', clusterId)
            // verify required parameter 'ingressId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIngressesIngressIdPatch', 'ingressId', ingressId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/ingresses/{ingress_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"ingress_id"}}`, encodeURIComponent(String(ingressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ingress, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates all ingresses
         * @param {string} clusterId 
         * @param {Array<Ingress>} [ingress] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIngressesPatch: async (clusterId: string, ingress?: Array<Ingress>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIngressesPatch', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/ingresses`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ingress, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new ingress to the cluster.
         * @param {string} clusterId 
         * @param {Ingress} [ingress] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIngressesPost: async (clusterId: string, ingress?: Ingress, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdIngressesPost', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/ingresses`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ingress, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of reasons.
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsGet: async (clusterId: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/limited_support_reasons`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the reason.
         * @param {string} clusterId 
         * @param {string} limitedSupportReasonId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdDelete: async (clusterId: string, limitedSupportReasonId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdDelete', 'clusterId', clusterId)
            // verify required parameter 'limitedSupportReasonId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdDelete', 'limitedSupportReasonId', limitedSupportReasonId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/limited_support_reasons/{limited_support_reason_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"limited_support_reason_id"}}`, encodeURIComponent(String(limitedSupportReasonId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the reason.
         * @param {string} clusterId 
         * @param {string} limitedSupportReasonId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdGet: async (clusterId: string, limitedSupportReasonId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdGet', 'clusterId', clusterId)
            // verify required parameter 'limitedSupportReasonId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdGet', 'limitedSupportReasonId', limitedSupportReasonId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/limited_support_reasons/{limited_support_reason_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"limited_support_reason_id"}}`, encodeURIComponent(String(limitedSupportReasonId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new reason to the cluster.
         * @param {string} clusterId 
         * @param {LimitedSupportReason} [limitedSupportReason] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsPost: async (clusterId: string, limitedSupportReason?: LimitedSupportReason, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsPost', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/limited_support_reasons`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(limitedSupportReason, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of log links.
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdLogsGet: async (clusterId: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdLogsGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/logs`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the log.
         * @param {string} clusterId 
         * @param {number} [offset] Line offset to start logs from. if 0 retreive entire log. If offset &gt; #lines return an empty log.
         * @param {number} [tail] Returns the number of tail lines from the end of the log. If there are no line breaks or the number of lines &lt; tail return the entire log. Either \&#39;tail\&#39; or \&#39;offset\&#39; can be set. Not both. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdLogsInstallGet: async (clusterId: string, offset?: number, tail?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdLogsInstallGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/logs/install`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (tail !== undefined) {
                localVarQueryParameter['tail'] = tail;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the log.
         * @param {string} clusterId 
         * @param {number} [offset] Line offset to start logs from. if 0 retreive entire log. If offset &gt; #lines return an empty log.
         * @param {number} [tail] Returns the number of tail lines from the end of the log. If there are no line breaks or the number of lines &lt; tail return the entire log. Either \&#39;tail\&#39; or \&#39;offset\&#39; can be set. Not both. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdLogsUninstallGet: async (clusterId: string, offset?: number, tail?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdLogsUninstallGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/logs/uninstall`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (tail !== undefined) {
                localVarQueryParameter['tail'] = tail;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of machine pools.
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMachinePoolsGet: async (clusterId: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdMachinePoolsGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/machine_pools`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the machine pool.
         * @param {string} clusterId 
         * @param {string} machinePoolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdDelete: async (clusterId: string, machinePoolId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdDelete', 'clusterId', clusterId)
            // verify required parameter 'machinePoolId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdDelete', 'machinePoolId', machinePoolId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/machine_pools/{machine_pool_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"machine_pool_id"}}`, encodeURIComponent(String(machinePoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the machine pool.
         * @param {string} clusterId 
         * @param {string} machinePoolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdGet: async (clusterId: string, machinePoolId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdGet', 'clusterId', clusterId)
            // verify required parameter 'machinePoolId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdGet', 'machinePoolId', machinePoolId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/machine_pools/{machine_pool_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"machine_pool_id"}}`, encodeURIComponent(String(machinePoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the machine pool.
         * @param {string} clusterId 
         * @param {string} machinePoolId 
         * @param {MachinePool} [machinePool] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdPatch: async (clusterId: string, machinePoolId: string, machinePool?: MachinePool, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdPatch', 'clusterId', clusterId)
            // verify required parameter 'machinePoolId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdPatch', 'machinePoolId', machinePoolId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/machine_pools/{machine_pool_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"machine_pool_id"}}`, encodeURIComponent(String(machinePoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(machinePool, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new machine pool to the cluster.
         * @param {string} clusterId 
         * @param {MachinePool} [machinePool] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMachinePoolsPost: async (clusterId: string, machinePool?: MachinePool, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdMachinePoolsPost', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/machine_pools`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(machinePool, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMetricQueriesAlertsGet: async (clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdMetricQueriesAlertsGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/metric_queries/alerts`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMetricQueriesClusterOperatorsGet: async (clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdMetricQueriesClusterOperatorsGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/metric_queries/cluster_operators`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the metrics.
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMetricQueriesCpuTotalByNodeRolesOsGet: async (clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdMetricQueriesCpuTotalByNodeRolesOsGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/metric_queries/cpu_total_by_node_roles_os`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMetricQueriesNodesGet: async (clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdMetricQueriesNodesGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/metric_queries/nodes`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the metrics.
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMetricQueriesSocketTotalByNodeRolesOsGet: async (clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdMetricQueriesSocketTotalByNodeRolesOsGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/metric_queries/socket_total_by_node_roles_os`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of node pools.
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdNodePoolsGet: async (clusterId: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdNodePoolsGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/node_pools`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the node pool.
         * @param {string} clusterId 
         * @param {string} nodePoolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdDelete: async (clusterId: string, nodePoolId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdDelete', 'clusterId', clusterId)
            // verify required parameter 'nodePoolId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdDelete', 'nodePoolId', nodePoolId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/node_pools/{node_pool_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"node_pool_id"}}`, encodeURIComponent(String(nodePoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the node pool.
         * @param {string} clusterId 
         * @param {string} nodePoolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdGet: async (clusterId: string, nodePoolId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdGet', 'clusterId', clusterId)
            // verify required parameter 'nodePoolId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdGet', 'nodePoolId', nodePoolId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/node_pools/{node_pool_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"node_pool_id"}}`, encodeURIComponent(String(nodePoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the node pool.
         * @param {string} clusterId 
         * @param {string} nodePoolId 
         * @param {NodePool} [nodePool] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdPatch: async (clusterId: string, nodePoolId: string, nodePool?: NodePool, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdPatch', 'clusterId', clusterId)
            // verify required parameter 'nodePoolId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdPatch', 'nodePoolId', nodePoolId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/node_pools/{node_pool_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"node_pool_id"}}`, encodeURIComponent(String(nodePoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nodePool, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of upgrade policies for the node pool.
         * @param {string} clusterId 
         * @param {string} nodePoolId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesGet: async (clusterId: string, nodePoolId: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesGet', 'clusterId', clusterId)
            // verify required parameter 'nodePoolId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesGet', 'nodePoolId', nodePoolId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/node_pools/{node_pool_id}/upgrade_policies`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"node_pool_id"}}`, encodeURIComponent(String(nodePoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the upgrade policy for the node pool.
         * @param {string} clusterId 
         * @param {string} nodePoolId 
         * @param {string} nodePoolUpgradePolicyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdDelete: async (clusterId: string, nodePoolId: string, nodePoolUpgradePolicyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdDelete', 'clusterId', clusterId)
            // verify required parameter 'nodePoolId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdDelete', 'nodePoolId', nodePoolId)
            // verify required parameter 'nodePoolUpgradePolicyId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdDelete', 'nodePoolUpgradePolicyId', nodePoolUpgradePolicyId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/node_pools/{node_pool_id}/upgrade_policies/{node_pool_upgrade_policy_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"node_pool_id"}}`, encodeURIComponent(String(nodePoolId)))
                .replace(`{${"node_pool_upgrade_policy_id"}}`, encodeURIComponent(String(nodePoolUpgradePolicyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the upgrade policy for the node pool.
         * @param {string} clusterId 
         * @param {string} nodePoolId 
         * @param {string} nodePoolUpgradePolicyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdGet: async (clusterId: string, nodePoolId: string, nodePoolUpgradePolicyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdGet', 'clusterId', clusterId)
            // verify required parameter 'nodePoolId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdGet', 'nodePoolId', nodePoolId)
            // verify required parameter 'nodePoolUpgradePolicyId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdGet', 'nodePoolUpgradePolicyId', nodePoolUpgradePolicyId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/node_pools/{node_pool_id}/upgrade_policies/{node_pool_upgrade_policy_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"node_pool_id"}}`, encodeURIComponent(String(nodePoolId)))
                .replace(`{${"node_pool_upgrade_policy_id"}}`, encodeURIComponent(String(nodePoolUpgradePolicyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the upgrade policy for the node pool.
         * @param {string} clusterId 
         * @param {string} nodePoolId 
         * @param {string} nodePoolUpgradePolicyId 
         * @param {NodePoolUpgradePolicy} [nodePoolUpgradePolicy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdPatch: async (clusterId: string, nodePoolId: string, nodePoolUpgradePolicyId: string, nodePoolUpgradePolicy?: NodePoolUpgradePolicy, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdPatch', 'clusterId', clusterId)
            // verify required parameter 'nodePoolId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdPatch', 'nodePoolId', nodePoolId)
            // verify required parameter 'nodePoolUpgradePolicyId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdPatch', 'nodePoolUpgradePolicyId', nodePoolUpgradePolicyId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/node_pools/{node_pool_id}/upgrade_policies/{node_pool_upgrade_policy_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"node_pool_id"}}`, encodeURIComponent(String(nodePoolId)))
                .replace(`{${"node_pool_upgrade_policy_id"}}`, encodeURIComponent(String(nodePoolUpgradePolicyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nodePoolUpgradePolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new upgrade policy to the node pool of the cluster.
         * @param {string} clusterId 
         * @param {string} nodePoolId 
         * @param {NodePoolUpgradePolicy} [nodePoolUpgradePolicy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesPost: async (clusterId: string, nodePoolId: string, nodePoolUpgradePolicy?: NodePoolUpgradePolicy, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesPost', 'clusterId', clusterId)
            // verify required parameter 'nodePoolId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesPost', 'nodePoolId', nodePoolId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/node_pools/{node_pool_id}/upgrade_policies`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"node_pool_id"}}`, encodeURIComponent(String(nodePoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nodePoolUpgradePolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new node pool to the cluster.
         * @param {string} clusterId 
         * @param {NodePool} [nodePool] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdNodePoolsPost: async (clusterId: string, nodePool?: NodePool, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdNodePoolsPost', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/node_pools`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nodePool, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the cluster.
         * @param {string} clusterId 
         * @param {Cluster} [cluster] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdPatch: async (clusterId: string, cluster?: Cluster, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdPatch', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cluster, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the product.
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdProductGet: async (clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdProductGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/product`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the provision shard.
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdProvisionShardDelete: async (clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdProvisionShardDelete', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/provision_shard`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the provision shard.
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdProvisionShardGet: async (clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdProvisionShardGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/provision_shard`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the details of the provision shard.
         * @param {string} clusterId 
         * @param {ProvisionShard} [provisionShard] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdProvisionShardPatch: async (clusterId: string, provisionShard?: ProvisionShard, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdProvisionShardPatch', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/provision_shard`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(provisionShard, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of resources for a cluster in error state
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdResourcesGet: async (clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdResourcesGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/resources`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves currently available cluster resources
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdResourcesLiveGet: async (clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdResourcesLiveGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/resources/live`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resumes from Hibernation.
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdResumePost: async (clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdResumePost', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/resume`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdStatusGet: async (clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdStatusGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/status`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of operator roles.
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdStsOperatorRolesGet: async (clusterId: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdStsOperatorRolesGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/sts_operator_roles`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the operator role.
         * @param {string} clusterId 
         * @param {string} operatorIamRoleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdStsOperatorRolesOperatorIamRoleIdDelete: async (clusterId: string, operatorIamRoleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdStsOperatorRolesOperatorIamRoleIdDelete', 'clusterId', clusterId)
            // verify required parameter 'operatorIamRoleId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdStsOperatorRolesOperatorIamRoleIdDelete', 'operatorIamRoleId', operatorIamRoleId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/sts_operator_roles/{operator_iam_role_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"operator_iam_role_id"}}`, encodeURIComponent(String(operatorIamRoleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new operator role to the cluster.
         * @param {string} clusterId 
         * @param {OperatorIAMRole} [operatorIAMRole] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdStsOperatorRolesPost: async (clusterId: string, operatorIAMRole?: OperatorIAMRole, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdStsOperatorRolesPost', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/sts_operator_roles`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(operatorIAMRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdStsSupportJumpRoleGet: async (clusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdStsSupportJumpRoleGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/sts_support_jump_role`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of tuning configs.
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdTuningConfigsGet: async (clusterId: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdTuningConfigsGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/tuning_configs`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new tuning config to the cluster.
         * @param {string} clusterId 
         * @param {TuningConfig} [tuningConfig] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdTuningConfigsPost: async (clusterId: string, tuningConfig?: TuningConfig, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdTuningConfigsPost', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/tuning_configs`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tuningConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the tuning config.
         * @param {string} clusterId 
         * @param {string} tuningConfigId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdDelete: async (clusterId: string, tuningConfigId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdDelete', 'clusterId', clusterId)
            // verify required parameter 'tuningConfigId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdDelete', 'tuningConfigId', tuningConfigId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/tuning_configs/{tuning_config_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"tuning_config_id"}}`, encodeURIComponent(String(tuningConfigId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the tuning config.
         * @param {string} clusterId 
         * @param {string} tuningConfigId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdGet: async (clusterId: string, tuningConfigId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdGet', 'clusterId', clusterId)
            // verify required parameter 'tuningConfigId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdGet', 'tuningConfigId', tuningConfigId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/tuning_configs/{tuning_config_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"tuning_config_id"}}`, encodeURIComponent(String(tuningConfigId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the tuning config.
         * @param {string} clusterId 
         * @param {string} tuningConfigId 
         * @param {TuningConfig} [tuningConfig] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdPatch: async (clusterId: string, tuningConfigId: string, tuningConfig?: TuningConfig, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdPatch', 'clusterId', clusterId)
            // verify required parameter 'tuningConfigId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdPatch', 'tuningConfigId', tuningConfigId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/tuning_configs/{tuning_config_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"tuning_config_id"}}`, encodeURIComponent(String(tuningConfigId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tuningConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of upgrade policies.
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdUpgradePoliciesGet: async (clusterId: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdUpgradePoliciesGet', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/upgrade_policies`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new upgrade policy to the cluster.
         * @param {string} clusterId 
         * @param {UpgradePolicy} [upgradePolicy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdUpgradePoliciesPost: async (clusterId: string, upgradePolicy?: UpgradePolicy, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdUpgradePoliciesPost', 'clusterId', clusterId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/upgrade_policies`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(upgradePolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the upgrade policy.
         * @param {string} clusterId 
         * @param {string} upgradePolicyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdDelete: async (clusterId: string, upgradePolicyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdDelete', 'clusterId', clusterId)
            // verify required parameter 'upgradePolicyId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdDelete', 'upgradePolicyId', upgradePolicyId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/upgrade_policies/{upgrade_policy_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"upgrade_policy_id"}}`, encodeURIComponent(String(upgradePolicyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the upgrade policy.
         * @param {string} clusterId 
         * @param {string} upgradePolicyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdGet: async (clusterId: string, upgradePolicyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdGet', 'clusterId', clusterId)
            // verify required parameter 'upgradePolicyId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdGet', 'upgradePolicyId', upgradePolicyId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/upgrade_policies/{upgrade_policy_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"upgrade_policy_id"}}`, encodeURIComponent(String(upgradePolicyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the upgrade policy.
         * @param {string} clusterId 
         * @param {string} upgradePolicyId 
         * @param {UpgradePolicy} [upgradePolicy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdPatch: async (clusterId: string, upgradePolicyId: string, upgradePolicy?: UpgradePolicy, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdPatch', 'clusterId', clusterId)
            // verify required parameter 'upgradePolicyId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdPatch', 'upgradePolicyId', upgradePolicyId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/upgrade_policies/{upgrade_policy_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"upgrade_policy_id"}}`, encodeURIComponent(String(upgradePolicyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(upgradePolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the upgrade policy state.
         * @param {string} clusterId 
         * @param {string} upgradePolicyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStateGet: async (clusterId: string, upgradePolicyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStateGet', 'clusterId', clusterId)
            // verify required parameter 'upgradePolicyId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStateGet', 'upgradePolicyId', upgradePolicyId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/upgrade_policies/{upgrade_policy_id}/state`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"upgrade_policy_id"}}`, encodeURIComponent(String(upgradePolicyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the upgrade policy state.
         * @param {string} clusterId 
         * @param {string} upgradePolicyId 
         * @param {UpgradePolicyState} [upgradePolicyState] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStatePatch: async (clusterId: string, upgradePolicyId: string, upgradePolicyState?: UpgradePolicyState, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStatePatch', 'clusterId', clusterId)
            // verify required parameter 'upgradePolicyId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStatePatch', 'upgradePolicyId', upgradePolicyId)
            const localVarPath = `/api/clusters_mgmt/v1/clusters/{cluster_id}/upgrade_policies/{upgrade_policy_id}/state`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"upgrade_policy_id"}}`, encodeURIComponent(String(upgradePolicyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(upgradePolicyState, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of clusters.
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the cluster instead of the names of the columns of a table. For example, in order to sort the clusters descending by region identifier the value should be:  &#x60;&#x60;&#x60;sql region.id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the cluster instead of the names of the columns of a table. For example, in order to retrieve all the clusters with a name starting with &#x60;my&#x60; in the &#x60;us-east-1&#x60; region the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; and region.id &#x3D; \&#39;us-east-1\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the clusters that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersGet: async (order?: string, page?: number, search?: string, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provision a new cluster and add it to the collection of clusters.  See the `register_cluster` method for adding an existing cluster.
         * @param {Cluster} [cluster] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersPost: async (cluster?: Cluster, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/clusters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cluster, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the DNS domain.
         * @param {string} dnsDomainId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1DnsDomainsDnsDomainIdDelete: async (dnsDomainId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dnsDomainId' is not null or undefined
            assertParamExists('apiClustersMgmtV1DnsDomainsDnsDomainIdDelete', 'dnsDomainId', dnsDomainId)
            const localVarPath = `/api/clusters_mgmt/v1/dns_domains/{dns_domain_id}`
                .replace(`{${"dns_domain_id"}}`, encodeURIComponent(String(dnsDomainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the DNS domain.
         * @param {string} dnsDomainId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1DnsDomainsDnsDomainIdGet: async (dnsDomainId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dnsDomainId' is not null or undefined
            assertParamExists('apiClustersMgmtV1DnsDomainsDnsDomainIdGet', 'dnsDomainId', dnsDomainId)
            const localVarPath = `/api/clusters_mgmt/v1/dns_domains/{dns_domain_id}`
                .replace(`{${"dns_domain_id"}}`, encodeURIComponent(String(dnsDomainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the details of the DNS domain.
         * @param {string} dnsDomainId 
         * @param {DNSDomain} [dNSDomain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1DnsDomainsDnsDomainIdPatch: async (dnsDomainId: string, dNSDomain?: DNSDomain, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dnsDomainId' is not null or undefined
            assertParamExists('apiClustersMgmtV1DnsDomainsDnsDomainIdPatch', 'dnsDomainId', dnsDomainId)
            const localVarPath = `/api/clusters_mgmt/v1/dns_domains/{dns_domain_id}`
                .replace(`{${"dns_domain_id"}}`, encodeURIComponent(String(dnsDomainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dNSDomain, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the dns domain instead of the names of the columns of a table. For example, in order to retrieve all the dns domains with a ID starting with &#x60;02a5&#x60; should be:  &#x60;&#x60;&#x60;sql id like \&#39;02a5%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the dns domains that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1DnsDomainsGet: async (page?: number, search?: string, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/dns_domains`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a DNS domain.
         * @param {DNSDomain} [dNSDomain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1DnsDomainsPost: async (dNSDomain?: DNSDomain, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/dns_domains`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dNSDomain, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the environment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1EnvironmentGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/environment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the environment.  Attributes that can be updated are:  - `last_upgrade_available_check` - `last_limited_support_check`
         * @param {Environment} [environment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1EnvironmentPatch: async (environment?: Environment, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/environment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new event to be tracked. When sending a new event request, it gets tracked in Prometheus, Pendo, CloudWatch, or whichever analytics client is configured as part of clusters service. This allows for reporting on events that happen outside of a regular API request, but are found to be useful for understanding customer needs and possible blockers.
         * @param {Event} [event] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1EventsPost: async (event?: Event, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(event, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the cluster flavour.
         * @param {string} flavourId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1FlavoursFlavourIdGet: async (flavourId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flavourId' is not null or undefined
            assertParamExists('apiClustersMgmtV1FlavoursFlavourIdGet', 'flavourId', flavourId)
            const localVarPath = `/api/clusters_mgmt/v1/flavours/{flavour_id}`
                .replace(`{${"flavour_id"}}`, encodeURIComponent(String(flavourId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the flavour.  Attributes that can be updated are:  - `aws.infra_volume` - `aws.infra_instance_type` - `gcp.infra_instance_type`
         * @param {string} flavourId 
         * @param {Flavour} [flavour] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1FlavoursFlavourIdPatch: async (flavourId: string, flavour?: Flavour, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flavourId' is not null or undefined
            assertParamExists('apiClustersMgmtV1FlavoursFlavourIdPatch', 'flavourId', flavourId)
            const localVarPath = `/api/clusters_mgmt/v1/flavours/{flavour_id}`
                .replace(`{${"flavour_id"}}`, encodeURIComponent(String(flavourId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flavour, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the flavour instead of the names of the columns of a table. For example, in order to sort the flavours descending by name the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the flavour instead of the names of the columns of a table. For example, in order to retrieve all the flavours with a name starting with &#x60;my&#x60;the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the flavours that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1FlavoursGet: async (order?: string, page?: number, search?: string, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/flavours`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new cluster flavour.
         * @param {Flavour} [flavour] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1FlavoursPost: async (flavour?: Flavour, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/flavours`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flavour, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of encryption keys. IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider.
         * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
         * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider.
         * @param {CloudProviderData} [cloudProviderData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1GcpInquiriesEncryptionKeysPost: async (page?: number, size?: number, cloudProviderData?: CloudProviderData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/gcp_inquiries/encryption_keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloudProviderData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of available key rings of the cloud provider. IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider.
         * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
         * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of key rings of the provider.
         * @param {CloudProviderData} [cloudProviderData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1GcpInquiriesKeyRingsPost: async (page?: number, size?: number, cloudProviderData?: CloudProviderData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/gcp_inquiries/key_rings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloudProviderData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of available regions of the cloud provider. IMPORTANT: This list doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider.
         * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
         * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider.
         * @param {CloudProviderData} [cloudProviderData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1GcpInquiriesRegionsPost: async (page?: number, size?: number, cloudProviderData?: CloudProviderData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/gcp_inquiries/regions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloudProviderData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of available vpcs of the cloud provider for specific region. IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available vpcs of the provider.
         * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
         * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of vpcs of the provider.
         * @param {CloudProviderData} [cloudProviderData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1GcpInquiriesVpcsPost: async (page?: number, size?: number, cloudProviderData?: CloudProviderData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/gcp_inquiries/vpcs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloudProviderData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the version metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1Get: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of templates.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1LimitedSupportReasonTemplatesGet: async (page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/limited_support_reason_templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the template.
         * @param {string} limitedSupportReasonTemplateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1LimitedSupportReasonTemplatesLimitedSupportReasonTemplateIdGet: async (limitedSupportReasonTemplateId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'limitedSupportReasonTemplateId' is not null or undefined
            assertParamExists('apiClustersMgmtV1LimitedSupportReasonTemplatesLimitedSupportReasonTemplateIdGet', 'limitedSupportReasonTemplateId', limitedSupportReasonTemplateId)
            const localVarPath = `/api/clusters_mgmt/v1/limited_support_reason_templates/{limited_support_reason_template_id}`
                .replace(`{${"limited_support_reason_template_id"}}`, encodeURIComponent(String(limitedSupportReasonTemplateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of machine types.
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the machine type instead of the names of the columns of a table. For example, in order to sort the machine types descending by name identifier the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the machine type instead of the names of the columns of a table. For example, in order to retrieve all the machine types with a name starting with &#x60;A&#x60; the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;A%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the machine types that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1MachineTypesGet: async (order?: string, page?: number, search?: string, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/machine_types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the machine type.
         * @param {string} machineTypeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1MachineTypesMachineTypeIdGet: async (machineTypeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'machineTypeId' is not null or undefined
            assertParamExists('apiClustersMgmtV1MachineTypesMachineTypeIdGet', 'machineTypeId', machineTypeId)
            const localVarPath = `/api/clusters_mgmt/v1/machine_types/{machine_type_id}`
                .replace(`{${"machine_type_id"}}`, encodeURIComponent(String(machineTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of a subnet network verification.
         * @param {string} networkVerificationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1NetworkVerificationsNetworkVerificationIdGet: async (networkVerificationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkVerificationId' is not null or undefined
            assertParamExists('apiClustersMgmtV1NetworkVerificationsNetworkVerificationIdGet', 'networkVerificationId', networkVerificationId)
            const localVarPath = `/api/clusters_mgmt/v1/network_verifications/{network_verification_id}`
                .replace(`{${"network_verification_id"}}`, encodeURIComponent(String(networkVerificationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates an entry for a network verification for each subnet supplied setting then to initial state.
         * @param {NetworkVerification} [networkVerification] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1NetworkVerificationsPost: async (networkVerification?: NetworkVerification, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/network_verifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkVerification, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of oidc configs.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1OidcConfigsGet: async (page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/oidc_configs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the OidcConfig.
         * @param {string} oidcConfigId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1OidcConfigsOidcConfigIdDelete: async (oidcConfigId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'oidcConfigId' is not null or undefined
            assertParamExists('apiClustersMgmtV1OidcConfigsOidcConfigIdDelete', 'oidcConfigId', oidcConfigId)
            const localVarPath = `/api/clusters_mgmt/v1/oidc_configs/{oidc_config_id}`
                .replace(`{${"oidc_config_id"}}`, encodeURIComponent(String(oidcConfigId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of an OidcConfig.
         * @param {string} oidcConfigId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1OidcConfigsOidcConfigIdGet: async (oidcConfigId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'oidcConfigId' is not null or undefined
            assertParamExists('apiClustersMgmtV1OidcConfigsOidcConfigIdGet', 'oidcConfigId', oidcConfigId)
            const localVarPath = `/api/clusters_mgmt/v1/oidc_configs/{oidc_config_id}`
                .replace(`{${"oidc_config_id"}}`, encodeURIComponent(String(oidcConfigId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates attributes of an OidcConfig.
         * @param {string} oidcConfigId 
         * @param {OidcConfig} [oidcConfig] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1OidcConfigsOidcConfigIdPatch: async (oidcConfigId: string, oidcConfig?: OidcConfig, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'oidcConfigId' is not null or undefined
            assertParamExists('apiClustersMgmtV1OidcConfigsOidcConfigIdPatch', 'oidcConfigId', oidcConfigId)
            const localVarPath = `/api/clusters_mgmt/v1/oidc_configs/{oidc_config_id}`
                .replace(`{${"oidc_config_id"}}`, encodeURIComponent(String(oidcConfigId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oidcConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a hosting under Red Hat\'s S3 bucket for byo oidc configuration.
         * @param {OidcConfig} [oidcConfig] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1OidcConfigsPost: async (oidcConfig?: OidcConfig, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/oidc_configs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oidcConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of pending delete clusters.
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the pending delete cluster instead of the names of the columns of a table. For example, in order to sort the pending delete clusters descending by creation timestamp (i.e. their deletion time) the value should be:  &#x60;&#x60;&#x60;sql creation_timestamp desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the pending delete cluster instead of the names of the columns of a table. For example, in order to retrieve all the pending delete clusters with creation time later than 2023-03-01T00:00:00Z the following is required:  &#x60;&#x60;&#x60;sql creation_timestamp &gt; \&#39;2023-03-01T00:00:00Z\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the pending delete clusters that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1PendingDeleteClustersGet: async (order?: string, page?: number, search?: string, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/pending_delete_clusters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the pending delete cluster.
         * @param {string} pendingDeleteClusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1PendingDeleteClustersPendingDeleteClusterIdGet: async (pendingDeleteClusterId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pendingDeleteClusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1PendingDeleteClustersPendingDeleteClusterIdGet', 'pendingDeleteClusterId', pendingDeleteClusterId)
            const localVarPath = `/api/clusters_mgmt/v1/pending_delete_clusters/{pending_delete_cluster_id}`
                .replace(`{${"pending_delete_cluster_id"}}`, encodeURIComponent(String(pendingDeleteClusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the pending delete cluster entry.
         * @param {string} pendingDeleteClusterId 
         * @param {PendingDeleteCluster} [pendingDeleteCluster] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1PendingDeleteClustersPendingDeleteClusterIdPatch: async (pendingDeleteClusterId: string, pendingDeleteCluster?: PendingDeleteCluster, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pendingDeleteClusterId' is not null or undefined
            assertParamExists('apiClustersMgmtV1PendingDeleteClustersPendingDeleteClusterIdPatch', 'pendingDeleteClusterId', pendingDeleteClusterId)
            const localVarPath = `/api/clusters_mgmt/v1/pending_delete_clusters/{pending_delete_cluster_id}`
                .replace(`{${"pending_delete_cluster_id"}}`, encodeURIComponent(String(pendingDeleteClusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pendingDeleteCluster, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of products.
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the product instead of the names of the columns of a table. For example, in order to sort the products descending by name the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the product instead of the names of the columns of a table. For example, in order to retrieve all the products with a name starting with &#x60;my&#x60; the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the products that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ProductsGet: async (order?: string, page?: number, search?: string, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the product.
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ProductsProductIdGet: async (productId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ProductsProductIdGet', 'productId', productId)
            const localVarPath = `/api/clusters_mgmt/v1/products/{product_id}`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the cluster instead of the names of the columns of a table. For example, in order to retrieve all the clusters with a name starting with &#x60;my&#x60; in the &#x60;us-east-1&#x60; region the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; and region.id &#x3D; \&#39;us-east-1\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the provision shards that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ProvisionShardsGet: async (page?: number, search?: string, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/provision_shards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a provision shard.
         * @param {ProvisionShard} [provisionShard] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ProvisionShardsPost: async (provisionShard?: ProvisionShard, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/provision_shards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(provisionShard, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the provision shard.
         * @param {string} provisionShardId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ProvisionShardsProvisionShardIdDelete: async (provisionShardId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provisionShardId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ProvisionShardsProvisionShardIdDelete', 'provisionShardId', provisionShardId)
            const localVarPath = `/api/clusters_mgmt/v1/provision_shards/{provision_shard_id}`
                .replace(`{${"provision_shard_id"}}`, encodeURIComponent(String(provisionShardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the provision shard.
         * @param {string} provisionShardId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ProvisionShardsProvisionShardIdGet: async (provisionShardId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provisionShardId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ProvisionShardsProvisionShardIdGet', 'provisionShardId', provisionShardId)
            const localVarPath = `/api/clusters_mgmt/v1/provision_shards/{provision_shard_id}`
                .replace(`{${"provision_shard_id"}}`, encodeURIComponent(String(provisionShardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the details of the provision shard.
         * @param {string} provisionShardId 
         * @param {ProvisionShard} [provisionShard] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ProvisionShardsProvisionShardIdPatch: async (provisionShardId: string, provisionShard?: ProvisionShard, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provisionShardId' is not null or undefined
            assertParamExists('apiClustersMgmtV1ProvisionShardsProvisionShardIdPatch', 'provisionShardId', provisionShardId)
            const localVarPath = `/api/clusters_mgmt/v1/provision_shards/{provision_shard_id}`
                .replace(`{${"provision_shard_id"}}`, encodeURIComponent(String(provisionShardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(provisionShard, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of trusted ip addresses.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1TrustedIpAddressesGet: async (page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/trusted_ip_addresses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the trusted ip adresses.
         * @param {string} trustedIpId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1TrustedIpAddressesTrustedIpIdGet: async (trustedIpId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trustedIpId' is not null or undefined
            assertParamExists('apiClustersMgmtV1TrustedIpAddressesTrustedIpIdGet', 'trustedIpId', trustedIpId)
            const localVarPath = `/api/clusters_mgmt/v1/trusted_ip_addresses/{trusted_ip_id}`
                .replace(`{${"trusted_ip_id"}}`, encodeURIComponent(String(trustedIpId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of version gates.
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of an SQL statement, but using the names of the attributes of the version gate instead of the names of the columns of a table. For example, in order to sort the version gates descending by identifier the value should be:  &#x60;&#x60;&#x60;sql id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the version gate instead of the names of the columns of a table.  If the parameter isn\&#39;t provided, or if the value is empty, then all the version gates that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.  Default value is &#x60;100&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1VersionGatesGet: async (order?: string, page?: number, search?: string, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/version_gates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new version gate
         * @param {VersionGate} [versionGate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1VersionGatesPost: async (versionGate?: VersionGate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/version_gates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(versionGate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the version gate.
         * @param {string} versionGateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1VersionGatesVersionGateIdDelete: async (versionGateId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'versionGateId' is not null or undefined
            assertParamExists('apiClustersMgmtV1VersionGatesVersionGateIdDelete', 'versionGateId', versionGateId)
            const localVarPath = `/api/clusters_mgmt/v1/version_gates/{version_gate_id}`
                .replace(`{${"version_gate_id"}}`, encodeURIComponent(String(versionGateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the version gate.
         * @param {string} versionGateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1VersionGatesVersionGateIdGet: async (versionGateId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'versionGateId' is not null or undefined
            assertParamExists('apiClustersMgmtV1VersionGatesVersionGateIdGet', 'versionGateId', versionGateId)
            const localVarPath = `/api/clusters_mgmt/v1/version_gates/{version_gate_id}`
                .replace(`{${"version_gate_id"}}`, encodeURIComponent(String(versionGateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of versions.
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the version instead of the names of the columns of a table. For example, in order to sort the versions descending by identifier the value should be:  &#x60;&#x60;&#x60;sql id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the version instead of the names of the columns of a table. For example, in order to retrieve all the versions that are enabled:  &#x60;&#x60;&#x60;sql enabled &#x3D; \&#39;t\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the versions that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.  Default value is &#x60;100&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1VersionsGet: async (order?: string, page?: number, search?: string, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/clusters_mgmt/v1/versions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of the version.
         * @param {string} versionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1VersionsVersionIdGet: async (versionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('apiClustersMgmtV1VersionsVersionIdGet', 'versionId', versionId)
            const localVarPath = `/api/clusters_mgmt/v1/versions/{version_id}`
                .replace(`{${"version_id"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes the add-on.
         * @param {string} addonId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1AddonsAddonIdDelete(addonId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1AddonsAddonIdDelete(addonId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the add-on.
         * @param {string} addonId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1AddonsAddonIdGet(addonId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddOn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1AddonsAddonIdGet(addonId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the add-on.
         * @param {string} addonId 
         * @param {AddOn} [addOn] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1AddonsAddonIdPatch(addonId: string, addOn?: AddOn, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddOn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1AddonsAddonIdPatch(addonId, addOn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of add-on versions.
         * @param {string} addonId 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to sort the add-on versions descending by id the value should be:  &#x60;&#x60;&#x60;sql id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the add-on version instead of the names of the columns of a table. For example, in order to retrieve all the add-on versions with an id starting with &#x60;0.1&#x60; the value should be:  &#x60;&#x60;&#x60;sql id like \&#39;0.1.%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the add-on versions that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1AddonsAddonIdVersionsGet(addonId: string, order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1AddonsAddonIdVersionsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1AddonsAddonIdVersionsGet(addonId, order, page, search, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new add-on version and add it to the collection of add-ons.
         * @param {string} addonId 
         * @param {AddOnVersion} [addOnVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1AddonsAddonIdVersionsPost(addonId: string, addOnVersion?: AddOnVersion, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddOnVersion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1AddonsAddonIdVersionsPost(addonId, addOnVersion, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the add-on version.
         * @param {string} addonId 
         * @param {string} versionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1AddonsAddonIdVersionsVersionIdDelete(addonId: string, versionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1AddonsAddonIdVersionsVersionIdDelete(addonId, versionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the add-on version.
         * @param {string} addonId 
         * @param {string} versionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1AddonsAddonIdVersionsVersionIdGet(addonId: string, versionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddOnVersion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1AddonsAddonIdVersionsVersionIdGet(addonId, versionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the add-on version.
         * @param {string} addonId 
         * @param {string} versionId 
         * @param {AddOnVersion} [addOnVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1AddonsAddonIdVersionsVersionIdPatch(addonId: string, versionId: string, addOnVersion?: AddOnVersion, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddOnVersion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1AddonsAddonIdVersionsVersionIdPatch(addonId, versionId, addOnVersion, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of add-ons.
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to sort the add-ons descending by name the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to retrieve all the add-ons with a name starting with &#x60;my&#x60; the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the add-ons that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1AddonsGet(order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1AddonsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1AddonsGet(order, page, search, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new add-on and add it to the collection of add-ons.
         * @param {AddOn} [addOn] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1AddonsPost(addOn?: AddOn, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddOn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1AddonsPost(addOn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the aws infrastructure access role.
         * @param {string} awsInfrastructureAccessRoleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1AwsInfrastructureAccessRolesAwsInfrastructureAccessRoleIdGet(awsInfrastructureAccessRoleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AWSInfrastructureAccessRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1AwsInfrastructureAccessRolesAwsInfrastructureAccessRoleIdGet(awsInfrastructureAccessRoleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the role instead of the names of the columns of a table. For example, in order to sort the roles descending by dislay_name the value should be:  &#x60;&#x60;&#x60;sql display_name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the role instead of the names of the columns of a table. For example, in order to retrieve all the role with a name starting with &#x60;my&#x60;the value should be:  &#x60;&#x60;&#x60;sql display_name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the roles that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1AwsInfrastructureAccessRolesGet(order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1AwsInfrastructureAccessRolesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1AwsInfrastructureAccessRolesGet(order, page, search, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of machine types in the provided region.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {CloudProviderData} [cloudProviderData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1AwsInquiriesMachineTypesPost(page?: number, size?: number, cloudProviderData?: CloudProviderData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1AwsInquiriesMachineTypesPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1AwsInquiriesMachineTypesPost(page, size, cloudProviderData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of available regions of the cloud provider. IMPORTANT: This list doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider.
         * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
         * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider.
         * @param {CloudProviderData} [cloudProviderData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1AwsInquiriesRegionsPost(page?: number, size?: number, cloudProviderData?: CloudProviderData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1AwsInquiriesRegionsPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1AwsInquiriesRegionsPost(page, size, cloudProviderData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of policies.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1AwsInquiriesStsCredentialRequestsGet(page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1AwsInquiriesStsCredentialRequestsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1AwsInquiriesStsCredentialRequestsGet(page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of policies.
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the awsstspolicies instead of the names of the columns of a table. For example, in order to sort the policies descending by operator type identifier the value should be:  &#x60;&#x60;&#x60;sql orderBy id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the awsstspolicies instead of the names of the columns of a table. For example, in order to retrieve all the policies of type  &#x60;operatorrole&#x60; should be:  &#x60;&#x60;&#x60;sql policy_type like \&#39;OperatorRole%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the policies  will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1AwsInquiriesStsPoliciesGet(order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1AwsInquiriesStsPoliciesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1AwsInquiriesStsPoliciesGet(order, page, search, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of available vpcs of the cloud provider for specific region. IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available vpcs of the provider.
         * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
         * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of vpcs of the provider.
         * @param {CloudProviderData} [cloudProviderData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1AwsInquiriesVpcsPost(page?: number, size?: number, cloudProviderData?: CloudProviderData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1AwsInquiriesVpcsPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1AwsInquiriesVpcsPost(page, size, cloudProviderData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of available regions of the cloud provider.  IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider.
         * @param {string} cloudProviderId 
         * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
         * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider.
         * @param {AWS} [aWS] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1CloudProvidersCloudProviderIdAvailableRegionsPost(cloudProviderId: string, page?: number, size?: number, aWS?: AWS, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1CloudProvidersCloudProviderIdAvailableRegionsPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1CloudProvidersCloudProviderIdAvailableRegionsPost(cloudProviderId, page, size, aWS, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the cloud provider.
         * @param {string} cloudProviderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1CloudProvidersCloudProviderIdGet(cloudProviderId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudProvider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1CloudProvidersCloudProviderIdGet(cloudProviderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of regions of the cloud provider.  IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of regions of the provider.
         * @param {string} cloudProviderId 
         * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
         * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsGet(cloudProviderId: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1CloudProvidersCloudProviderIdRegionsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsGet(cloudProviderId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a cloud region to the database.
         * @param {string} cloudProviderId 
         * @param {CloudRegion} [cloudRegion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsPost(cloudProviderId: string, cloudRegion?: CloudRegion, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudRegion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsPost(cloudProviderId, cloudRegion, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the region.
         * @param {string} cloudProviderId 
         * @param {string} regionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdDelete(cloudProviderId: string, regionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdDelete(cloudProviderId, regionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the region.
         * @param {string} cloudProviderId 
         * @param {string} regionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdGet(cloudProviderId: string, regionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudRegion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdGet(cloudProviderId, regionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the region.
         * @param {string} cloudProviderId 
         * @param {string} regionId 
         * @param {CloudRegion} [cloudRegion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdPatch(cloudProviderId: string, regionId: string, cloudRegion?: CloudRegion, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudRegion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdPatch(cloudProviderId, regionId, cloudRegion, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of cloud providers.
         * @param {boolean} [fetchRegions] If true, includes the regions on each provider in the output. Could slow request response time.
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the cloud provider instead of the names of the columns of a table. For example, in order to sort the clusters descending by name identifier the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the cloud provider instead of the names of the columns of a table. For example, in order to retrieve all the cloud providers with a name starting with &#x60;A&#x60; the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;A%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the clusters that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1CloudProvidersGet(fetchRegions?: boolean, order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1CloudProvidersGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1CloudProvidersGet(fetchRegions, order, page, search, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {string} addonInquiryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdAddonInquiriesAddonInquiryIdGet(clusterId: string, addonInquiryId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddOn>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdAddonInquiriesAddonInquiryIdGet(clusterId, addonInquiryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to sort the add-ons descending by name the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to retrieve all the add-ons with a name starting with &#x60;my&#x60; the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the add-ons that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdAddonInquiriesGet(clusterId: string, order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1AddonsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdAddonInquiriesGet(clusterId, order, page, search, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the addon upgrade policy.
         * @param {string} clusterId 
         * @param {string} addonUpgradePolicyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdDelete(clusterId: string, addonUpgradePolicyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdDelete(clusterId, addonUpgradePolicyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the addon upgrade policy.
         * @param {string} clusterId 
         * @param {string} addonUpgradePolicyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdGet(clusterId: string, addonUpgradePolicyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddonUpgradePolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdGet(clusterId, addonUpgradePolicyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the addon upgrade policy.
         * @param {string} clusterId 
         * @param {string} addonUpgradePolicyId 
         * @param {AddonUpgradePolicy} [addonUpgradePolicy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdPatch(clusterId: string, addonUpgradePolicyId: string, addonUpgradePolicy?: AddonUpgradePolicy, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddonUpgradePolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdPatch(clusterId, addonUpgradePolicyId, addonUpgradePolicy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the upgrade policy state.
         * @param {string} clusterId 
         * @param {string} addonUpgradePolicyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdStateGet(clusterId: string, addonUpgradePolicyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddonUpgradePolicyState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdStateGet(clusterId, addonUpgradePolicyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the upgrade policy state.
         * @param {string} clusterId 
         * @param {string} addonUpgradePolicyId 
         * @param {AddonUpgradePolicyState} [addonUpgradePolicyState] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdStatePatch(clusterId: string, addonUpgradePolicyId: string, addonUpgradePolicyState?: AddonUpgradePolicyState, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddonUpgradePolicyState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdStatePatch(clusterId, addonUpgradePolicyId, addonUpgradePolicyState, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of addon upgrade policies.
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesGet(clusterId: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesGet(clusterId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new addon upgrade policy to the cluster.
         * @param {string} clusterId 
         * @param {AddonUpgradePolicy} [addonUpgradePolicy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesPost(clusterId: string, addonUpgradePolicy?: AddonUpgradePolicy, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddonUpgradePolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesPost(clusterId, addonUpgradePolicy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an add-on installation and remove it from the collection of add-on installations on the cluster.
         * @param {string} clusterId 
         * @param {string} addoninstallationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdDelete(clusterId: string, addoninstallationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdDelete(clusterId, addoninstallationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the add-on installation.
         * @param {string} clusterId 
         * @param {string} addoninstallationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdGet(clusterId: string, addoninstallationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddOnInstallation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdGet(clusterId, addoninstallationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the add-on installation.
         * @param {string} clusterId 
         * @param {string} addoninstallationId 
         * @param {AddOnInstallation} [addOnInstallation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdPatch(clusterId: string, addoninstallationId: string, addOnInstallation?: AddOnInstallation, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddOnInstallation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdPatch(clusterId, addoninstallationId, addOnInstallation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of add-on installations.
         * @param {string} clusterId 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the add-on installation instead of the names of the columns of a table. For example, in order to sort the add-on installations descending by name the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the add-on installation instead of the names of the columns of a table. For example, in order to retrieve all the add-on installations with a name starting with &#x60;my&#x60; the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the add-on installations that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdAddonsGet(clusterId: string, order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1ClustersClusterIdAddonsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdAddonsGet(clusterId, order, page, search, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new add-on installation and add it to the collection of add-on installations on the cluster.
         * @param {string} clusterId 
         * @param {AddOnInstallation} [addOnInstallation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdAddonsPost(clusterId: string, addOnInstallation?: AddOnInstallation, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddOnInstallation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdAddonsPost(clusterId, addOnInstallation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the cluster autoscaler.
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdAutoscalerDelete(clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdAutoscalerDelete(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the autoscaler of a cluster.
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdAutoscalerGet(clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterAutoscaler>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdAutoscalerGet(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the cluster autoscaler.
         * @param {string} clusterId 
         * @param {ClusterAutoscaler} [clusterAutoscaler] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdAutoscalerPatch(clusterId: string, clusterAutoscaler?: ClusterAutoscaler, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterAutoscaler>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdAutoscalerPatch(clusterId, clusterAutoscaler, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new cluster autoscaler object.
         * @param {string} clusterId 
         * @param {ClusterAutoscaler} [clusterAutoscaler] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdAutoscalerPost(clusterId: string, clusterAutoscaler?: ClusterAutoscaler, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterAutoscaler>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdAutoscalerPost(clusterId, clusterAutoscaler, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the AWS infrastructure access role grant.
         * @param {string} clusterId 
         * @param {string} awsInfrastructureAccessRoleGrantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdDelete(clusterId: string, awsInfrastructureAccessRoleGrantId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdDelete(clusterId, awsInfrastructureAccessRoleGrantId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the AWS infrastructure access role grant.
         * @param {string} clusterId 
         * @param {string} awsInfrastructureAccessRoleGrantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdGet(clusterId: string, awsInfrastructureAccessRoleGrantId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AWSInfrastructureAccessRoleGrant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdGet(clusterId, awsInfrastructureAccessRoleGrantId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of AWS infrastructure access role grants.
         * @param {string} clusterId 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the AWS infrastructure access role grant instead of the names of the columns of a table. For example, in order to sort the AWS infrastructure access role grants descending by user ARN the value should be:  &#x60;&#x60;&#x60;sql user_arn desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the AWS infrastructure access role grant instead of the names of the columns of a table. For example, in order to retrieve all the AWS infrastructure access role grants with a user ARN starting with &#x60;user&#x60; the value should be:  &#x60;&#x60;&#x60;sql user_arn like \&#39;%user\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the AWS infrastructure access role grants that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsGet(clusterId: string, order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsGet(clusterId, order, page, search, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new AWS infrastructure access role grant and add it to the collection of AWS infrastructure access role grants on the cluster.
         * @param {string} clusterId 
         * @param {AWSInfrastructureAccessRoleGrant} [aWSInfrastructureAccessRoleGrant] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsPost(clusterId: string, aWSInfrastructureAccessRoleGrant?: AWSInfrastructureAccessRoleGrant, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AWSInfrastructureAccessRoleGrant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsPost(clusterId, aWSInfrastructureAccessRoleGrant, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the configuration for the Private Link.
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationGet(clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrivateLinkConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationGet(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of principals.
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the role binding instead of the names of the columns of a table. For example, in order to retrieve role bindings with role_id AuthenticatedUser:  &#x60;&#x60;&#x60;sql role_id &#x3D; \&#39;AuthenticatedUser\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the items that the user has permission to see will be returned.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsGet(clusterId: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsGet(clusterId, page, search, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new principal for the Private Link.
         * @param {string} clusterId 
         * @param {PrivateLinkPrincipal} [privateLinkPrincipal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPost(clusterId: string, privateLinkPrincipal?: PrivateLinkPrincipal, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrivateLinkPrincipal>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPost(clusterId, privateLinkPrincipal, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the principal.
         * @param {string} clusterId 
         * @param {string} principalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPrincipalIdDelete(clusterId: string, principalId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPrincipalIdDelete(clusterId, principalId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the principal.
         * @param {string} clusterId 
         * @param {string} principalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPrincipalIdGet(clusterId: string, principalId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrivateLinkPrincipal>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPrincipalIdGet(clusterId, principalId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the clusterdeployment.
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdClusterdeploymentDelete(clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdClusterdeploymentDelete(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the upgrade policy for the control plane.
         * @param {string} clusterId 
         * @param {string} controlPlaneUpgradePolicyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdDelete(clusterId: string, controlPlaneUpgradePolicyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdDelete(clusterId, controlPlaneUpgradePolicyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the upgrade policy for the control plane.
         * @param {string} clusterId 
         * @param {string} controlPlaneUpgradePolicyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdGet(clusterId: string, controlPlaneUpgradePolicyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ControlPlaneUpgradePolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdGet(clusterId, controlPlaneUpgradePolicyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the upgrade policy for the control plane.
         * @param {string} clusterId 
         * @param {string} controlPlaneUpgradePolicyId 
         * @param {ControlPlaneUpgradePolicy} [controlPlaneUpgradePolicy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdPatch(clusterId: string, controlPlaneUpgradePolicyId: string, controlPlaneUpgradePolicy?: ControlPlaneUpgradePolicy, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ControlPlaneUpgradePolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdPatch(clusterId, controlPlaneUpgradePolicyId, controlPlaneUpgradePolicy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of upgrade policies for the control plane.
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesGet(clusterId: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesGet(clusterId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new upgrade policy to the control plane of the cluster.
         * @param {string} clusterId 
         * @param {ControlPlaneUpgradePolicy} [controlPlaneUpgradePolicy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesPost(clusterId: string, controlPlaneUpgradePolicy?: ControlPlaneUpgradePolicy, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ControlPlaneUpgradePolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesPost(clusterId, controlPlaneUpgradePolicy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the credentials of a cluster.
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdCredentialsGet(clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdCredentialsGet(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the cluster.
         * @param {string} clusterId 
         * @param {boolean} [deprovision] If false it will only delete from OCM but not the actual cluster resources. false is only allowed for OCP clusters. true by default.
         * @param {boolean} [dryRun] Dry run flag is used to check if the operation can be completed, but won\&#39;t delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdDelete(clusterId: string, deprovision?: boolean, dryRun?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdDelete(clusterId, deprovision, dryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdDeleteProtectionGet(clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteProtection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdDeleteProtectionGet(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {DeleteProtection} [deleteProtection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdDeleteProtectionPatch(clusterId: string, deleteProtection?: DeleteProtection, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteProtection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdDeleteProtectionPatch(clusterId, deleteProtection, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the external configuration.
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdExternalConfigurationGet(clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExternalConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdExternalConfigurationGet(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of labels.
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsGet(clusterId: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsGet(clusterId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the label.
         * @param {string} clusterId 
         * @param {string} labelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdDelete(clusterId: string, labelId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdDelete(clusterId, labelId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the label.
         * @param {string} clusterId 
         * @param {string} labelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdGet(clusterId: string, labelId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Label>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdGet(clusterId, labelId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the label.
         * @param {string} clusterId 
         * @param {string} labelId 
         * @param {Label} [label] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdPatch(clusterId: string, labelId: string, label?: Label, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Label>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdPatch(clusterId, labelId, label, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new label to the cluster.
         * @param {string} clusterId 
         * @param {Label} [label] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsPost(clusterId: string, label?: Label, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Label>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsPost(clusterId, label, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of manifests.
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsGet(clusterId: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsGet(clusterId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the manifest.
         * @param {string} clusterId 
         * @param {string} manifestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdDelete(clusterId: string, manifestId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdDelete(clusterId, manifestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the manifest.
         * @param {string} clusterId 
         * @param {string} manifestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdGet(clusterId: string, manifestId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Manifest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdGet(clusterId, manifestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the manifest.
         * @param {string} clusterId 
         * @param {string} manifestId 
         * @param {Manifest} [manifest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdPatch(clusterId: string, manifestId: string, manifest?: Manifest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Manifest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdPatch(clusterId, manifestId, manifest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new manifest to a cluster.
         * @param {string} clusterId 
         * @param {Manifest} [manifest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsPost(clusterId: string, manifest?: Manifest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Manifest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsPost(clusterId, manifest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of syncsets.
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsGet(clusterId: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsGet(clusterId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new syncset to the cluster.
         * @param {string} clusterId 
         * @param {Syncset} [syncset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsPost(clusterId: string, syncset?: Syncset, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Syncset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsPost(clusterId, syncset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the syncset.
         * @param {string} clusterId 
         * @param {string} syncsetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdDelete(clusterId: string, syncsetId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdDelete(clusterId, syncsetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the syncset.
         * @param {string} clusterId 
         * @param {string} syncsetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdGet(clusterId: string, syncsetId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Syncset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdGet(clusterId, syncsetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the syncset.
         * @param {string} clusterId 
         * @param {string} syncsetId 
         * @param {Syncset} [syncset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdPatch(clusterId: string, syncsetId: string, syncset?: Syncset, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Syncset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdPatch(clusterId, syncsetId, syncset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of reasons.
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdGateAgreementsGet(clusterId: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1ClustersClusterIdGateAgreementsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdGateAgreementsGet(clusterId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new agreed version gate to the cluster.
         * @param {string} clusterId 
         * @param {VersionGateAgreement} [versionGateAgreement] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdGateAgreementsPost(clusterId: string, versionGateAgreement?: VersionGateAgreement, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VersionGateAgreement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdGateAgreementsPost(clusterId, versionGateAgreement, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the version gate agreement.
         * @param {string} clusterId 
         * @param {string} versionGateAgreementId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdDelete(clusterId: string, versionGateAgreementId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdDelete(clusterId, versionGateAgreementId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the version gate agreement.
         * @param {string} clusterId 
         * @param {string} versionGateAgreementId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdGet(clusterId: string, versionGateAgreementId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VersionGateAgreement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdGet(clusterId, versionGateAgreementId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the cluster.
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdGet(clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cluster>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdGet(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of groups.
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdGroupsGet(clusterId: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1ClustersClusterIdGroupsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdGroupsGet(clusterId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the group.
         * @param {string} clusterId 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdGroupsGroupIdGet(clusterId: string, groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdGroupsGroupIdGet(clusterId, groupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of users.
         * @param {string} clusterId 
         * @param {string} groupId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersGet(clusterId: string, groupId: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersGet(clusterId, groupId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new user to the group.
         * @param {string} clusterId 
         * @param {string} groupId 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersPost(clusterId: string, groupId: string, user?: User, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersPost(clusterId, groupId, user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the user.
         * @param {string} clusterId 
         * @param {string} groupId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdDelete(clusterId: string, groupId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdDelete(clusterId, groupId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the user.
         * @param {string} clusterId 
         * @param {string} groupId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdGet(clusterId: string, groupId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdGet(clusterId, groupId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Initiates cluster hibernation. While hibernating a cluster will not consume any cloud provider infrastructure but will be counted for quota.
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdHibernatePost(clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdHibernatePost(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the Hypershift details for a single cluster.
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdHypershiftGet(clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HypershiftConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdHypershiftGet(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of identity providers.
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdIdentityProvidersGet(clusterId: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1ClustersClusterIdIdentityProvidersGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdIdentityProvidersGet(clusterId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the identity provider.
         * @param {string} clusterId 
         * @param {string} identityProviderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdDelete(clusterId: string, identityProviderId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdDelete(clusterId, identityProviderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the identity provider.
         * @param {string} clusterId 
         * @param {string} identityProviderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdGet(clusterId: string, identityProviderId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityProvider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdGet(clusterId, identityProviderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of _HTPasswd_ IDP users.
         * @param {string} clusterId 
         * @param {string} identityProviderId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersGet(clusterId: string, identityProviderId: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersGet(clusterId, identityProviderId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the user.
         * @param {string} clusterId 
         * @param {string} identityProviderId 
         * @param {string} htpasswdUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdDelete(clusterId: string, identityProviderId: string, htpasswdUserId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdDelete(clusterId, identityProviderId, htpasswdUserId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the user.
         * @param {string} clusterId 
         * @param {string} identityProviderId 
         * @param {string} htpasswdUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdGet(clusterId: string, identityProviderId: string, htpasswdUserId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HTPasswdUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdGet(clusterId, identityProviderId, htpasswdUserId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the user\'s password. The username is not editable
         * @param {string} clusterId 
         * @param {string} identityProviderId 
         * @param {string} htpasswdUserId 
         * @param {HTPasswdUser} [hTPasswdUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdPatch(clusterId: string, identityProviderId: string, htpasswdUserId: string, hTPasswdUser?: HTPasswdUser, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HTPasswdUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdPatch(clusterId, identityProviderId, htpasswdUserId, hTPasswdUser, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds multiple new users to the _HTPasswd_ file.
         * @param {string} clusterId 
         * @param {string} identityProviderId 
         * @param {ApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersImportPostRequest} [apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersImportPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersImportPost(clusterId: string, identityProviderId: string, apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersImportPostRequest?: ApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersImportPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersImportPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersImportPost(clusterId, identityProviderId, apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersImportPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new user to the _HTPasswd_ file.
         * @param {string} clusterId 
         * @param {string} identityProviderId 
         * @param {HTPasswdUser} [hTPasswdUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersPost(clusterId: string, identityProviderId: string, hTPasswdUser?: HTPasswdUser, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HTPasswdUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersPost(clusterId, identityProviderId, hTPasswdUser, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update identity provider in the cluster.
         * @param {string} clusterId 
         * @param {string} identityProviderId 
         * @param {IdentityProvider} [identityProvider] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdPatch(clusterId: string, identityProviderId: string, identityProvider?: IdentityProvider, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityProvider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdPatch(clusterId, identityProviderId, identityProvider, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new identity provider to the cluster.
         * @param {string} clusterId 
         * @param {IdentityProvider} [identityProvider] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdIdentityProvidersPost(clusterId: string, identityProvider?: IdentityProvider, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityProvider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdIdentityProvidersPost(clusterId, identityProvider, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of inflight checks.
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdInflightChecksGet(clusterId: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1ClustersClusterIdInflightChecksGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdInflightChecksGet(clusterId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the inflight check.
         * @param {string} clusterId 
         * @param {string} inflightCheckId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdInflightChecksInflightCheckIdGet(clusterId: string, inflightCheckId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InflightCheck>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdInflightChecksInflightCheckIdGet(clusterId, inflightCheckId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of ingresses.
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdIngressesGet(clusterId: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1ClustersClusterIdIngressesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdIngressesGet(clusterId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the ingress.
         * @param {string} clusterId 
         * @param {string} ingressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdIngressesIngressIdDelete(clusterId: string, ingressId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdIngressesIngressIdDelete(clusterId, ingressId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the ingress.
         * @param {string} clusterId 
         * @param {string} ingressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdIngressesIngressIdGet(clusterId: string, ingressId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ingress>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdIngressesIngressIdGet(clusterId, ingressId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the ingress.
         * @param {string} clusterId 
         * @param {string} ingressId 
         * @param {Ingress} [ingress] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdIngressesIngressIdPatch(clusterId: string, ingressId: string, ingress?: Ingress, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ingress>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdIngressesIngressIdPatch(clusterId, ingressId, ingress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates all ingresses
         * @param {string} clusterId 
         * @param {Array<Ingress>} [ingress] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdIngressesPatch(clusterId: string, ingress?: Array<Ingress>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Ingress>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdIngressesPatch(clusterId, ingress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new ingress to the cluster.
         * @param {string} clusterId 
         * @param {Ingress} [ingress] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdIngressesPost(clusterId: string, ingress?: Ingress, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ingress>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdIngressesPost(clusterId, ingress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of reasons.
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsGet(clusterId: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsGet(clusterId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the reason.
         * @param {string} clusterId 
         * @param {string} limitedSupportReasonId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdDelete(clusterId: string, limitedSupportReasonId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdDelete(clusterId, limitedSupportReasonId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the reason.
         * @param {string} clusterId 
         * @param {string} limitedSupportReasonId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdGet(clusterId: string, limitedSupportReasonId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LimitedSupportReason>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdGet(clusterId, limitedSupportReasonId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new reason to the cluster.
         * @param {string} clusterId 
         * @param {LimitedSupportReason} [limitedSupportReason] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsPost(clusterId: string, limitedSupportReason?: LimitedSupportReason, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LimitedSupportReason>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsPost(clusterId, limitedSupportReason, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of log links.
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdLogsGet(clusterId: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1ClustersClusterIdLogsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdLogsGet(clusterId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the log.
         * @param {string} clusterId 
         * @param {number} [offset] Line offset to start logs from. if 0 retreive entire log. If offset &gt; #lines return an empty log.
         * @param {number} [tail] Returns the number of tail lines from the end of the log. If there are no line breaks or the number of lines &lt; tail return the entire log. Either \&#39;tail\&#39; or \&#39;offset\&#39; can be set. Not both. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdLogsInstallGet(clusterId: string, offset?: number, tail?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Log>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdLogsInstallGet(clusterId, offset, tail, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the log.
         * @param {string} clusterId 
         * @param {number} [offset] Line offset to start logs from. if 0 retreive entire log. If offset &gt; #lines return an empty log.
         * @param {number} [tail] Returns the number of tail lines from the end of the log. If there are no line breaks or the number of lines &lt; tail return the entire log. Either \&#39;tail\&#39; or \&#39;offset\&#39; can be set. Not both. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdLogsUninstallGet(clusterId: string, offset?: number, tail?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Log>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdLogsUninstallGet(clusterId, offset, tail, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of machine pools.
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdMachinePoolsGet(clusterId: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1ClustersClusterIdMachinePoolsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdMachinePoolsGet(clusterId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the machine pool.
         * @param {string} clusterId 
         * @param {string} machinePoolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdDelete(clusterId: string, machinePoolId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdDelete(clusterId, machinePoolId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the machine pool.
         * @param {string} clusterId 
         * @param {string} machinePoolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdGet(clusterId: string, machinePoolId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MachinePool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdGet(clusterId, machinePoolId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the machine pool.
         * @param {string} clusterId 
         * @param {string} machinePoolId 
         * @param {MachinePool} [machinePool] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdPatch(clusterId: string, machinePoolId: string, machinePool?: MachinePool, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MachinePool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdPatch(clusterId, machinePoolId, machinePool, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new machine pool to the cluster.
         * @param {string} clusterId 
         * @param {MachinePool} [machinePool] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdMachinePoolsPost(clusterId: string, machinePool?: MachinePool, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MachinePool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdMachinePoolsPost(clusterId, machinePool, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdMetricQueriesAlertsGet(clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertsInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdMetricQueriesAlertsGet(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdMetricQueriesClusterOperatorsGet(clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterOperatorsInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdMetricQueriesClusterOperatorsGet(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the metrics.
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdMetricQueriesCpuTotalByNodeRolesOsGet(clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CPUTotalsNodeRoleOSMetricNode>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdMetricQueriesCpuTotalByNodeRolesOsGet(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdMetricQueriesNodesGet(clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NodesInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdMetricQueriesNodesGet(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the metrics.
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdMetricQueriesSocketTotalByNodeRolesOsGet(clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SocketTotalsNodeRoleOSMetricNode>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdMetricQueriesSocketTotalByNodeRolesOsGet(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of node pools.
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdNodePoolsGet(clusterId: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1ClustersClusterIdNodePoolsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdNodePoolsGet(clusterId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the node pool.
         * @param {string} clusterId 
         * @param {string} nodePoolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdDelete(clusterId: string, nodePoolId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdDelete(clusterId, nodePoolId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the node pool.
         * @param {string} clusterId 
         * @param {string} nodePoolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdGet(clusterId: string, nodePoolId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NodePool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdGet(clusterId, nodePoolId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the node pool.
         * @param {string} clusterId 
         * @param {string} nodePoolId 
         * @param {NodePool} [nodePool] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdPatch(clusterId: string, nodePoolId: string, nodePool?: NodePool, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NodePool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdPatch(clusterId, nodePoolId, nodePool, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of upgrade policies for the node pool.
         * @param {string} clusterId 
         * @param {string} nodePoolId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesGet(clusterId: string, nodePoolId: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesGet(clusterId, nodePoolId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the upgrade policy for the node pool.
         * @param {string} clusterId 
         * @param {string} nodePoolId 
         * @param {string} nodePoolUpgradePolicyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdDelete(clusterId: string, nodePoolId: string, nodePoolUpgradePolicyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdDelete(clusterId, nodePoolId, nodePoolUpgradePolicyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the upgrade policy for the node pool.
         * @param {string} clusterId 
         * @param {string} nodePoolId 
         * @param {string} nodePoolUpgradePolicyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdGet(clusterId: string, nodePoolId: string, nodePoolUpgradePolicyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NodePoolUpgradePolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdGet(clusterId, nodePoolId, nodePoolUpgradePolicyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the upgrade policy for the node pool.
         * @param {string} clusterId 
         * @param {string} nodePoolId 
         * @param {string} nodePoolUpgradePolicyId 
         * @param {NodePoolUpgradePolicy} [nodePoolUpgradePolicy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdPatch(clusterId: string, nodePoolId: string, nodePoolUpgradePolicyId: string, nodePoolUpgradePolicy?: NodePoolUpgradePolicy, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NodePoolUpgradePolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdPatch(clusterId, nodePoolId, nodePoolUpgradePolicyId, nodePoolUpgradePolicy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new upgrade policy to the node pool of the cluster.
         * @param {string} clusterId 
         * @param {string} nodePoolId 
         * @param {NodePoolUpgradePolicy} [nodePoolUpgradePolicy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesPost(clusterId: string, nodePoolId: string, nodePoolUpgradePolicy?: NodePoolUpgradePolicy, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NodePoolUpgradePolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesPost(clusterId, nodePoolId, nodePoolUpgradePolicy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new node pool to the cluster.
         * @param {string} clusterId 
         * @param {NodePool} [nodePool] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdNodePoolsPost(clusterId: string, nodePool?: NodePool, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NodePool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdNodePoolsPost(clusterId, nodePool, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the cluster.
         * @param {string} clusterId 
         * @param {Cluster} [cluster] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdPatch(clusterId: string, cluster?: Cluster, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cluster>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdPatch(clusterId, cluster, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the product.
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdProductGet(clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdProductGet(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete the provision shard.
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdProvisionShardDelete(clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdProvisionShardDelete(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the provision shard.
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdProvisionShardGet(clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvisionShard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdProvisionShardGet(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the details of the provision shard.
         * @param {string} clusterId 
         * @param {ProvisionShard} [provisionShard] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdProvisionShardPatch(clusterId: string, provisionShard?: ProvisionShard, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvisionShard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdProvisionShardPatch(clusterId, provisionShard, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a list of resources for a cluster in error state
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdResourcesGet(clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterResources>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdResourcesGet(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves currently available cluster resources
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdResourcesLiveGet(clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterResources>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdResourcesLiveGet(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Resumes from Hibernation.
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdResumePost(clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdResumePost(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdStatusGet(clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdStatusGet(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of operator roles.
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdStsOperatorRolesGet(clusterId: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1ClustersClusterIdStsOperatorRolesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdStsOperatorRolesGet(clusterId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the operator role.
         * @param {string} clusterId 
         * @param {string} operatorIamRoleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdStsOperatorRolesOperatorIamRoleIdDelete(clusterId: string, operatorIamRoleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdStsOperatorRolesOperatorIamRoleIdDelete(clusterId, operatorIamRoleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new operator role to the cluster.
         * @param {string} clusterId 
         * @param {OperatorIAMRole} [operatorIAMRole] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdStsOperatorRolesPost(clusterId: string, operatorIAMRole?: OperatorIAMRole, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperatorIAMRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdStsOperatorRolesPost(clusterId, operatorIAMRole, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdStsSupportJumpRoleGet(clusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StsSupportJumpRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdStsSupportJumpRoleGet(clusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of tuning configs.
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdTuningConfigsGet(clusterId: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1ClustersClusterIdTuningConfigsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdTuningConfigsGet(clusterId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new tuning config to the cluster.
         * @param {string} clusterId 
         * @param {TuningConfig} [tuningConfig] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdTuningConfigsPost(clusterId: string, tuningConfig?: TuningConfig, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TuningConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdTuningConfigsPost(clusterId, tuningConfig, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the tuning config.
         * @param {string} clusterId 
         * @param {string} tuningConfigId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdDelete(clusterId: string, tuningConfigId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdDelete(clusterId, tuningConfigId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the tuning config.
         * @param {string} clusterId 
         * @param {string} tuningConfigId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdGet(clusterId: string, tuningConfigId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TuningConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdGet(clusterId, tuningConfigId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the tuning config.
         * @param {string} clusterId 
         * @param {string} tuningConfigId 
         * @param {TuningConfig} [tuningConfig] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdPatch(clusterId: string, tuningConfigId: string, tuningConfig?: TuningConfig, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TuningConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdPatch(clusterId, tuningConfigId, tuningConfig, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of upgrade policies.
         * @param {string} clusterId 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdUpgradePoliciesGet(clusterId: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1ClustersClusterIdUpgradePoliciesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdUpgradePoliciesGet(clusterId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new upgrade policy to the cluster.
         * @param {string} clusterId 
         * @param {UpgradePolicy} [upgradePolicy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdUpgradePoliciesPost(clusterId: string, upgradePolicy?: UpgradePolicy, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpgradePolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdUpgradePoliciesPost(clusterId, upgradePolicy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the upgrade policy.
         * @param {string} clusterId 
         * @param {string} upgradePolicyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdDelete(clusterId: string, upgradePolicyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdDelete(clusterId, upgradePolicyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the upgrade policy.
         * @param {string} clusterId 
         * @param {string} upgradePolicyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdGet(clusterId: string, upgradePolicyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpgradePolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdGet(clusterId, upgradePolicyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the upgrade policy.
         * @param {string} clusterId 
         * @param {string} upgradePolicyId 
         * @param {UpgradePolicy} [upgradePolicy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdPatch(clusterId: string, upgradePolicyId: string, upgradePolicy?: UpgradePolicy, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpgradePolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdPatch(clusterId, upgradePolicyId, upgradePolicy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the upgrade policy state.
         * @param {string} clusterId 
         * @param {string} upgradePolicyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStateGet(clusterId: string, upgradePolicyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpgradePolicyState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStateGet(clusterId, upgradePolicyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the upgrade policy state.
         * @param {string} clusterId 
         * @param {string} upgradePolicyId 
         * @param {UpgradePolicyState} [upgradePolicyState] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStatePatch(clusterId: string, upgradePolicyId: string, upgradePolicyState?: UpgradePolicyState, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpgradePolicyState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStatePatch(clusterId, upgradePolicyId, upgradePolicyState, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of clusters.
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the cluster instead of the names of the columns of a table. For example, in order to sort the clusters descending by region identifier the value should be:  &#x60;&#x60;&#x60;sql region.id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the cluster instead of the names of the columns of a table. For example, in order to retrieve all the clusters with a name starting with &#x60;my&#x60; in the &#x60;us-east-1&#x60; region the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; and region.id &#x3D; \&#39;us-east-1\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the clusters that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersGet(order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1ClustersGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersGet(order, page, search, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Provision a new cluster and add it to the collection of clusters.  See the `register_cluster` method for adding an existing cluster.
         * @param {Cluster} [cluster] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ClustersPost(cluster?: Cluster, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cluster>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ClustersPost(cluster, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete the DNS domain.
         * @param {string} dnsDomainId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1DnsDomainsDnsDomainIdDelete(dnsDomainId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1DnsDomainsDnsDomainIdDelete(dnsDomainId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the DNS domain.
         * @param {string} dnsDomainId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1DnsDomainsDnsDomainIdGet(dnsDomainId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DNSDomain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1DnsDomainsDnsDomainIdGet(dnsDomainId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the details of the DNS domain.
         * @param {string} dnsDomainId 
         * @param {DNSDomain} [dNSDomain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1DnsDomainsDnsDomainIdPatch(dnsDomainId: string, dNSDomain?: DNSDomain, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DNSDomain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1DnsDomainsDnsDomainIdPatch(dnsDomainId, dNSDomain, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the dns domain instead of the names of the columns of a table. For example, in order to retrieve all the dns domains with a ID starting with &#x60;02a5&#x60; should be:  &#x60;&#x60;&#x60;sql id like \&#39;02a5%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the dns domains that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1DnsDomainsGet(page?: number, search?: string, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1DnsDomainsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1DnsDomainsGet(page, search, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a DNS domain.
         * @param {DNSDomain} [dNSDomain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1DnsDomainsPost(dNSDomain?: DNSDomain, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DNSDomain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1DnsDomainsPost(dNSDomain, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the environment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1EnvironmentGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Environment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1EnvironmentGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the environment.  Attributes that can be updated are:  - `last_upgrade_available_check` - `last_limited_support_check`
         * @param {Environment} [environment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1EnvironmentPatch(environment?: Environment, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Environment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1EnvironmentPatch(environment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new event to be tracked. When sending a new event request, it gets tracked in Prometheus, Pendo, CloudWatch, or whichever analytics client is configured as part of clusters service. This allows for reporting on events that happen outside of a regular API request, but are found to be useful for understanding customer needs and possible blockers.
         * @param {Event} [event] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1EventsPost(event?: Event, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1EventsPost(event, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the cluster flavour.
         * @param {string} flavourId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1FlavoursFlavourIdGet(flavourId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Flavour>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1FlavoursFlavourIdGet(flavourId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the flavour.  Attributes that can be updated are:  - `aws.infra_volume` - `aws.infra_instance_type` - `gcp.infra_instance_type`
         * @param {string} flavourId 
         * @param {Flavour} [flavour] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1FlavoursFlavourIdPatch(flavourId: string, flavour?: Flavour, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Flavour>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1FlavoursFlavourIdPatch(flavourId, flavour, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the flavour instead of the names of the columns of a table. For example, in order to sort the flavours descending by name the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the flavour instead of the names of the columns of a table. For example, in order to retrieve all the flavours with a name starting with &#x60;my&#x60;the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the flavours that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1FlavoursGet(order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1FlavoursGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1FlavoursGet(order, page, search, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new cluster flavour.
         * @param {Flavour} [flavour] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1FlavoursPost(flavour?: Flavour, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Flavour>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1FlavoursPost(flavour, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of encryption keys. IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider.
         * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
         * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider.
         * @param {CloudProviderData} [cloudProviderData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1GcpInquiriesEncryptionKeysPost(page?: number, size?: number, cloudProviderData?: CloudProviderData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1GcpInquiriesEncryptionKeysPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1GcpInquiriesEncryptionKeysPost(page, size, cloudProviderData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of available key rings of the cloud provider. IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider.
         * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
         * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of key rings of the provider.
         * @param {CloudProviderData} [cloudProviderData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1GcpInquiriesKeyRingsPost(page?: number, size?: number, cloudProviderData?: CloudProviderData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1GcpInquiriesKeyRingsPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1GcpInquiriesKeyRingsPost(page, size, cloudProviderData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of available regions of the cloud provider. IMPORTANT: This list doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider.
         * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
         * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider.
         * @param {CloudProviderData} [cloudProviderData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1GcpInquiriesRegionsPost(page?: number, size?: number, cloudProviderData?: CloudProviderData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1AwsInquiriesRegionsPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1GcpInquiriesRegionsPost(page, size, cloudProviderData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of available vpcs of the cloud provider for specific region. IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available vpcs of the provider.
         * @param {number} [page] Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
         * @param {number} [size] Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of vpcs of the provider.
         * @param {CloudProviderData} [cloudProviderData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1GcpInquiriesVpcsPost(page?: number, size?: number, cloudProviderData?: CloudProviderData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1AwsInquiriesVpcsPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1GcpInquiriesVpcsPost(page, size, cloudProviderData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the version metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1Get(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Metadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1Get(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of templates.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1LimitedSupportReasonTemplatesGet(page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1LimitedSupportReasonTemplatesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1LimitedSupportReasonTemplatesGet(page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the template.
         * @param {string} limitedSupportReasonTemplateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1LimitedSupportReasonTemplatesLimitedSupportReasonTemplateIdGet(limitedSupportReasonTemplateId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LimitedSupportReasonTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1LimitedSupportReasonTemplatesLimitedSupportReasonTemplateIdGet(limitedSupportReasonTemplateId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of machine types.
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the machine type instead of the names of the columns of a table. For example, in order to sort the machine types descending by name identifier the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the machine type instead of the names of the columns of a table. For example, in order to retrieve all the machine types with a name starting with &#x60;A&#x60; the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;A%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the machine types that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1MachineTypesGet(order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1MachineTypesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1MachineTypesGet(order, page, search, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the machine type.
         * @param {string} machineTypeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1MachineTypesMachineTypeIdGet(machineTypeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MachineType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1MachineTypesMachineTypeIdGet(machineTypeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of a subnet network verification.
         * @param {string} networkVerificationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1NetworkVerificationsNetworkVerificationIdGet(networkVerificationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubnetNetworkVerification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1NetworkVerificationsNetworkVerificationIdGet(networkVerificationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates an entry for a network verification for each subnet supplied setting then to initial state.
         * @param {NetworkVerification} [networkVerification] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1NetworkVerificationsPost(networkVerification?: NetworkVerification, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkVerification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1NetworkVerificationsPost(networkVerification, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of oidc configs.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1OidcConfigsGet(page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1OidcConfigsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1OidcConfigsGet(page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the OidcConfig.
         * @param {string} oidcConfigId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1OidcConfigsOidcConfigIdDelete(oidcConfigId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1OidcConfigsOidcConfigIdDelete(oidcConfigId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of an OidcConfig.
         * @param {string} oidcConfigId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1OidcConfigsOidcConfigIdGet(oidcConfigId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OidcConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1OidcConfigsOidcConfigIdGet(oidcConfigId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates attributes of an OidcConfig.
         * @param {string} oidcConfigId 
         * @param {OidcConfig} [oidcConfig] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1OidcConfigsOidcConfigIdPatch(oidcConfigId: string, oidcConfig?: OidcConfig, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OidcConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1OidcConfigsOidcConfigIdPatch(oidcConfigId, oidcConfig, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a hosting under Red Hat\'s S3 bucket for byo oidc configuration.
         * @param {OidcConfig} [oidcConfig] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1OidcConfigsPost(oidcConfig?: OidcConfig, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OidcConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1OidcConfigsPost(oidcConfig, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of pending delete clusters.
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the pending delete cluster instead of the names of the columns of a table. For example, in order to sort the pending delete clusters descending by creation timestamp (i.e. their deletion time) the value should be:  &#x60;&#x60;&#x60;sql creation_timestamp desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the pending delete cluster instead of the names of the columns of a table. For example, in order to retrieve all the pending delete clusters with creation time later than 2023-03-01T00:00:00Z the following is required:  &#x60;&#x60;&#x60;sql creation_timestamp &gt; \&#39;2023-03-01T00:00:00Z\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the pending delete clusters that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1PendingDeleteClustersGet(order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1PendingDeleteClustersGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1PendingDeleteClustersGet(order, page, search, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the pending delete cluster.
         * @param {string} pendingDeleteClusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1PendingDeleteClustersPendingDeleteClusterIdGet(pendingDeleteClusterId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PendingDeleteCluster>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1PendingDeleteClustersPendingDeleteClusterIdGet(pendingDeleteClusterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the pending delete cluster entry.
         * @param {string} pendingDeleteClusterId 
         * @param {PendingDeleteCluster} [pendingDeleteCluster] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1PendingDeleteClustersPendingDeleteClusterIdPatch(pendingDeleteClusterId: string, pendingDeleteCluster?: PendingDeleteCluster, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PendingDeleteCluster>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1PendingDeleteClustersPendingDeleteClusterIdPatch(pendingDeleteClusterId, pendingDeleteCluster, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of products.
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the product instead of the names of the columns of a table. For example, in order to sort the products descending by name the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the product instead of the names of the columns of a table. For example, in order to retrieve all the products with a name starting with &#x60;my&#x60; the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the products that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ProductsGet(order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1ProductsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ProductsGet(order, page, search, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the product.
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ProductsProductIdGet(productId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ProductsProductIdGet(productId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the cluster instead of the names of the columns of a table. For example, in order to retrieve all the clusters with a name starting with &#x60;my&#x60; in the &#x60;us-east-1&#x60; region the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; and region.id &#x3D; \&#39;us-east-1\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the provision shards that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ProvisionShardsGet(page?: number, search?: string, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1ProvisionShardsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ProvisionShardsGet(page, search, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a provision shard.
         * @param {ProvisionShard} [provisionShard] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ProvisionShardsPost(provisionShard?: ProvisionShard, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvisionShard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ProvisionShardsPost(provisionShard, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete the provision shard.
         * @param {string} provisionShardId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ProvisionShardsProvisionShardIdDelete(provisionShardId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ProvisionShardsProvisionShardIdDelete(provisionShardId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the provision shard.
         * @param {string} provisionShardId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ProvisionShardsProvisionShardIdGet(provisionShardId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvisionShard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ProvisionShardsProvisionShardIdGet(provisionShardId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the details of the provision shard.
         * @param {string} provisionShardId 
         * @param {ProvisionShard} [provisionShard] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1ProvisionShardsProvisionShardIdPatch(provisionShardId: string, provisionShard?: ProvisionShard, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvisionShard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1ProvisionShardsProvisionShardIdPatch(provisionShardId, provisionShard, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of trusted ip addresses.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {number} [size] Number of items contained in the returned page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1TrustedIpAddressesGet(page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1TrustedIpAddressesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1TrustedIpAddressesGet(page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the trusted ip adresses.
         * @param {string} trustedIpId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1TrustedIpAddressesTrustedIpIdGet(trustedIpId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrustedIp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1TrustedIpAddressesTrustedIpIdGet(trustedIpId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a list of version gates.
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of an SQL statement, but using the names of the attributes of the version gate instead of the names of the columns of a table. For example, in order to sort the version gates descending by identifier the value should be:  &#x60;&#x60;&#x60;sql id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the version gate instead of the names of the columns of a table.  If the parameter isn\&#39;t provided, or if the value is empty, then all the version gates that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.  Default value is &#x60;100&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1VersionGatesGet(order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1VersionGatesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1VersionGatesGet(order, page, search, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new version gate
         * @param {VersionGate} [versionGate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1VersionGatesPost(versionGate?: VersionGate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VersionGate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1VersionGatesPost(versionGate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the version gate.
         * @param {string} versionGateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1VersionGatesVersionGateIdDelete(versionGateId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1VersionGatesVersionGateIdDelete(versionGateId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the version gate.
         * @param {string} versionGateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1VersionGatesVersionGateIdGet(versionGateId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VersionGate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1VersionGatesVersionGateIdGet(versionGateId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a list of versions.
         * @param {string} [order] Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the version instead of the names of the columns of a table. For example, in order to sort the versions descending by identifier the value should be:  &#x60;&#x60;&#x60;sql id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
         * @param {number} [page] Index of the requested page, where one corresponds to the first page.
         * @param {string} [search] Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the version instead of the names of the columns of a table. For example, in order to retrieve all the versions that are enabled:  &#x60;&#x60;&#x60;sql enabled &#x3D; \&#39;t\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the versions that the user has permission to see will be returned.
         * @param {number} [size] Maximum number of items that will be contained in the returned page.  Default value is &#x60;100&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1VersionsGet(order?: string, page?: number, search?: string, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClustersMgmtV1VersionsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1VersionsGet(order, page, search, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of the version.
         * @param {string} versionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClustersMgmtV1VersionsVersionIdGet(versionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Version>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiClustersMgmtV1VersionsVersionIdGet(versionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Deletes the add-on.
         * @param {DefaultApiApiClustersMgmtV1AddonsAddonIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsAddonIdDelete(requestParameters: DefaultApiApiClustersMgmtV1AddonsAddonIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1AddonsAddonIdDelete(requestParameters.addonId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the add-on.
         * @param {DefaultApiApiClustersMgmtV1AddonsAddonIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsAddonIdGet(requestParameters: DefaultApiApiClustersMgmtV1AddonsAddonIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<AddOn> {
            return localVarFp.apiClustersMgmtV1AddonsAddonIdGet(requestParameters.addonId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the add-on.
         * @param {DefaultApiApiClustersMgmtV1AddonsAddonIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsAddonIdPatch(requestParameters: DefaultApiApiClustersMgmtV1AddonsAddonIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<AddOn> {
            return localVarFp.apiClustersMgmtV1AddonsAddonIdPatch(requestParameters.addonId, requestParameters.addOn, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of add-on versions.
         * @param {DefaultApiApiClustersMgmtV1AddonsAddonIdVersionsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsAddonIdVersionsGet(requestParameters: DefaultApiApiClustersMgmtV1AddonsAddonIdVersionsGetRequest, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1AddonsAddonIdVersionsGet200Response> {
            return localVarFp.apiClustersMgmtV1AddonsAddonIdVersionsGet(requestParameters.addonId, requestParameters.order, requestParameters.page, requestParameters.search, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new add-on version and add it to the collection of add-ons.
         * @param {DefaultApiApiClustersMgmtV1AddonsAddonIdVersionsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsAddonIdVersionsPost(requestParameters: DefaultApiApiClustersMgmtV1AddonsAddonIdVersionsPostRequest, options?: AxiosRequestConfig): AxiosPromise<AddOnVersion> {
            return localVarFp.apiClustersMgmtV1AddonsAddonIdVersionsPost(requestParameters.addonId, requestParameters.addOnVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the add-on version.
         * @param {DefaultApiApiClustersMgmtV1AddonsAddonIdVersionsVersionIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsAddonIdVersionsVersionIdDelete(requestParameters: DefaultApiApiClustersMgmtV1AddonsAddonIdVersionsVersionIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1AddonsAddonIdVersionsVersionIdDelete(requestParameters.addonId, requestParameters.versionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the add-on version.
         * @param {DefaultApiApiClustersMgmtV1AddonsAddonIdVersionsVersionIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsAddonIdVersionsVersionIdGet(requestParameters: DefaultApiApiClustersMgmtV1AddonsAddonIdVersionsVersionIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<AddOnVersion> {
            return localVarFp.apiClustersMgmtV1AddonsAddonIdVersionsVersionIdGet(requestParameters.addonId, requestParameters.versionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the add-on version.
         * @param {DefaultApiApiClustersMgmtV1AddonsAddonIdVersionsVersionIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsAddonIdVersionsVersionIdPatch(requestParameters: DefaultApiApiClustersMgmtV1AddonsAddonIdVersionsVersionIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<AddOnVersion> {
            return localVarFp.apiClustersMgmtV1AddonsAddonIdVersionsVersionIdPatch(requestParameters.addonId, requestParameters.versionId, requestParameters.addOnVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of add-ons.
         * @param {DefaultApiApiClustersMgmtV1AddonsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsGet(requestParameters: DefaultApiApiClustersMgmtV1AddonsGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1AddonsGet200Response> {
            return localVarFp.apiClustersMgmtV1AddonsGet(requestParameters.order, requestParameters.page, requestParameters.search, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new add-on and add it to the collection of add-ons.
         * @param {DefaultApiApiClustersMgmtV1AddonsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AddonsPost(requestParameters: DefaultApiApiClustersMgmtV1AddonsPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<AddOn> {
            return localVarFp.apiClustersMgmtV1AddonsPost(requestParameters.addOn, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the aws infrastructure access role.
         * @param {DefaultApiApiClustersMgmtV1AwsInfrastructureAccessRolesAwsInfrastructureAccessRoleIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AwsInfrastructureAccessRolesAwsInfrastructureAccessRoleIdGet(requestParameters: DefaultApiApiClustersMgmtV1AwsInfrastructureAccessRolesAwsInfrastructureAccessRoleIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<AWSInfrastructureAccessRole> {
            return localVarFp.apiClustersMgmtV1AwsInfrastructureAccessRolesAwsInfrastructureAccessRoleIdGet(requestParameters.awsInfrastructureAccessRoleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DefaultApiApiClustersMgmtV1AwsInfrastructureAccessRolesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AwsInfrastructureAccessRolesGet(requestParameters: DefaultApiApiClustersMgmtV1AwsInfrastructureAccessRolesGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1AwsInfrastructureAccessRolesGet200Response> {
            return localVarFp.apiClustersMgmtV1AwsInfrastructureAccessRolesGet(requestParameters.order, requestParameters.page, requestParameters.search, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of machine types in the provided region.
         * @param {DefaultApiApiClustersMgmtV1AwsInquiriesMachineTypesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AwsInquiriesMachineTypesPost(requestParameters: DefaultApiApiClustersMgmtV1AwsInquiriesMachineTypesPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1AwsInquiriesMachineTypesPost200Response> {
            return localVarFp.apiClustersMgmtV1AwsInquiriesMachineTypesPost(requestParameters.page, requestParameters.size, requestParameters.cloudProviderData, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of available regions of the cloud provider. IMPORTANT: This list doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider.
         * @param {DefaultApiApiClustersMgmtV1AwsInquiriesRegionsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AwsInquiriesRegionsPost(requestParameters: DefaultApiApiClustersMgmtV1AwsInquiriesRegionsPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1AwsInquiriesRegionsPost200Response> {
            return localVarFp.apiClustersMgmtV1AwsInquiriesRegionsPost(requestParameters.page, requestParameters.size, requestParameters.cloudProviderData, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of policies.
         * @param {DefaultApiApiClustersMgmtV1AwsInquiriesStsCredentialRequestsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AwsInquiriesStsCredentialRequestsGet(requestParameters: DefaultApiApiClustersMgmtV1AwsInquiriesStsCredentialRequestsGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1AwsInquiriesStsCredentialRequestsGet200Response> {
            return localVarFp.apiClustersMgmtV1AwsInquiriesStsCredentialRequestsGet(requestParameters.page, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of policies.
         * @param {DefaultApiApiClustersMgmtV1AwsInquiriesStsPoliciesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AwsInquiriesStsPoliciesGet(requestParameters: DefaultApiApiClustersMgmtV1AwsInquiriesStsPoliciesGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1AwsInquiriesStsPoliciesGet200Response> {
            return localVarFp.apiClustersMgmtV1AwsInquiriesStsPoliciesGet(requestParameters.order, requestParameters.page, requestParameters.search, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of available vpcs of the cloud provider for specific region. IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available vpcs of the provider.
         * @param {DefaultApiApiClustersMgmtV1AwsInquiriesVpcsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1AwsInquiriesVpcsPost(requestParameters: DefaultApiApiClustersMgmtV1AwsInquiriesVpcsPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1AwsInquiriesVpcsPost200Response> {
            return localVarFp.apiClustersMgmtV1AwsInquiriesVpcsPost(requestParameters.page, requestParameters.size, requestParameters.cloudProviderData, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of available regions of the cloud provider.  IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider.
         * @param {DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdAvailableRegionsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1CloudProvidersCloudProviderIdAvailableRegionsPost(requestParameters: DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdAvailableRegionsPostRequest, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1CloudProvidersCloudProviderIdAvailableRegionsPost200Response> {
            return localVarFp.apiClustersMgmtV1CloudProvidersCloudProviderIdAvailableRegionsPost(requestParameters.cloudProviderId, requestParameters.page, requestParameters.size, requestParameters.aWS, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the cloud provider.
         * @param {DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1CloudProvidersCloudProviderIdGet(requestParameters: DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<CloudProvider> {
            return localVarFp.apiClustersMgmtV1CloudProvidersCloudProviderIdGet(requestParameters.cloudProviderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of regions of the cloud provider.  IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of regions of the provider.
         * @param {DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdRegionsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsGet(requestParameters: DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdRegionsGetRequest, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1CloudProvidersCloudProviderIdRegionsGet200Response> {
            return localVarFp.apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsGet(requestParameters.cloudProviderId, requestParameters.page, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a cloud region to the database.
         * @param {DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdRegionsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsPost(requestParameters: DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdRegionsPostRequest, options?: AxiosRequestConfig): AxiosPromise<CloudRegion> {
            return localVarFp.apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsPost(requestParameters.cloudProviderId, requestParameters.cloudRegion, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the region.
         * @param {DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdDelete(requestParameters: DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdDelete(requestParameters.cloudProviderId, requestParameters.regionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the region.
         * @param {DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdGet(requestParameters: DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<CloudRegion> {
            return localVarFp.apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdGet(requestParameters.cloudProviderId, requestParameters.regionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the region.
         * @param {DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdPatch(requestParameters: DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<CloudRegion> {
            return localVarFp.apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdPatch(requestParameters.cloudProviderId, requestParameters.regionId, requestParameters.cloudRegion, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of cloud providers.
         * @param {DefaultApiApiClustersMgmtV1CloudProvidersGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1CloudProvidersGet(requestParameters: DefaultApiApiClustersMgmtV1CloudProvidersGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1CloudProvidersGet200Response> {
            return localVarFp.apiClustersMgmtV1CloudProvidersGet(requestParameters.fetchRegions, requestParameters.order, requestParameters.page, requestParameters.search, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAddonInquiriesAddonInquiryIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonInquiriesAddonInquiryIdGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAddonInquiriesAddonInquiryIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<AddOn> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdAddonInquiriesAddonInquiryIdGet(requestParameters.clusterId, requestParameters.addonInquiryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAddonInquiriesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonInquiriesGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAddonInquiriesGetRequest, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1AddonsGet200Response> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdAddonInquiriesGet(requestParameters.clusterId, requestParameters.order, requestParameters.page, requestParameters.search, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the addon upgrade policy.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdDelete(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdDelete(requestParameters.clusterId, requestParameters.addonUpgradePolicyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the addon upgrade policy.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<AddonUpgradePolicy> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdGet(requestParameters.clusterId, requestParameters.addonUpgradePolicyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the addon upgrade policy.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdPatch(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<AddonUpgradePolicy> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdPatch(requestParameters.clusterId, requestParameters.addonUpgradePolicyId, requestParameters.addonUpgradePolicy, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the upgrade policy state.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdStateGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdStateGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdStateGetRequest, options?: AxiosRequestConfig): AxiosPromise<AddonUpgradePolicyState> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdStateGet(requestParameters.clusterId, requestParameters.addonUpgradePolicyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the upgrade policy state.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdStatePatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdStatePatch(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdStatePatchRequest, options?: AxiosRequestConfig): AxiosPromise<AddonUpgradePolicyState> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdStatePatch(requestParameters.clusterId, requestParameters.addonUpgradePolicyId, requestParameters.addonUpgradePolicyState, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of addon upgrade policies.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesGetRequest, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesGet200Response> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesGet(requestParameters.clusterId, requestParameters.page, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new addon upgrade policy to the cluster.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesPost(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesPostRequest, options?: AxiosRequestConfig): AxiosPromise<AddonUpgradePolicy> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesPost(requestParameters.clusterId, requestParameters.addonUpgradePolicy, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an add-on installation and remove it from the collection of add-on installations on the cluster.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdDelete(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdDelete(requestParameters.clusterId, requestParameters.addoninstallationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the add-on installation.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<AddOnInstallation> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdGet(requestParameters.clusterId, requestParameters.addoninstallationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the add-on installation.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdPatch(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<AddOnInstallation> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdPatch(requestParameters.clusterId, requestParameters.addoninstallationId, requestParameters.addOnInstallation, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of add-on installations.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAddonsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonsGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAddonsGetRequest, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1ClustersClusterIdAddonsGet200Response> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdAddonsGet(requestParameters.clusterId, requestParameters.order, requestParameters.page, requestParameters.search, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new add-on installation and add it to the collection of add-on installations on the cluster.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAddonsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAddonsPost(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAddonsPostRequest, options?: AxiosRequestConfig): AxiosPromise<AddOnInstallation> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdAddonsPost(requestParameters.clusterId, requestParameters.addOnInstallation, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the cluster autoscaler.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAutoscalerDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAutoscalerDelete(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAutoscalerDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdAutoscalerDelete(requestParameters.clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the autoscaler of a cluster.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAutoscalerGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAutoscalerGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAutoscalerGetRequest, options?: AxiosRequestConfig): AxiosPromise<ClusterAutoscaler> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdAutoscalerGet(requestParameters.clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the cluster autoscaler.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAutoscalerPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAutoscalerPatch(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAutoscalerPatchRequest, options?: AxiosRequestConfig): AxiosPromise<ClusterAutoscaler> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdAutoscalerPatch(requestParameters.clusterId, requestParameters.clusterAutoscaler, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new cluster autoscaler object.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAutoscalerPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAutoscalerPost(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAutoscalerPostRequest, options?: AxiosRequestConfig): AxiosPromise<ClusterAutoscaler> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdAutoscalerPost(requestParameters.clusterId, requestParameters.clusterAutoscaler, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the AWS infrastructure access role grant.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdDelete(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdDelete(requestParameters.clusterId, requestParameters.awsInfrastructureAccessRoleGrantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the AWS infrastructure access role grant.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<AWSInfrastructureAccessRoleGrant> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdGet(requestParameters.clusterId, requestParameters.awsInfrastructureAccessRoleGrantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of AWS infrastructure access role grants.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsGetRequest, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsGet200Response> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsGet(requestParameters.clusterId, requestParameters.order, requestParameters.page, requestParameters.search, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new AWS infrastructure access role grant and add it to the collection of AWS infrastructure access role grants on the cluster.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsPost(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsPostRequest, options?: AxiosRequestConfig): AxiosPromise<AWSInfrastructureAccessRoleGrant> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsPost(requestParameters.clusterId, requestParameters.aWSInfrastructureAccessRoleGrant, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the configuration for the Private Link.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationGetRequest, options?: AxiosRequestConfig): AxiosPromise<PrivateLinkConfiguration> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationGet(requestParameters.clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of principals.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsGetRequest, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsGet200Response> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsGet(requestParameters.clusterId, requestParameters.page, requestParameters.search, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new principal for the Private Link.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPost(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPostRequest, options?: AxiosRequestConfig): AxiosPromise<PrivateLinkPrincipal> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPost(requestParameters.clusterId, requestParameters.privateLinkPrincipal, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the principal.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPrincipalIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPrincipalIdDelete(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPrincipalIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPrincipalIdDelete(requestParameters.clusterId, requestParameters.principalId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the principal.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPrincipalIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPrincipalIdGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPrincipalIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<PrivateLinkPrincipal> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPrincipalIdGet(requestParameters.clusterId, requestParameters.principalId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the clusterdeployment.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdClusterdeploymentDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdClusterdeploymentDelete(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdClusterdeploymentDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdClusterdeploymentDelete(requestParameters.clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the upgrade policy for the control plane.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdDelete(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdDelete(requestParameters.clusterId, requestParameters.controlPlaneUpgradePolicyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the upgrade policy for the control plane.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<ControlPlaneUpgradePolicy> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdGet(requestParameters.clusterId, requestParameters.controlPlaneUpgradePolicyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the upgrade policy for the control plane.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdPatch(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<ControlPlaneUpgradePolicy> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdPatch(requestParameters.clusterId, requestParameters.controlPlaneUpgradePolicyId, requestParameters.controlPlaneUpgradePolicy, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of upgrade policies for the control plane.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesGetRequest, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesGet200Response> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesGet(requestParameters.clusterId, requestParameters.page, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new upgrade policy to the control plane of the cluster.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesPost(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesPostRequest, options?: AxiosRequestConfig): AxiosPromise<ControlPlaneUpgradePolicy> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesPost(requestParameters.clusterId, requestParameters.controlPlaneUpgradePolicy, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the credentials of a cluster.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdCredentialsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdCredentialsGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdCredentialsGetRequest, options?: AxiosRequestConfig): AxiosPromise<ClusterCredentials> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdCredentialsGet(requestParameters.clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the cluster.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdDelete(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdDelete(requestParameters.clusterId, requestParameters.deprovision, requestParameters.dryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdDeleteProtectionGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdDeleteProtectionGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdDeleteProtectionGetRequest, options?: AxiosRequestConfig): AxiosPromise<DeleteProtection> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdDeleteProtectionGet(requestParameters.clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdDeleteProtectionPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdDeleteProtectionPatch(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdDeleteProtectionPatchRequest, options?: AxiosRequestConfig): AxiosPromise<DeleteProtection> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdDeleteProtectionPatch(requestParameters.clusterId, requestParameters.deleteProtection, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the external configuration.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationGetRequest, options?: AxiosRequestConfig): AxiosPromise<ExternalConfiguration> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdExternalConfigurationGet(requestParameters.clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of labels.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsGetRequest, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsGet200Response> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsGet(requestParameters.clusterId, requestParameters.page, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the label.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdDelete(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdDelete(requestParameters.clusterId, requestParameters.labelId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the label.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<Label> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdGet(requestParameters.clusterId, requestParameters.labelId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the label.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdPatch(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<Label> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdPatch(requestParameters.clusterId, requestParameters.labelId, requestParameters.label, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new label to the cluster.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsPost(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsPostRequest, options?: AxiosRequestConfig): AxiosPromise<Label> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsPost(requestParameters.clusterId, requestParameters.label, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of manifests.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsGetRequest, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsGet200Response> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsGet(requestParameters.clusterId, requestParameters.page, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the manifest.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdDelete(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdDelete(requestParameters.clusterId, requestParameters.manifestId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the manifest.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<Manifest> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdGet(requestParameters.clusterId, requestParameters.manifestId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the manifest.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdPatch(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<Manifest> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdPatch(requestParameters.clusterId, requestParameters.manifestId, requestParameters.manifest, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new manifest to a cluster.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsPost(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsPostRequest, options?: AxiosRequestConfig): AxiosPromise<Manifest> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsPost(requestParameters.clusterId, requestParameters.manifest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of syncsets.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsGetRequest, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsGet200Response> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsGet(requestParameters.clusterId, requestParameters.page, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new syncset to the cluster.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsPost(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsPostRequest, options?: AxiosRequestConfig): AxiosPromise<Syncset> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsPost(requestParameters.clusterId, requestParameters.syncset, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the syncset.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdDelete(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdDelete(requestParameters.clusterId, requestParameters.syncsetId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the syncset.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<Syncset> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdGet(requestParameters.clusterId, requestParameters.syncsetId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the syncset.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdPatch(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<Syncset> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdPatch(requestParameters.clusterId, requestParameters.syncsetId, requestParameters.syncset, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of reasons.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdGateAgreementsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGateAgreementsGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdGateAgreementsGetRequest, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1ClustersClusterIdGateAgreementsGet200Response> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdGateAgreementsGet(requestParameters.clusterId, requestParameters.page, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new agreed version gate to the cluster.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdGateAgreementsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGateAgreementsPost(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdGateAgreementsPostRequest, options?: AxiosRequestConfig): AxiosPromise<VersionGateAgreement> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdGateAgreementsPost(requestParameters.clusterId, requestParameters.versionGateAgreement, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the version gate agreement.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdDelete(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdDelete(requestParameters.clusterId, requestParameters.versionGateAgreementId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the version gate agreement.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<VersionGateAgreement> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdGet(requestParameters.clusterId, requestParameters.versionGateAgreementId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the cluster.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<Cluster> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdGet(requestParameters.clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of groups.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGroupsGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGetRequest, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1ClustersClusterIdGroupsGet200Response> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdGroupsGet(requestParameters.clusterId, requestParameters.page, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the group.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGroupIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGroupsGroupIdGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGroupIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<Group> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdGroupsGroupIdGet(requestParameters.clusterId, requestParameters.groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of users.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersGetRequest, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersGet200Response> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersGet(requestParameters.clusterId, requestParameters.groupId, requestParameters.page, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new user to the group.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersPost(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersPostRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersPost(requestParameters.clusterId, requestParameters.groupId, requestParameters.user, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the user.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdDelete(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdDelete(requestParameters.clusterId, requestParameters.groupId, requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the user.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdGet(requestParameters.clusterId, requestParameters.groupId, requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Initiates cluster hibernation. While hibernating a cluster will not consume any cloud provider infrastructure but will be counted for quota.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdHibernatePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdHibernatePost(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdHibernatePostRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdHibernatePost(requestParameters.clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the Hypershift details for a single cluster.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdHypershiftGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdHypershiftGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdHypershiftGetRequest, options?: AxiosRequestConfig): AxiosPromise<HypershiftConfig> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdHypershiftGet(requestParameters.clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of identity providers.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersGetRequest, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1ClustersClusterIdIdentityProvidersGet200Response> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdIdentityProvidersGet(requestParameters.clusterId, requestParameters.page, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the identity provider.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdDelete(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdDelete(requestParameters.clusterId, requestParameters.identityProviderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the identity provider.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<IdentityProvider> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdGet(requestParameters.clusterId, requestParameters.identityProviderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of _HTPasswd_ IDP users.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersGetRequest, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersGet200Response> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersGet(requestParameters.clusterId, requestParameters.identityProviderId, requestParameters.page, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the user.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdDelete(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdDelete(requestParameters.clusterId, requestParameters.identityProviderId, requestParameters.htpasswdUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the user.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<HTPasswdUser> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdGet(requestParameters.clusterId, requestParameters.identityProviderId, requestParameters.htpasswdUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the user\'s password. The username is not editable
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdPatch(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<HTPasswdUser> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdPatch(requestParameters.clusterId, requestParameters.identityProviderId, requestParameters.htpasswdUserId, requestParameters.hTPasswdUser, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds multiple new users to the _HTPasswd_ file.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersImportPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersImportPost(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersImportPostRequest, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersImportPost200Response> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersImportPost(requestParameters.clusterId, requestParameters.identityProviderId, requestParameters.apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersImportPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new user to the _HTPasswd_ file.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersPost(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersPostRequest, options?: AxiosRequestConfig): AxiosPromise<HTPasswdUser> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersPost(requestParameters.clusterId, requestParameters.identityProviderId, requestParameters.hTPasswdUser, options).then((request) => request(axios, basePath));
        },
        /**
         * Update identity provider in the cluster.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdPatch(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<IdentityProvider> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdPatch(requestParameters.clusterId, requestParameters.identityProviderId, requestParameters.identityProvider, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new identity provider to the cluster.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIdentityProvidersPost(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersPostRequest, options?: AxiosRequestConfig): AxiosPromise<IdentityProvider> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdIdentityProvidersPost(requestParameters.clusterId, requestParameters.identityProvider, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of inflight checks.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdInflightChecksGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdInflightChecksGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdInflightChecksGetRequest, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1ClustersClusterIdInflightChecksGet200Response> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdInflightChecksGet(requestParameters.clusterId, requestParameters.page, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the inflight check.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdInflightChecksInflightCheckIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdInflightChecksInflightCheckIdGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdInflightChecksInflightCheckIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<InflightCheck> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdInflightChecksInflightCheckIdGet(requestParameters.clusterId, requestParameters.inflightCheckId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of ingresses.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIngressesGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesGetRequest, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1ClustersClusterIdIngressesGet200Response> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdIngressesGet(requestParameters.clusterId, requestParameters.page, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the ingress.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesIngressIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIngressesIngressIdDelete(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesIngressIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdIngressesIngressIdDelete(requestParameters.clusterId, requestParameters.ingressId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the ingress.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesIngressIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIngressesIngressIdGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesIngressIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<Ingress> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdIngressesIngressIdGet(requestParameters.clusterId, requestParameters.ingressId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the ingress.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesIngressIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIngressesIngressIdPatch(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesIngressIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<Ingress> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdIngressesIngressIdPatch(requestParameters.clusterId, requestParameters.ingressId, requestParameters.ingress, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates all ingresses
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIngressesPatch(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesPatchRequest, options?: AxiosRequestConfig): AxiosPromise<Array<Ingress>> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdIngressesPatch(requestParameters.clusterId, requestParameters.ingress, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new ingress to the cluster.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdIngressesPost(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesPostRequest, options?: AxiosRequestConfig): AxiosPromise<Ingress> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdIngressesPost(requestParameters.clusterId, requestParameters.ingress, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of reasons.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsGetRequest, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsGet200Response> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsGet(requestParameters.clusterId, requestParameters.page, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the reason.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdDelete(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdDelete(requestParameters.clusterId, requestParameters.limitedSupportReasonId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the reason.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<LimitedSupportReason> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdGet(requestParameters.clusterId, requestParameters.limitedSupportReasonId, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new reason to the cluster.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsPost(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsPostRequest, options?: AxiosRequestConfig): AxiosPromise<LimitedSupportReason> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsPost(requestParameters.clusterId, requestParameters.limitedSupportReason, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of log links.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdLogsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdLogsGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdLogsGetRequest, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1ClustersClusterIdLogsGet200Response> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdLogsGet(requestParameters.clusterId, requestParameters.page, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the log.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdLogsInstallGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdLogsInstallGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdLogsInstallGetRequest, options?: AxiosRequestConfig): AxiosPromise<Log> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdLogsInstallGet(requestParameters.clusterId, requestParameters.offset, requestParameters.tail, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the log.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdLogsUninstallGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdLogsUninstallGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdLogsUninstallGetRequest, options?: AxiosRequestConfig): AxiosPromise<Log> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdLogsUninstallGet(requestParameters.clusterId, requestParameters.offset, requestParameters.tail, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of machine pools.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdMachinePoolsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMachinePoolsGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdMachinePoolsGetRequest, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1ClustersClusterIdMachinePoolsGet200Response> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdMachinePoolsGet(requestParameters.clusterId, requestParameters.page, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the machine pool.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdDelete(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdDelete(requestParameters.clusterId, requestParameters.machinePoolId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the machine pool.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<MachinePool> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdGet(requestParameters.clusterId, requestParameters.machinePoolId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the machine pool.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdPatch(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<MachinePool> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdPatch(requestParameters.clusterId, requestParameters.machinePoolId, requestParameters.machinePool, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new machine pool to the cluster.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdMachinePoolsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMachinePoolsPost(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdMachinePoolsPostRequest, options?: AxiosRequestConfig): AxiosPromise<MachinePool> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdMachinePoolsPost(requestParameters.clusterId, requestParameters.machinePool, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdMetricQueriesAlertsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMetricQueriesAlertsGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdMetricQueriesAlertsGetRequest, options?: AxiosRequestConfig): AxiosPromise<AlertsInfo> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdMetricQueriesAlertsGet(requestParameters.clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdMetricQueriesClusterOperatorsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMetricQueriesClusterOperatorsGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdMetricQueriesClusterOperatorsGetRequest, options?: AxiosRequestConfig): AxiosPromise<ClusterOperatorsInfo> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdMetricQueriesClusterOperatorsGet(requestParameters.clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the metrics.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdMetricQueriesCpuTotalByNodeRolesOsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMetricQueriesCpuTotalByNodeRolesOsGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdMetricQueriesCpuTotalByNodeRolesOsGetRequest, options?: AxiosRequestConfig): AxiosPromise<CPUTotalsNodeRoleOSMetricNode> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdMetricQueriesCpuTotalByNodeRolesOsGet(requestParameters.clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdMetricQueriesNodesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMetricQueriesNodesGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdMetricQueriesNodesGetRequest, options?: AxiosRequestConfig): AxiosPromise<NodesInfo> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdMetricQueriesNodesGet(requestParameters.clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the metrics.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdMetricQueriesSocketTotalByNodeRolesOsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdMetricQueriesSocketTotalByNodeRolesOsGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdMetricQueriesSocketTotalByNodeRolesOsGetRequest, options?: AxiosRequestConfig): AxiosPromise<SocketTotalsNodeRoleOSMetricNode> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdMetricQueriesSocketTotalByNodeRolesOsGet(requestParameters.clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of node pools.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdNodePoolsGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsGetRequest, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1ClustersClusterIdNodePoolsGet200Response> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdNodePoolsGet(requestParameters.clusterId, requestParameters.page, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the node pool.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdDelete(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdDelete(requestParameters.clusterId, requestParameters.nodePoolId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the node pool.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<NodePool> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdGet(requestParameters.clusterId, requestParameters.nodePoolId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the node pool.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdPatch(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<NodePool> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdPatch(requestParameters.clusterId, requestParameters.nodePoolId, requestParameters.nodePool, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of upgrade policies for the node pool.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesGetRequest, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesGet200Response> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesGet(requestParameters.clusterId, requestParameters.nodePoolId, requestParameters.page, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the upgrade policy for the node pool.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdDelete(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdDelete(requestParameters.clusterId, requestParameters.nodePoolId, requestParameters.nodePoolUpgradePolicyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the upgrade policy for the node pool.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<NodePoolUpgradePolicy> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdGet(requestParameters.clusterId, requestParameters.nodePoolId, requestParameters.nodePoolUpgradePolicyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the upgrade policy for the node pool.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdPatch(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<NodePoolUpgradePolicy> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdPatch(requestParameters.clusterId, requestParameters.nodePoolId, requestParameters.nodePoolUpgradePolicyId, requestParameters.nodePoolUpgradePolicy, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new upgrade policy to the node pool of the cluster.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesPost(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesPostRequest, options?: AxiosRequestConfig): AxiosPromise<NodePoolUpgradePolicy> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesPost(requestParameters.clusterId, requestParameters.nodePoolId, requestParameters.nodePoolUpgradePolicy, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new node pool to the cluster.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdNodePoolsPost(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsPostRequest, options?: AxiosRequestConfig): AxiosPromise<NodePool> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdNodePoolsPost(requestParameters.clusterId, requestParameters.nodePool, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the cluster.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdPatch(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<Cluster> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdPatch(requestParameters.clusterId, requestParameters.cluster, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the product.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdProductGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdProductGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdProductGetRequest, options?: AxiosRequestConfig): AxiosPromise<Product> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdProductGet(requestParameters.clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the provision shard.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdProvisionShardDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdProvisionShardDelete(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdProvisionShardDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdProvisionShardDelete(requestParameters.clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the provision shard.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdProvisionShardGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdProvisionShardGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdProvisionShardGetRequest, options?: AxiosRequestConfig): AxiosPromise<ProvisionShard> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdProvisionShardGet(requestParameters.clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the details of the provision shard.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdProvisionShardPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdProvisionShardPatch(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdProvisionShardPatchRequest, options?: AxiosRequestConfig): AxiosPromise<ProvisionShard> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdProvisionShardPatch(requestParameters.clusterId, requestParameters.provisionShard, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of resources for a cluster in error state
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdResourcesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdResourcesGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdResourcesGetRequest, options?: AxiosRequestConfig): AxiosPromise<ClusterResources> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdResourcesGet(requestParameters.clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves currently available cluster resources
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdResourcesLiveGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdResourcesLiveGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdResourcesLiveGetRequest, options?: AxiosRequestConfig): AxiosPromise<ClusterResources> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdResourcesLiveGet(requestParameters.clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Resumes from Hibernation.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdResumePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdResumePost(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdResumePostRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdResumePost(requestParameters.clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdStatusGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdStatusGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdStatusGetRequest, options?: AxiosRequestConfig): AxiosPromise<ClusterStatus> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdStatusGet(requestParameters.clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of operator roles.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdStsOperatorRolesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdStsOperatorRolesGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdStsOperatorRolesGetRequest, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1ClustersClusterIdStsOperatorRolesGet200Response> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdStsOperatorRolesGet(requestParameters.clusterId, requestParameters.page, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the operator role.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdStsOperatorRolesOperatorIamRoleIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdStsOperatorRolesOperatorIamRoleIdDelete(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdStsOperatorRolesOperatorIamRoleIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdStsOperatorRolesOperatorIamRoleIdDelete(requestParameters.clusterId, requestParameters.operatorIamRoleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new operator role to the cluster.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdStsOperatorRolesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdStsOperatorRolesPost(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdStsOperatorRolesPostRequest, options?: AxiosRequestConfig): AxiosPromise<OperatorIAMRole> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdStsOperatorRolesPost(requestParameters.clusterId, requestParameters.operatorIAMRole, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdStsSupportJumpRoleGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdStsSupportJumpRoleGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdStsSupportJumpRoleGetRequest, options?: AxiosRequestConfig): AxiosPromise<StsSupportJumpRole> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdStsSupportJumpRoleGet(requestParameters.clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of tuning configs.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdTuningConfigsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdTuningConfigsGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdTuningConfigsGetRequest, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1ClustersClusterIdTuningConfigsGet200Response> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdTuningConfigsGet(requestParameters.clusterId, requestParameters.page, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new tuning config to the cluster.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdTuningConfigsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdTuningConfigsPost(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdTuningConfigsPostRequest, options?: AxiosRequestConfig): AxiosPromise<TuningConfig> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdTuningConfigsPost(requestParameters.clusterId, requestParameters.tuningConfig, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the tuning config.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdDelete(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdDelete(requestParameters.clusterId, requestParameters.tuningConfigId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the tuning config.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<TuningConfig> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdGet(requestParameters.clusterId, requestParameters.tuningConfigId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the tuning config.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdPatch(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<TuningConfig> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdPatch(requestParameters.clusterId, requestParameters.tuningConfigId, requestParameters.tuningConfig, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of upgrade policies.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdUpgradePoliciesGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesGetRequest, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1ClustersClusterIdUpgradePoliciesGet200Response> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdUpgradePoliciesGet(requestParameters.clusterId, requestParameters.page, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new upgrade policy to the cluster.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdUpgradePoliciesPost(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesPostRequest, options?: AxiosRequestConfig): AxiosPromise<UpgradePolicy> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdUpgradePoliciesPost(requestParameters.clusterId, requestParameters.upgradePolicy, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the upgrade policy.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdDelete(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdDelete(requestParameters.clusterId, requestParameters.upgradePolicyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the upgrade policy.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<UpgradePolicy> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdGet(requestParameters.clusterId, requestParameters.upgradePolicyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the upgrade policy.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdPatch(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<UpgradePolicy> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdPatch(requestParameters.clusterId, requestParameters.upgradePolicyId, requestParameters.upgradePolicy, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the upgrade policy state.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStateGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStateGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStateGetRequest, options?: AxiosRequestConfig): AxiosPromise<UpgradePolicyState> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStateGet(requestParameters.clusterId, requestParameters.upgradePolicyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the upgrade policy state.
         * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStatePatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStatePatch(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStatePatchRequest, options?: AxiosRequestConfig): AxiosPromise<UpgradePolicyState> {
            return localVarFp.apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStatePatch(requestParameters.clusterId, requestParameters.upgradePolicyId, requestParameters.upgradePolicyState, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of clusters.
         * @param {DefaultApiApiClustersMgmtV1ClustersGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1ClustersGet200Response> {
            return localVarFp.apiClustersMgmtV1ClustersGet(requestParameters.order, requestParameters.page, requestParameters.search, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * Provision a new cluster and add it to the collection of clusters.  See the `register_cluster` method for adding an existing cluster.
         * @param {DefaultApiApiClustersMgmtV1ClustersPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ClustersPost(requestParameters: DefaultApiApiClustersMgmtV1ClustersPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Cluster> {
            return localVarFp.apiClustersMgmtV1ClustersPost(requestParameters.cluster, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the DNS domain.
         * @param {DefaultApiApiClustersMgmtV1DnsDomainsDnsDomainIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1DnsDomainsDnsDomainIdDelete(requestParameters: DefaultApiApiClustersMgmtV1DnsDomainsDnsDomainIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1DnsDomainsDnsDomainIdDelete(requestParameters.dnsDomainId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the DNS domain.
         * @param {DefaultApiApiClustersMgmtV1DnsDomainsDnsDomainIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1DnsDomainsDnsDomainIdGet(requestParameters: DefaultApiApiClustersMgmtV1DnsDomainsDnsDomainIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<DNSDomain> {
            return localVarFp.apiClustersMgmtV1DnsDomainsDnsDomainIdGet(requestParameters.dnsDomainId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the details of the DNS domain.
         * @param {DefaultApiApiClustersMgmtV1DnsDomainsDnsDomainIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1DnsDomainsDnsDomainIdPatch(requestParameters: DefaultApiApiClustersMgmtV1DnsDomainsDnsDomainIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<DNSDomain> {
            return localVarFp.apiClustersMgmtV1DnsDomainsDnsDomainIdPatch(requestParameters.dnsDomainId, requestParameters.dNSDomain, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DefaultApiApiClustersMgmtV1DnsDomainsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1DnsDomainsGet(requestParameters: DefaultApiApiClustersMgmtV1DnsDomainsGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1DnsDomainsGet200Response> {
            return localVarFp.apiClustersMgmtV1DnsDomainsGet(requestParameters.page, requestParameters.search, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a DNS domain.
         * @param {DefaultApiApiClustersMgmtV1DnsDomainsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1DnsDomainsPost(requestParameters: DefaultApiApiClustersMgmtV1DnsDomainsPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<DNSDomain> {
            return localVarFp.apiClustersMgmtV1DnsDomainsPost(requestParameters.dNSDomain, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the environment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1EnvironmentGet(options?: AxiosRequestConfig): AxiosPromise<Environment> {
            return localVarFp.apiClustersMgmtV1EnvironmentGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the environment.  Attributes that can be updated are:  - `last_upgrade_available_check` - `last_limited_support_check`
         * @param {DefaultApiApiClustersMgmtV1EnvironmentPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1EnvironmentPatch(requestParameters: DefaultApiApiClustersMgmtV1EnvironmentPatchRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Environment> {
            return localVarFp.apiClustersMgmtV1EnvironmentPatch(requestParameters.environment, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new event to be tracked. When sending a new event request, it gets tracked in Prometheus, Pendo, CloudWatch, or whichever analytics client is configured as part of clusters service. This allows for reporting on events that happen outside of a regular API request, but are found to be useful for understanding customer needs and possible blockers.
         * @param {DefaultApiApiClustersMgmtV1EventsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1EventsPost(requestParameters: DefaultApiApiClustersMgmtV1EventsPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Event> {
            return localVarFp.apiClustersMgmtV1EventsPost(requestParameters.event, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the cluster flavour.
         * @param {DefaultApiApiClustersMgmtV1FlavoursFlavourIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1FlavoursFlavourIdGet(requestParameters: DefaultApiApiClustersMgmtV1FlavoursFlavourIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<Flavour> {
            return localVarFp.apiClustersMgmtV1FlavoursFlavourIdGet(requestParameters.flavourId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the flavour.  Attributes that can be updated are:  - `aws.infra_volume` - `aws.infra_instance_type` - `gcp.infra_instance_type`
         * @param {DefaultApiApiClustersMgmtV1FlavoursFlavourIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1FlavoursFlavourIdPatch(requestParameters: DefaultApiApiClustersMgmtV1FlavoursFlavourIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<Flavour> {
            return localVarFp.apiClustersMgmtV1FlavoursFlavourIdPatch(requestParameters.flavourId, requestParameters.flavour, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DefaultApiApiClustersMgmtV1FlavoursGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1FlavoursGet(requestParameters: DefaultApiApiClustersMgmtV1FlavoursGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1FlavoursGet200Response> {
            return localVarFp.apiClustersMgmtV1FlavoursGet(requestParameters.order, requestParameters.page, requestParameters.search, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new cluster flavour.
         * @param {DefaultApiApiClustersMgmtV1FlavoursPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1FlavoursPost(requestParameters: DefaultApiApiClustersMgmtV1FlavoursPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Flavour> {
            return localVarFp.apiClustersMgmtV1FlavoursPost(requestParameters.flavour, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of encryption keys. IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider.
         * @param {DefaultApiApiClustersMgmtV1GcpInquiriesEncryptionKeysPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1GcpInquiriesEncryptionKeysPost(requestParameters: DefaultApiApiClustersMgmtV1GcpInquiriesEncryptionKeysPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1GcpInquiriesEncryptionKeysPost200Response> {
            return localVarFp.apiClustersMgmtV1GcpInquiriesEncryptionKeysPost(requestParameters.page, requestParameters.size, requestParameters.cloudProviderData, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of available key rings of the cloud provider. IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider.
         * @param {DefaultApiApiClustersMgmtV1GcpInquiriesKeyRingsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1GcpInquiriesKeyRingsPost(requestParameters: DefaultApiApiClustersMgmtV1GcpInquiriesKeyRingsPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1GcpInquiriesKeyRingsPost200Response> {
            return localVarFp.apiClustersMgmtV1GcpInquiriesKeyRingsPost(requestParameters.page, requestParameters.size, requestParameters.cloudProviderData, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of available regions of the cloud provider. IMPORTANT: This list doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider.
         * @param {DefaultApiApiClustersMgmtV1GcpInquiriesRegionsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1GcpInquiriesRegionsPost(requestParameters: DefaultApiApiClustersMgmtV1GcpInquiriesRegionsPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1AwsInquiriesRegionsPost200Response> {
            return localVarFp.apiClustersMgmtV1GcpInquiriesRegionsPost(requestParameters.page, requestParameters.size, requestParameters.cloudProviderData, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of available vpcs of the cloud provider for specific region. IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available vpcs of the provider.
         * @param {DefaultApiApiClustersMgmtV1GcpInquiriesVpcsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1GcpInquiriesVpcsPost(requestParameters: DefaultApiApiClustersMgmtV1GcpInquiriesVpcsPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1AwsInquiriesVpcsPost200Response> {
            return localVarFp.apiClustersMgmtV1GcpInquiriesVpcsPost(requestParameters.page, requestParameters.size, requestParameters.cloudProviderData, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the version metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1Get(options?: AxiosRequestConfig): AxiosPromise<Metadata> {
            return localVarFp.apiClustersMgmtV1Get(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of templates.
         * @param {DefaultApiApiClustersMgmtV1LimitedSupportReasonTemplatesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1LimitedSupportReasonTemplatesGet(requestParameters: DefaultApiApiClustersMgmtV1LimitedSupportReasonTemplatesGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1LimitedSupportReasonTemplatesGet200Response> {
            return localVarFp.apiClustersMgmtV1LimitedSupportReasonTemplatesGet(requestParameters.page, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the template.
         * @param {DefaultApiApiClustersMgmtV1LimitedSupportReasonTemplatesLimitedSupportReasonTemplateIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1LimitedSupportReasonTemplatesLimitedSupportReasonTemplateIdGet(requestParameters: DefaultApiApiClustersMgmtV1LimitedSupportReasonTemplatesLimitedSupportReasonTemplateIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<LimitedSupportReasonTemplate> {
            return localVarFp.apiClustersMgmtV1LimitedSupportReasonTemplatesLimitedSupportReasonTemplateIdGet(requestParameters.limitedSupportReasonTemplateId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of machine types.
         * @param {DefaultApiApiClustersMgmtV1MachineTypesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1MachineTypesGet(requestParameters: DefaultApiApiClustersMgmtV1MachineTypesGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1MachineTypesGet200Response> {
            return localVarFp.apiClustersMgmtV1MachineTypesGet(requestParameters.order, requestParameters.page, requestParameters.search, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the machine type.
         * @param {DefaultApiApiClustersMgmtV1MachineTypesMachineTypeIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1MachineTypesMachineTypeIdGet(requestParameters: DefaultApiApiClustersMgmtV1MachineTypesMachineTypeIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<MachineType> {
            return localVarFp.apiClustersMgmtV1MachineTypesMachineTypeIdGet(requestParameters.machineTypeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of a subnet network verification.
         * @param {DefaultApiApiClustersMgmtV1NetworkVerificationsNetworkVerificationIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1NetworkVerificationsNetworkVerificationIdGet(requestParameters: DefaultApiApiClustersMgmtV1NetworkVerificationsNetworkVerificationIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<SubnetNetworkVerification> {
            return localVarFp.apiClustersMgmtV1NetworkVerificationsNetworkVerificationIdGet(requestParameters.networkVerificationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates an entry for a network verification for each subnet supplied setting then to initial state.
         * @param {DefaultApiApiClustersMgmtV1NetworkVerificationsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1NetworkVerificationsPost(requestParameters: DefaultApiApiClustersMgmtV1NetworkVerificationsPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<NetworkVerification> {
            return localVarFp.apiClustersMgmtV1NetworkVerificationsPost(requestParameters.networkVerification, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of oidc configs.
         * @param {DefaultApiApiClustersMgmtV1OidcConfigsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1OidcConfigsGet(requestParameters: DefaultApiApiClustersMgmtV1OidcConfigsGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1OidcConfigsGet200Response> {
            return localVarFp.apiClustersMgmtV1OidcConfigsGet(requestParameters.page, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the OidcConfig.
         * @param {DefaultApiApiClustersMgmtV1OidcConfigsOidcConfigIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1OidcConfigsOidcConfigIdDelete(requestParameters: DefaultApiApiClustersMgmtV1OidcConfigsOidcConfigIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1OidcConfigsOidcConfigIdDelete(requestParameters.oidcConfigId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of an OidcConfig.
         * @param {DefaultApiApiClustersMgmtV1OidcConfigsOidcConfigIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1OidcConfigsOidcConfigIdGet(requestParameters: DefaultApiApiClustersMgmtV1OidcConfigsOidcConfigIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<OidcConfig> {
            return localVarFp.apiClustersMgmtV1OidcConfigsOidcConfigIdGet(requestParameters.oidcConfigId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates attributes of an OidcConfig.
         * @param {DefaultApiApiClustersMgmtV1OidcConfigsOidcConfigIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1OidcConfigsOidcConfigIdPatch(requestParameters: DefaultApiApiClustersMgmtV1OidcConfigsOidcConfigIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<OidcConfig> {
            return localVarFp.apiClustersMgmtV1OidcConfigsOidcConfigIdPatch(requestParameters.oidcConfigId, requestParameters.oidcConfig, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a hosting under Red Hat\'s S3 bucket for byo oidc configuration.
         * @param {DefaultApiApiClustersMgmtV1OidcConfigsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1OidcConfigsPost(requestParameters: DefaultApiApiClustersMgmtV1OidcConfigsPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<OidcConfig> {
            return localVarFp.apiClustersMgmtV1OidcConfigsPost(requestParameters.oidcConfig, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of pending delete clusters.
         * @param {DefaultApiApiClustersMgmtV1PendingDeleteClustersGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1PendingDeleteClustersGet(requestParameters: DefaultApiApiClustersMgmtV1PendingDeleteClustersGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1PendingDeleteClustersGet200Response> {
            return localVarFp.apiClustersMgmtV1PendingDeleteClustersGet(requestParameters.order, requestParameters.page, requestParameters.search, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the pending delete cluster.
         * @param {DefaultApiApiClustersMgmtV1PendingDeleteClustersPendingDeleteClusterIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1PendingDeleteClustersPendingDeleteClusterIdGet(requestParameters: DefaultApiApiClustersMgmtV1PendingDeleteClustersPendingDeleteClusterIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<PendingDeleteCluster> {
            return localVarFp.apiClustersMgmtV1PendingDeleteClustersPendingDeleteClusterIdGet(requestParameters.pendingDeleteClusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the pending delete cluster entry.
         * @param {DefaultApiApiClustersMgmtV1PendingDeleteClustersPendingDeleteClusterIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1PendingDeleteClustersPendingDeleteClusterIdPatch(requestParameters: DefaultApiApiClustersMgmtV1PendingDeleteClustersPendingDeleteClusterIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<PendingDeleteCluster> {
            return localVarFp.apiClustersMgmtV1PendingDeleteClustersPendingDeleteClusterIdPatch(requestParameters.pendingDeleteClusterId, requestParameters.pendingDeleteCluster, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of products.
         * @param {DefaultApiApiClustersMgmtV1ProductsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ProductsGet(requestParameters: DefaultApiApiClustersMgmtV1ProductsGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1ProductsGet200Response> {
            return localVarFp.apiClustersMgmtV1ProductsGet(requestParameters.order, requestParameters.page, requestParameters.search, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the product.
         * @param {DefaultApiApiClustersMgmtV1ProductsProductIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ProductsProductIdGet(requestParameters: DefaultApiApiClustersMgmtV1ProductsProductIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<Product> {
            return localVarFp.apiClustersMgmtV1ProductsProductIdGet(requestParameters.productId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DefaultApiApiClustersMgmtV1ProvisionShardsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ProvisionShardsGet(requestParameters: DefaultApiApiClustersMgmtV1ProvisionShardsGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1ProvisionShardsGet200Response> {
            return localVarFp.apiClustersMgmtV1ProvisionShardsGet(requestParameters.page, requestParameters.search, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a provision shard.
         * @param {DefaultApiApiClustersMgmtV1ProvisionShardsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ProvisionShardsPost(requestParameters: DefaultApiApiClustersMgmtV1ProvisionShardsPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ProvisionShard> {
            return localVarFp.apiClustersMgmtV1ProvisionShardsPost(requestParameters.provisionShard, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the provision shard.
         * @param {DefaultApiApiClustersMgmtV1ProvisionShardsProvisionShardIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ProvisionShardsProvisionShardIdDelete(requestParameters: DefaultApiApiClustersMgmtV1ProvisionShardsProvisionShardIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1ProvisionShardsProvisionShardIdDelete(requestParameters.provisionShardId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the provision shard.
         * @param {DefaultApiApiClustersMgmtV1ProvisionShardsProvisionShardIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ProvisionShardsProvisionShardIdGet(requestParameters: DefaultApiApiClustersMgmtV1ProvisionShardsProvisionShardIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<ProvisionShard> {
            return localVarFp.apiClustersMgmtV1ProvisionShardsProvisionShardIdGet(requestParameters.provisionShardId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the details of the provision shard.
         * @param {DefaultApiApiClustersMgmtV1ProvisionShardsProvisionShardIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1ProvisionShardsProvisionShardIdPatch(requestParameters: DefaultApiApiClustersMgmtV1ProvisionShardsProvisionShardIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<ProvisionShard> {
            return localVarFp.apiClustersMgmtV1ProvisionShardsProvisionShardIdPatch(requestParameters.provisionShardId, requestParameters.provisionShard, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of trusted ip addresses.
         * @param {DefaultApiApiClustersMgmtV1TrustedIpAddressesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1TrustedIpAddressesGet(requestParameters: DefaultApiApiClustersMgmtV1TrustedIpAddressesGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1TrustedIpAddressesGet200Response> {
            return localVarFp.apiClustersMgmtV1TrustedIpAddressesGet(requestParameters.page, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the trusted ip adresses.
         * @param {DefaultApiApiClustersMgmtV1TrustedIpAddressesTrustedIpIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1TrustedIpAddressesTrustedIpIdGet(requestParameters: DefaultApiApiClustersMgmtV1TrustedIpAddressesTrustedIpIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<TrustedIp> {
            return localVarFp.apiClustersMgmtV1TrustedIpAddressesTrustedIpIdGet(requestParameters.trustedIpId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of version gates.
         * @param {DefaultApiApiClustersMgmtV1VersionGatesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1VersionGatesGet(requestParameters: DefaultApiApiClustersMgmtV1VersionGatesGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1VersionGatesGet200Response> {
            return localVarFp.apiClustersMgmtV1VersionGatesGet(requestParameters.order, requestParameters.page, requestParameters.search, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new version gate
         * @param {DefaultApiApiClustersMgmtV1VersionGatesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1VersionGatesPost(requestParameters: DefaultApiApiClustersMgmtV1VersionGatesPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<VersionGate> {
            return localVarFp.apiClustersMgmtV1VersionGatesPost(requestParameters.versionGate, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the version gate.
         * @param {DefaultApiApiClustersMgmtV1VersionGatesVersionGateIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1VersionGatesVersionGateIdDelete(requestParameters: DefaultApiApiClustersMgmtV1VersionGatesVersionGateIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiClustersMgmtV1VersionGatesVersionGateIdDelete(requestParameters.versionGateId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the version gate.
         * @param {DefaultApiApiClustersMgmtV1VersionGatesVersionGateIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1VersionGatesVersionGateIdGet(requestParameters: DefaultApiApiClustersMgmtV1VersionGatesVersionGateIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<VersionGate> {
            return localVarFp.apiClustersMgmtV1VersionGatesVersionGateIdGet(requestParameters.versionGateId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of versions.
         * @param {DefaultApiApiClustersMgmtV1VersionsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1VersionsGet(requestParameters: DefaultApiApiClustersMgmtV1VersionsGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ApiClustersMgmtV1VersionsGet200Response> {
            return localVarFp.apiClustersMgmtV1VersionsGet(requestParameters.order, requestParameters.page, requestParameters.search, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of the version.
         * @param {DefaultApiApiClustersMgmtV1VersionsVersionIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClustersMgmtV1VersionsVersionIdGet(requestParameters: DefaultApiApiClustersMgmtV1VersionsVersionIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<Version> {
            return localVarFp.apiClustersMgmtV1VersionsVersionIdGet(requestParameters.versionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for apiClustersMgmtV1AddonsAddonIdDelete operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1AddonsAddonIdDeleteRequest
 */
export interface DefaultApiApiClustersMgmtV1AddonsAddonIdDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1AddonsAddonIdDelete
     */
    readonly addonId: string
}

/**
 * Request parameters for apiClustersMgmtV1AddonsAddonIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1AddonsAddonIdGetRequest
 */
export interface DefaultApiApiClustersMgmtV1AddonsAddonIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1AddonsAddonIdGet
     */
    readonly addonId: string
}

/**
 * Request parameters for apiClustersMgmtV1AddonsAddonIdPatch operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1AddonsAddonIdPatchRequest
 */
export interface DefaultApiApiClustersMgmtV1AddonsAddonIdPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1AddonsAddonIdPatch
     */
    readonly addonId: string

    /**
     * 
     * @type {AddOn}
     * @memberof DefaultApiApiClustersMgmtV1AddonsAddonIdPatch
     */
    readonly addOn?: AddOn
}

/**
 * Request parameters for apiClustersMgmtV1AddonsAddonIdVersionsGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1AddonsAddonIdVersionsGetRequest
 */
export interface DefaultApiApiClustersMgmtV1AddonsAddonIdVersionsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1AddonsAddonIdVersionsGet
     */
    readonly addonId: string

    /**
     * Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to sort the add-on versions descending by id the value should be:  &#x60;&#x60;&#x60;sql id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1AddonsAddonIdVersionsGet
     */
    readonly order?: string

    /**
     * Index of the requested page, where one corresponds to the first page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1AddonsAddonIdVersionsGet
     */
    readonly page?: number

    /**
     * Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the add-on version instead of the names of the columns of a table. For example, in order to retrieve all the add-on versions with an id starting with &#x60;0.1&#x60; the value should be:  &#x60;&#x60;&#x60;sql id like \&#39;0.1.%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the add-on versions that the user has permission to see will be returned.
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1AddonsAddonIdVersionsGet
     */
    readonly search?: string

    /**
     * Maximum number of items that will be contained in the returned page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1AddonsAddonIdVersionsGet
     */
    readonly size?: number
}

/**
 * Request parameters for apiClustersMgmtV1AddonsAddonIdVersionsPost operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1AddonsAddonIdVersionsPostRequest
 */
export interface DefaultApiApiClustersMgmtV1AddonsAddonIdVersionsPostRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1AddonsAddonIdVersionsPost
     */
    readonly addonId: string

    /**
     * 
     * @type {AddOnVersion}
     * @memberof DefaultApiApiClustersMgmtV1AddonsAddonIdVersionsPost
     */
    readonly addOnVersion?: AddOnVersion
}

/**
 * Request parameters for apiClustersMgmtV1AddonsAddonIdVersionsVersionIdDelete operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1AddonsAddonIdVersionsVersionIdDeleteRequest
 */
export interface DefaultApiApiClustersMgmtV1AddonsAddonIdVersionsVersionIdDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1AddonsAddonIdVersionsVersionIdDelete
     */
    readonly addonId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1AddonsAddonIdVersionsVersionIdDelete
     */
    readonly versionId: string
}

/**
 * Request parameters for apiClustersMgmtV1AddonsAddonIdVersionsVersionIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1AddonsAddonIdVersionsVersionIdGetRequest
 */
export interface DefaultApiApiClustersMgmtV1AddonsAddonIdVersionsVersionIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1AddonsAddonIdVersionsVersionIdGet
     */
    readonly addonId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1AddonsAddonIdVersionsVersionIdGet
     */
    readonly versionId: string
}

/**
 * Request parameters for apiClustersMgmtV1AddonsAddonIdVersionsVersionIdPatch operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1AddonsAddonIdVersionsVersionIdPatchRequest
 */
export interface DefaultApiApiClustersMgmtV1AddonsAddonIdVersionsVersionIdPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1AddonsAddonIdVersionsVersionIdPatch
     */
    readonly addonId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1AddonsAddonIdVersionsVersionIdPatch
     */
    readonly versionId: string

    /**
     * 
     * @type {AddOnVersion}
     * @memberof DefaultApiApiClustersMgmtV1AddonsAddonIdVersionsVersionIdPatch
     */
    readonly addOnVersion?: AddOnVersion
}

/**
 * Request parameters for apiClustersMgmtV1AddonsGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1AddonsGetRequest
 */
export interface DefaultApiApiClustersMgmtV1AddonsGetRequest {
    /**
     * Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to sort the add-ons descending by name the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1AddonsGet
     */
    readonly order?: string

    /**
     * Index of the requested page, where one corresponds to the first page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1AddonsGet
     */
    readonly page?: number

    /**
     * Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to retrieve all the add-ons with a name starting with &#x60;my&#x60; the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the add-ons that the user has permission to see will be returned.
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1AddonsGet
     */
    readonly search?: string

    /**
     * Maximum number of items that will be contained in the returned page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1AddonsGet
     */
    readonly size?: number
}

/**
 * Request parameters for apiClustersMgmtV1AddonsPost operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1AddonsPostRequest
 */
export interface DefaultApiApiClustersMgmtV1AddonsPostRequest {
    /**
     * 
     * @type {AddOn}
     * @memberof DefaultApiApiClustersMgmtV1AddonsPost
     */
    readonly addOn?: AddOn
}

/**
 * Request parameters for apiClustersMgmtV1AwsInfrastructureAccessRolesAwsInfrastructureAccessRoleIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1AwsInfrastructureAccessRolesAwsInfrastructureAccessRoleIdGetRequest
 */
export interface DefaultApiApiClustersMgmtV1AwsInfrastructureAccessRolesAwsInfrastructureAccessRoleIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1AwsInfrastructureAccessRolesAwsInfrastructureAccessRoleIdGet
     */
    readonly awsInfrastructureAccessRoleId: string
}

/**
 * Request parameters for apiClustersMgmtV1AwsInfrastructureAccessRolesGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1AwsInfrastructureAccessRolesGetRequest
 */
export interface DefaultApiApiClustersMgmtV1AwsInfrastructureAccessRolesGetRequest {
    /**
     * Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the role instead of the names of the columns of a table. For example, in order to sort the roles descending by dislay_name the value should be:  &#x60;&#x60;&#x60;sql display_name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1AwsInfrastructureAccessRolesGet
     */
    readonly order?: string

    /**
     * Index of the requested page, where one corresponds to the first page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1AwsInfrastructureAccessRolesGet
     */
    readonly page?: number

    /**
     * Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the role instead of the names of the columns of a table. For example, in order to retrieve all the role with a name starting with &#x60;my&#x60;the value should be:  &#x60;&#x60;&#x60;sql display_name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the roles that the user has permission to see will be returned.
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1AwsInfrastructureAccessRolesGet
     */
    readonly search?: string

    /**
     * Maximum number of items that will be contained in the returned page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1AwsInfrastructureAccessRolesGet
     */
    readonly size?: number
}

/**
 * Request parameters for apiClustersMgmtV1AwsInquiriesMachineTypesPost operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1AwsInquiriesMachineTypesPostRequest
 */
export interface DefaultApiApiClustersMgmtV1AwsInquiriesMachineTypesPostRequest {
    /**
     * Index of the requested page, where one corresponds to the first page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1AwsInquiriesMachineTypesPost
     */
    readonly page?: number

    /**
     * Maximum number of items that will be contained in the returned page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1AwsInquiriesMachineTypesPost
     */
    readonly size?: number

    /**
     * 
     * @type {CloudProviderData}
     * @memberof DefaultApiApiClustersMgmtV1AwsInquiriesMachineTypesPost
     */
    readonly cloudProviderData?: CloudProviderData
}

/**
 * Request parameters for apiClustersMgmtV1AwsInquiriesRegionsPost operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1AwsInquiriesRegionsPostRequest
 */
export interface DefaultApiApiClustersMgmtV1AwsInquiriesRegionsPostRequest {
    /**
     * Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1AwsInquiriesRegionsPost
     */
    readonly page?: number

    /**
     * Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1AwsInquiriesRegionsPost
     */
    readonly size?: number

    /**
     * 
     * @type {CloudProviderData}
     * @memberof DefaultApiApiClustersMgmtV1AwsInquiriesRegionsPost
     */
    readonly cloudProviderData?: CloudProviderData
}

/**
 * Request parameters for apiClustersMgmtV1AwsInquiriesStsCredentialRequestsGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1AwsInquiriesStsCredentialRequestsGetRequest
 */
export interface DefaultApiApiClustersMgmtV1AwsInquiriesStsCredentialRequestsGetRequest {
    /**
     * Index of the requested page, where one corresponds to the first page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1AwsInquiriesStsCredentialRequestsGet
     */
    readonly page?: number

    /**
     * Maximum number of items that will be contained in the returned page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1AwsInquiriesStsCredentialRequestsGet
     */
    readonly size?: number
}

/**
 * Request parameters for apiClustersMgmtV1AwsInquiriesStsPoliciesGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1AwsInquiriesStsPoliciesGetRequest
 */
export interface DefaultApiApiClustersMgmtV1AwsInquiriesStsPoliciesGetRequest {
    /**
     * Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the awsstspolicies instead of the names of the columns of a table. For example, in order to sort the policies descending by operator type identifier the value should be:  &#x60;&#x60;&#x60;sql orderBy id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1AwsInquiriesStsPoliciesGet
     */
    readonly order?: string

    /**
     * Index of the requested page, where one corresponds to the first page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1AwsInquiriesStsPoliciesGet
     */
    readonly page?: number

    /**
     * Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the awsstspolicies instead of the names of the columns of a table. For example, in order to retrieve all the policies of type  &#x60;operatorrole&#x60; should be:  &#x60;&#x60;&#x60;sql policy_type like \&#39;OperatorRole%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the policies  will be returned.
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1AwsInquiriesStsPoliciesGet
     */
    readonly search?: string

    /**
     * Maximum number of items that will be contained in the returned page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1AwsInquiriesStsPoliciesGet
     */
    readonly size?: number
}

/**
 * Request parameters for apiClustersMgmtV1AwsInquiriesVpcsPost operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1AwsInquiriesVpcsPostRequest
 */
export interface DefaultApiApiClustersMgmtV1AwsInquiriesVpcsPostRequest {
    /**
     * Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1AwsInquiriesVpcsPost
     */
    readonly page?: number

    /**
     * Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of vpcs of the provider.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1AwsInquiriesVpcsPost
     */
    readonly size?: number

    /**
     * 
     * @type {CloudProviderData}
     * @memberof DefaultApiApiClustersMgmtV1AwsInquiriesVpcsPost
     */
    readonly cloudProviderData?: CloudProviderData
}

/**
 * Request parameters for apiClustersMgmtV1CloudProvidersCloudProviderIdAvailableRegionsPost operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdAvailableRegionsPostRequest
 */
export interface DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdAvailableRegionsPostRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdAvailableRegionsPost
     */
    readonly cloudProviderId: string

    /**
     * Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdAvailableRegionsPost
     */
    readonly page?: number

    /**
     * Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdAvailableRegionsPost
     */
    readonly size?: number

    /**
     * 
     * @type {AWS}
     * @memberof DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdAvailableRegionsPost
     */
    readonly aWS?: AWS
}

/**
 * Request parameters for apiClustersMgmtV1CloudProvidersCloudProviderIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdGetRequest
 */
export interface DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdGet
     */
    readonly cloudProviderId: string
}

/**
 * Request parameters for apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdRegionsGetRequest
 */
export interface DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdRegionsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdRegionsGet
     */
    readonly cloudProviderId: string

    /**
     * Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdRegionsGet
     */
    readonly page?: number

    /**
     * Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdRegionsGet
     */
    readonly size?: number
}

/**
 * Request parameters for apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsPost operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdRegionsPostRequest
 */
export interface DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdRegionsPostRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdRegionsPost
     */
    readonly cloudProviderId: string

    /**
     * 
     * @type {CloudRegion}
     * @memberof DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdRegionsPost
     */
    readonly cloudRegion?: CloudRegion
}

/**
 * Request parameters for apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdDelete operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdDeleteRequest
 */
export interface DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdDelete
     */
    readonly cloudProviderId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdDelete
     */
    readonly regionId: string
}

/**
 * Request parameters for apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdGetRequest
 */
export interface DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdGet
     */
    readonly cloudProviderId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdGet
     */
    readonly regionId: string
}

/**
 * Request parameters for apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdPatch operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdPatchRequest
 */
export interface DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdPatch
     */
    readonly cloudProviderId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdPatch
     */
    readonly regionId: string

    /**
     * 
     * @type {CloudRegion}
     * @memberof DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdPatch
     */
    readonly cloudRegion?: CloudRegion
}

/**
 * Request parameters for apiClustersMgmtV1CloudProvidersGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1CloudProvidersGetRequest
 */
export interface DefaultApiApiClustersMgmtV1CloudProvidersGetRequest {
    /**
     * If true, includes the regions on each provider in the output. Could slow request response time.
     * @type {boolean}
     * @memberof DefaultApiApiClustersMgmtV1CloudProvidersGet
     */
    readonly fetchRegions?: boolean

    /**
     * Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the cloud provider instead of the names of the columns of a table. For example, in order to sort the clusters descending by name identifier the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1CloudProvidersGet
     */
    readonly order?: string

    /**
     * Index of the requested page, where one corresponds to the first page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1CloudProvidersGet
     */
    readonly page?: number

    /**
     * Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the cloud provider instead of the names of the columns of a table. For example, in order to retrieve all the cloud providers with a name starting with &#x60;A&#x60; the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;A%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the clusters that the user has permission to see will be returned.
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1CloudProvidersGet
     */
    readonly search?: string

    /**
     * Maximum number of items that will be contained in the returned page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1CloudProvidersGet
     */
    readonly size?: number
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdAddonInquiriesAddonInquiryIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdAddonInquiriesAddonInquiryIdGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdAddonInquiriesAddonInquiryIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAddonInquiriesAddonInquiryIdGet
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAddonInquiriesAddonInquiryIdGet
     */
    readonly addonInquiryId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdAddonInquiriesGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdAddonInquiriesGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdAddonInquiriesGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAddonInquiriesGet
     */
    readonly clusterId: string

    /**
     * Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to sort the add-ons descending by name the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAddonInquiriesGet
     */
    readonly order?: string

    /**
     * Index of the requested page, where one corresponds to the first page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAddonInquiriesGet
     */
    readonly page?: number

    /**
     * Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the add-on instead of the names of the columns of a table. For example, in order to retrieve all the add-ons with a name starting with &#x60;my&#x60; the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the add-ons that the user has permission to see will be returned.
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAddonInquiriesGet
     */
    readonly search?: string

    /**
     * Maximum number of items that will be contained in the returned page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAddonInquiriesGet
     */
    readonly size?: number
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdDelete operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdDeleteRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdDelete
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdDelete
     */
    readonly addonUpgradePolicyId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdGet
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdGet
     */
    readonly addonUpgradePolicyId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdPatch operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdPatchRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdPatch
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdPatch
     */
    readonly addonUpgradePolicyId: string

    /**
     * 
     * @type {AddonUpgradePolicy}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdPatch
     */
    readonly addonUpgradePolicy?: AddonUpgradePolicy
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdStateGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdStateGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdStateGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdStateGet
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdStateGet
     */
    readonly addonUpgradePolicyId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdStatePatch operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdStatePatchRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdStatePatchRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdStatePatch
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdStatePatch
     */
    readonly addonUpgradePolicyId: string

    /**
     * 
     * @type {AddonUpgradePolicyState}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdStatePatch
     */
    readonly addonUpgradePolicyState?: AddonUpgradePolicyState
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesGet
     */
    readonly clusterId: string

    /**
     * Index of the requested page, where one corresponds to the first page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesGet
     */
    readonly page?: number

    /**
     * Number of items contained in the returned page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesGet
     */
    readonly size?: number
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesPost operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesPostRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesPostRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesPost
     */
    readonly clusterId: string

    /**
     * 
     * @type {AddonUpgradePolicy}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesPost
     */
    readonly addonUpgradePolicy?: AddonUpgradePolicy
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdDelete operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdDeleteRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdDelete
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdDelete
     */
    readonly addoninstallationId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdGet
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdGet
     */
    readonly addoninstallationId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdPatch operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdPatchRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdPatch
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdPatch
     */
    readonly addoninstallationId: string

    /**
     * 
     * @type {AddOnInstallation}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdPatch
     */
    readonly addOnInstallation?: AddOnInstallation
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdAddonsGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdAddonsGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdAddonsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAddonsGet
     */
    readonly clusterId: string

    /**
     * Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the add-on installation instead of the names of the columns of a table. For example, in order to sort the add-on installations descending by name the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAddonsGet
     */
    readonly order?: string

    /**
     * Index of the requested page, where one corresponds to the first page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAddonsGet
     */
    readonly page?: number

    /**
     * Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the add-on installation instead of the names of the columns of a table. For example, in order to retrieve all the add-on installations with a name starting with &#x60;my&#x60; the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the add-on installations that the user has permission to see will be returned.
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAddonsGet
     */
    readonly search?: string

    /**
     * Maximum number of items that will be contained in the returned page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAddonsGet
     */
    readonly size?: number
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdAddonsPost operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdAddonsPostRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdAddonsPostRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAddonsPost
     */
    readonly clusterId: string

    /**
     * 
     * @type {AddOnInstallation}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAddonsPost
     */
    readonly addOnInstallation?: AddOnInstallation
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdAutoscalerDelete operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdAutoscalerDeleteRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdAutoscalerDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAutoscalerDelete
     */
    readonly clusterId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdAutoscalerGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdAutoscalerGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdAutoscalerGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAutoscalerGet
     */
    readonly clusterId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdAutoscalerPatch operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdAutoscalerPatchRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdAutoscalerPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAutoscalerPatch
     */
    readonly clusterId: string

    /**
     * 
     * @type {ClusterAutoscaler}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAutoscalerPatch
     */
    readonly clusterAutoscaler?: ClusterAutoscaler
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdAutoscalerPost operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdAutoscalerPostRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdAutoscalerPostRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAutoscalerPost
     */
    readonly clusterId: string

    /**
     * 
     * @type {ClusterAutoscaler}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAutoscalerPost
     */
    readonly clusterAutoscaler?: ClusterAutoscaler
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdDelete operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdDeleteRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdDelete
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdDelete
     */
    readonly awsInfrastructureAccessRoleGrantId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdGet
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdGet
     */
    readonly awsInfrastructureAccessRoleGrantId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsGet
     */
    readonly clusterId: string

    /**
     * Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the AWS infrastructure access role grant instead of the names of the columns of a table. For example, in order to sort the AWS infrastructure access role grants descending by user ARN the value should be:  &#x60;&#x60;&#x60;sql user_arn desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsGet
     */
    readonly order?: string

    /**
     * Index of the requested page, where one corresponds to the first page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsGet
     */
    readonly page?: number

    /**
     * Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the AWS infrastructure access role grant instead of the names of the columns of a table. For example, in order to retrieve all the AWS infrastructure access role grants with a user ARN starting with &#x60;user&#x60; the value should be:  &#x60;&#x60;&#x60;sql user_arn like \&#39;%user\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the AWS infrastructure access role grants that the user has permission to see will be returned.
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsGet
     */
    readonly search?: string

    /**
     * Maximum number of items that will be contained in the returned page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsGet
     */
    readonly size?: number
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsPost operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsPostRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsPostRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsPost
     */
    readonly clusterId: string

    /**
     * 
     * @type {AWSInfrastructureAccessRoleGrant}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsPost
     */
    readonly aWSInfrastructureAccessRoleGrant?: AWSInfrastructureAccessRoleGrant
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationGet
     */
    readonly clusterId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsGet
     */
    readonly clusterId: string

    /**
     * Index of the requested page, where one corresponds to the first page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsGet
     */
    readonly page?: number

    /**
     * Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the role binding instead of the names of the columns of a table. For example, in order to retrieve role bindings with role_id AuthenticatedUser:  &#x60;&#x60;&#x60;sql role_id &#x3D; \&#39;AuthenticatedUser\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the items that the user has permission to see will be returned.
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsGet
     */
    readonly search?: string

    /**
     * Number of items contained in the returned page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsGet
     */
    readonly size?: number
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPost operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPostRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPostRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPost
     */
    readonly clusterId: string

    /**
     * 
     * @type {PrivateLinkPrincipal}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPost
     */
    readonly privateLinkPrincipal?: PrivateLinkPrincipal
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPrincipalIdDelete operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPrincipalIdDeleteRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPrincipalIdDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPrincipalIdDelete
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPrincipalIdDelete
     */
    readonly principalId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPrincipalIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPrincipalIdGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPrincipalIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPrincipalIdGet
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPrincipalIdGet
     */
    readonly principalId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdClusterdeploymentDelete operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdClusterdeploymentDeleteRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdClusterdeploymentDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdClusterdeploymentDelete
     */
    readonly clusterId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdDelete operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdDeleteRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdDelete
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdDelete
     */
    readonly controlPlaneUpgradePolicyId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdGet
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdGet
     */
    readonly controlPlaneUpgradePolicyId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdPatch operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdPatchRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdPatch
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdPatch
     */
    readonly controlPlaneUpgradePolicyId: string

    /**
     * 
     * @type {ControlPlaneUpgradePolicy}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdPatch
     */
    readonly controlPlaneUpgradePolicy?: ControlPlaneUpgradePolicy
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesGet
     */
    readonly clusterId: string

    /**
     * Index of the requested page, where one corresponds to the first page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesGet
     */
    readonly page?: number

    /**
     * Number of items contained in the returned page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesGet
     */
    readonly size?: number
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesPost operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesPostRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesPostRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesPost
     */
    readonly clusterId: string

    /**
     * 
     * @type {ControlPlaneUpgradePolicy}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesPost
     */
    readonly controlPlaneUpgradePolicy?: ControlPlaneUpgradePolicy
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdCredentialsGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdCredentialsGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdCredentialsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdCredentialsGet
     */
    readonly clusterId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdDelete operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdDeleteRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdDelete
     */
    readonly clusterId: string

    /**
     * If false it will only delete from OCM but not the actual cluster resources. false is only allowed for OCP clusters. true by default.
     * @type {boolean}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdDelete
     */
    readonly deprovision?: boolean

    /**
     * Dry run flag is used to check if the operation can be completed, but won\&#39;t delete.
     * @type {boolean}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdDelete
     */
    readonly dryRun?: boolean
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdDeleteProtectionGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdDeleteProtectionGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdDeleteProtectionGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdDeleteProtectionGet
     */
    readonly clusterId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdDeleteProtectionPatch operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdDeleteProtectionPatchRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdDeleteProtectionPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdDeleteProtectionPatch
     */
    readonly clusterId: string

    /**
     * 
     * @type {DeleteProtection}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdDeleteProtectionPatch
     */
    readonly deleteProtection?: DeleteProtection
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdExternalConfigurationGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationGet
     */
    readonly clusterId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsGet
     */
    readonly clusterId: string

    /**
     * Index of the requested page, where one corresponds to the first page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsGet
     */
    readonly page?: number

    /**
     * Number of items contained in the returned page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsGet
     */
    readonly size?: number
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdDelete operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdDeleteRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdDelete
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdDelete
     */
    readonly labelId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdGet
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdGet
     */
    readonly labelId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdPatch operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdPatchRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdPatch
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdPatch
     */
    readonly labelId: string

    /**
     * 
     * @type {Label}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdPatch
     */
    readonly label?: Label
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsPost operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsPostRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsPostRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsPost
     */
    readonly clusterId: string

    /**
     * 
     * @type {Label}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsPost
     */
    readonly label?: Label
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsGet
     */
    readonly clusterId: string

    /**
     * Index of the requested page, where one corresponds to the first page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsGet
     */
    readonly page?: number

    /**
     * Number of items contained in the returned page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsGet
     */
    readonly size?: number
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdDelete operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdDeleteRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdDelete
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdDelete
     */
    readonly manifestId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdGet
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdGet
     */
    readonly manifestId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdPatch operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdPatchRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdPatch
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdPatch
     */
    readonly manifestId: string

    /**
     * 
     * @type {Manifest}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdPatch
     */
    readonly manifest?: Manifest
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsPost operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsPostRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsPostRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsPost
     */
    readonly clusterId: string

    /**
     * 
     * @type {Manifest}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsPost
     */
    readonly manifest?: Manifest
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsGet
     */
    readonly clusterId: string

    /**
     * Index of the requested page, where one corresponds to the first page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsGet
     */
    readonly page?: number

    /**
     * Number of items contained in the returned page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsGet
     */
    readonly size?: number
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsPost operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsPostRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsPostRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsPost
     */
    readonly clusterId: string

    /**
     * 
     * @type {Syncset}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsPost
     */
    readonly syncset?: Syncset
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdDelete operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdDeleteRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdDelete
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdDelete
     */
    readonly syncsetId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdGet
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdGet
     */
    readonly syncsetId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdPatch operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdPatchRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdPatch
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdPatch
     */
    readonly syncsetId: string

    /**
     * 
     * @type {Syncset}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdPatch
     */
    readonly syncset?: Syncset
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdGateAgreementsGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdGateAgreementsGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdGateAgreementsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdGateAgreementsGet
     */
    readonly clusterId: string

    /**
     * Index of the requested page, where one corresponds to the first page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdGateAgreementsGet
     */
    readonly page?: number

    /**
     * Number of items contained in the returned page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdGateAgreementsGet
     */
    readonly size?: number
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdGateAgreementsPost operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdGateAgreementsPostRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdGateAgreementsPostRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdGateAgreementsPost
     */
    readonly clusterId: string

    /**
     * 
     * @type {VersionGateAgreement}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdGateAgreementsPost
     */
    readonly versionGateAgreement?: VersionGateAgreement
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdDelete operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdDeleteRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdDelete
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdDelete
     */
    readonly versionGateAgreementId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdGet
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdGet
     */
    readonly versionGateAgreementId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdGet
     */
    readonly clusterId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdGroupsGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGet
     */
    readonly clusterId: string

    /**
     * Index of the requested page, where one corresponds to the first page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGet
     */
    readonly page?: number

    /**
     * Number of items contained in the returned page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGet
     */
    readonly size?: number
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdGroupsGroupIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGroupIdGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGroupIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGroupIdGet
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGroupIdGet
     */
    readonly groupId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersGet
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersGet
     */
    readonly groupId: string

    /**
     * Index of the requested page, where one corresponds to the first page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersGet
     */
    readonly page?: number

    /**
     * Number of items contained in the returned page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersGet
     */
    readonly size?: number
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersPost operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersPostRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersPostRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersPost
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersPost
     */
    readonly groupId: string

    /**
     * 
     * @type {User}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersPost
     */
    readonly user?: User
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdDelete operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdDeleteRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdDelete
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdDelete
     */
    readonly groupId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdDelete
     */
    readonly userId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdGet
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdGet
     */
    readonly groupId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdGet
     */
    readonly userId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdHibernatePost operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdHibernatePostRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdHibernatePostRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdHibernatePost
     */
    readonly clusterId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdHypershiftGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdHypershiftGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdHypershiftGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdHypershiftGet
     */
    readonly clusterId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdIdentityProvidersGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersGet
     */
    readonly clusterId: string

    /**
     * Index of the requested page, where one corresponds to the first page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersGet
     */
    readonly page?: number

    /**
     * Number of items contained in the returned page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersGet
     */
    readonly size?: number
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdDelete operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdDeleteRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdDelete
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdDelete
     */
    readonly identityProviderId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdGet
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdGet
     */
    readonly identityProviderId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersGet
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersGet
     */
    readonly identityProviderId: string

    /**
     * Index of the requested page, where one corresponds to the first page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersGet
     */
    readonly page?: number

    /**
     * Number of items contained in the returned page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersGet
     */
    readonly size?: number
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdDelete operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdDeleteRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdDelete
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdDelete
     */
    readonly identityProviderId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdDelete
     */
    readonly htpasswdUserId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdGet
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdGet
     */
    readonly identityProviderId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdGet
     */
    readonly htpasswdUserId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdPatch operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdPatchRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdPatch
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdPatch
     */
    readonly identityProviderId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdPatch
     */
    readonly htpasswdUserId: string

    /**
     * 
     * @type {HTPasswdUser}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdPatch
     */
    readonly hTPasswdUser?: HTPasswdUser
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersImportPost operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersImportPostRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersImportPostRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersImportPost
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersImportPost
     */
    readonly identityProviderId: string

    /**
     * 
     * @type {ApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersImportPostRequest}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersImportPost
     */
    readonly apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersImportPostRequest?: ApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersImportPostRequest
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersPost operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersPostRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersPostRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersPost
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersPost
     */
    readonly identityProviderId: string

    /**
     * 
     * @type {HTPasswdUser}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersPost
     */
    readonly hTPasswdUser?: HTPasswdUser
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdPatch operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdPatchRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdPatch
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdPatch
     */
    readonly identityProviderId: string

    /**
     * 
     * @type {IdentityProvider}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdPatch
     */
    readonly identityProvider?: IdentityProvider
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdIdentityProvidersPost operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersPostRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersPostRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersPost
     */
    readonly clusterId: string

    /**
     * 
     * @type {IdentityProvider}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersPost
     */
    readonly identityProvider?: IdentityProvider
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdInflightChecksGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdInflightChecksGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdInflightChecksGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdInflightChecksGet
     */
    readonly clusterId: string

    /**
     * Index of the requested page, where one corresponds to the first page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdInflightChecksGet
     */
    readonly page?: number

    /**
     * Number of items contained in the returned page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdInflightChecksGet
     */
    readonly size?: number
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdInflightChecksInflightCheckIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdInflightChecksInflightCheckIdGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdInflightChecksInflightCheckIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdInflightChecksInflightCheckIdGet
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdInflightChecksInflightCheckIdGet
     */
    readonly inflightCheckId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdIngressesGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesGet
     */
    readonly clusterId: string

    /**
     * Index of the requested page, where one corresponds to the first page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesGet
     */
    readonly page?: number

    /**
     * Number of items contained in the returned page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesGet
     */
    readonly size?: number
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdIngressesIngressIdDelete operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesIngressIdDeleteRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesIngressIdDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesIngressIdDelete
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesIngressIdDelete
     */
    readonly ingressId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdIngressesIngressIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesIngressIdGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesIngressIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesIngressIdGet
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesIngressIdGet
     */
    readonly ingressId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdIngressesIngressIdPatch operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesIngressIdPatchRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesIngressIdPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesIngressIdPatch
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesIngressIdPatch
     */
    readonly ingressId: string

    /**
     * 
     * @type {Ingress}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesIngressIdPatch
     */
    readonly ingress?: Ingress
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdIngressesPatch operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesPatchRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesPatch
     */
    readonly clusterId: string

    /**
     * 
     * @type {Array<Ingress>}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesPatch
     */
    readonly ingress?: Array<Ingress>
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdIngressesPost operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesPostRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesPostRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesPost
     */
    readonly clusterId: string

    /**
     * 
     * @type {Ingress}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesPost
     */
    readonly ingress?: Ingress
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsGet
     */
    readonly clusterId: string

    /**
     * Index of the requested page, where one corresponds to the first page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsGet
     */
    readonly page?: number

    /**
     * Number of items contained in the returned page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsGet
     */
    readonly size?: number
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdDelete operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdDeleteRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdDelete
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdDelete
     */
    readonly limitedSupportReasonId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdGet
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdGet
     */
    readonly limitedSupportReasonId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsPost operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsPostRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsPostRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsPost
     */
    readonly clusterId: string

    /**
     * 
     * @type {LimitedSupportReason}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsPost
     */
    readonly limitedSupportReason?: LimitedSupportReason
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdLogsGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdLogsGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdLogsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdLogsGet
     */
    readonly clusterId: string

    /**
     * Index of the requested page, where one corresponds to the first page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdLogsGet
     */
    readonly page?: number

    /**
     * Number of items contained in the returned page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdLogsGet
     */
    readonly size?: number
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdLogsInstallGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdLogsInstallGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdLogsInstallGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdLogsInstallGet
     */
    readonly clusterId: string

    /**
     * Line offset to start logs from. if 0 retreive entire log. If offset &gt; #lines return an empty log.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdLogsInstallGet
     */
    readonly offset?: number

    /**
     * Returns the number of tail lines from the end of the log. If there are no line breaks or the number of lines &lt; tail return the entire log. Either \&#39;tail\&#39; or \&#39;offset\&#39; can be set. Not both. 
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdLogsInstallGet
     */
    readonly tail?: number
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdLogsUninstallGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdLogsUninstallGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdLogsUninstallGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdLogsUninstallGet
     */
    readonly clusterId: string

    /**
     * Line offset to start logs from. if 0 retreive entire log. If offset &gt; #lines return an empty log.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdLogsUninstallGet
     */
    readonly offset?: number

    /**
     * Returns the number of tail lines from the end of the log. If there are no line breaks or the number of lines &lt; tail return the entire log. Either \&#39;tail\&#39; or \&#39;offset\&#39; can be set. Not both. 
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdLogsUninstallGet
     */
    readonly tail?: number
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdMachinePoolsGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdMachinePoolsGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdMachinePoolsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdMachinePoolsGet
     */
    readonly clusterId: string

    /**
     * Index of the requested page, where one corresponds to the first page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdMachinePoolsGet
     */
    readonly page?: number

    /**
     * Number of items contained in the returned page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdMachinePoolsGet
     */
    readonly size?: number
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdDelete operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdDeleteRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdDelete
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdDelete
     */
    readonly machinePoolId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdGet
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdGet
     */
    readonly machinePoolId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdPatch operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdPatchRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdPatch
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdPatch
     */
    readonly machinePoolId: string

    /**
     * 
     * @type {MachinePool}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdPatch
     */
    readonly machinePool?: MachinePool
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdMachinePoolsPost operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdMachinePoolsPostRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdMachinePoolsPostRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdMachinePoolsPost
     */
    readonly clusterId: string

    /**
     * 
     * @type {MachinePool}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdMachinePoolsPost
     */
    readonly machinePool?: MachinePool
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdMetricQueriesAlertsGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdMetricQueriesAlertsGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdMetricQueriesAlertsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdMetricQueriesAlertsGet
     */
    readonly clusterId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdMetricQueriesClusterOperatorsGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdMetricQueriesClusterOperatorsGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdMetricQueriesClusterOperatorsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdMetricQueriesClusterOperatorsGet
     */
    readonly clusterId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdMetricQueriesCpuTotalByNodeRolesOsGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdMetricQueriesCpuTotalByNodeRolesOsGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdMetricQueriesCpuTotalByNodeRolesOsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdMetricQueriesCpuTotalByNodeRolesOsGet
     */
    readonly clusterId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdMetricQueriesNodesGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdMetricQueriesNodesGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdMetricQueriesNodesGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdMetricQueriesNodesGet
     */
    readonly clusterId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdMetricQueriesSocketTotalByNodeRolesOsGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdMetricQueriesSocketTotalByNodeRolesOsGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdMetricQueriesSocketTotalByNodeRolesOsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdMetricQueriesSocketTotalByNodeRolesOsGet
     */
    readonly clusterId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdNodePoolsGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsGet
     */
    readonly clusterId: string

    /**
     * Index of the requested page, where one corresponds to the first page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsGet
     */
    readonly page?: number

    /**
     * Number of items contained in the returned page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsGet
     */
    readonly size?: number
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdDelete operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdDeleteRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdDelete
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdDelete
     */
    readonly nodePoolId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdGet
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdGet
     */
    readonly nodePoolId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdPatch operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdPatchRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdPatch
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdPatch
     */
    readonly nodePoolId: string

    /**
     * 
     * @type {NodePool}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdPatch
     */
    readonly nodePool?: NodePool
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesGet
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesGet
     */
    readonly nodePoolId: string

    /**
     * Index of the requested page, where one corresponds to the first page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesGet
     */
    readonly page?: number

    /**
     * Number of items contained in the returned page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesGet
     */
    readonly size?: number
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdDelete operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdDeleteRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdDelete
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdDelete
     */
    readonly nodePoolId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdDelete
     */
    readonly nodePoolUpgradePolicyId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdGet
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdGet
     */
    readonly nodePoolId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdGet
     */
    readonly nodePoolUpgradePolicyId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdPatch operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdPatchRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdPatch
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdPatch
     */
    readonly nodePoolId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdPatch
     */
    readonly nodePoolUpgradePolicyId: string

    /**
     * 
     * @type {NodePoolUpgradePolicy}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdPatch
     */
    readonly nodePoolUpgradePolicy?: NodePoolUpgradePolicy
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesPost operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesPostRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesPostRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesPost
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesPost
     */
    readonly nodePoolId: string

    /**
     * 
     * @type {NodePoolUpgradePolicy}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesPost
     */
    readonly nodePoolUpgradePolicy?: NodePoolUpgradePolicy
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdNodePoolsPost operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsPostRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsPostRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsPost
     */
    readonly clusterId: string

    /**
     * 
     * @type {NodePool}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsPost
     */
    readonly nodePool?: NodePool
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdPatch operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdPatchRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdPatch
     */
    readonly clusterId: string

    /**
     * 
     * @type {Cluster}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdPatch
     */
    readonly cluster?: Cluster
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdProductGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdProductGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdProductGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdProductGet
     */
    readonly clusterId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdProvisionShardDelete operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdProvisionShardDeleteRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdProvisionShardDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdProvisionShardDelete
     */
    readonly clusterId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdProvisionShardGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdProvisionShardGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdProvisionShardGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdProvisionShardGet
     */
    readonly clusterId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdProvisionShardPatch operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdProvisionShardPatchRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdProvisionShardPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdProvisionShardPatch
     */
    readonly clusterId: string

    /**
     * 
     * @type {ProvisionShard}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdProvisionShardPatch
     */
    readonly provisionShard?: ProvisionShard
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdResourcesGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdResourcesGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdResourcesGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdResourcesGet
     */
    readonly clusterId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdResourcesLiveGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdResourcesLiveGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdResourcesLiveGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdResourcesLiveGet
     */
    readonly clusterId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdResumePost operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdResumePostRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdResumePostRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdResumePost
     */
    readonly clusterId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdStatusGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdStatusGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdStatusGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdStatusGet
     */
    readonly clusterId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdStsOperatorRolesGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdStsOperatorRolesGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdStsOperatorRolesGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdStsOperatorRolesGet
     */
    readonly clusterId: string

    /**
     * Index of the requested page, where one corresponds to the first page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdStsOperatorRolesGet
     */
    readonly page?: number

    /**
     * Number of items that will be contained in the returned page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdStsOperatorRolesGet
     */
    readonly size?: number
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdStsOperatorRolesOperatorIamRoleIdDelete operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdStsOperatorRolesOperatorIamRoleIdDeleteRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdStsOperatorRolesOperatorIamRoleIdDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdStsOperatorRolesOperatorIamRoleIdDelete
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdStsOperatorRolesOperatorIamRoleIdDelete
     */
    readonly operatorIamRoleId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdStsOperatorRolesPost operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdStsOperatorRolesPostRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdStsOperatorRolesPostRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdStsOperatorRolesPost
     */
    readonly clusterId: string

    /**
     * 
     * @type {OperatorIAMRole}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdStsOperatorRolesPost
     */
    readonly operatorIAMRole?: OperatorIAMRole
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdStsSupportJumpRoleGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdStsSupportJumpRoleGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdStsSupportJumpRoleGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdStsSupportJumpRoleGet
     */
    readonly clusterId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdTuningConfigsGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdTuningConfigsGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdTuningConfigsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdTuningConfigsGet
     */
    readonly clusterId: string

    /**
     * Index of the requested page, where one corresponds to the first page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdTuningConfigsGet
     */
    readonly page?: number

    /**
     * Number of items contained in the returned page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdTuningConfigsGet
     */
    readonly size?: number
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdTuningConfigsPost operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdTuningConfigsPostRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdTuningConfigsPostRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdTuningConfigsPost
     */
    readonly clusterId: string

    /**
     * 
     * @type {TuningConfig}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdTuningConfigsPost
     */
    readonly tuningConfig?: TuningConfig
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdDelete operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdDeleteRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdDelete
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdDelete
     */
    readonly tuningConfigId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdGet
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdGet
     */
    readonly tuningConfigId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdPatch operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdPatchRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdPatch
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdPatch
     */
    readonly tuningConfigId: string

    /**
     * 
     * @type {TuningConfig}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdPatch
     */
    readonly tuningConfig?: TuningConfig
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdUpgradePoliciesGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesGet
     */
    readonly clusterId: string

    /**
     * Index of the requested page, where one corresponds to the first page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesGet
     */
    readonly page?: number

    /**
     * Number of items contained in the returned page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesGet
     */
    readonly size?: number
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdUpgradePoliciesPost operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesPostRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesPostRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesPost
     */
    readonly clusterId: string

    /**
     * 
     * @type {UpgradePolicy}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesPost
     */
    readonly upgradePolicy?: UpgradePolicy
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdDelete operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdDeleteRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdDelete
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdDelete
     */
    readonly upgradePolicyId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdGet
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdGet
     */
    readonly upgradePolicyId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdPatch operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdPatchRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdPatch
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdPatch
     */
    readonly upgradePolicyId: string

    /**
     * 
     * @type {UpgradePolicy}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdPatch
     */
    readonly upgradePolicy?: UpgradePolicy
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStateGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStateGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStateGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStateGet
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStateGet
     */
    readonly upgradePolicyId: string
}

/**
 * Request parameters for apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStatePatch operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStatePatchRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStatePatchRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStatePatch
     */
    readonly clusterId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStatePatch
     */
    readonly upgradePolicyId: string

    /**
     * 
     * @type {UpgradePolicyState}
     * @memberof DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStatePatch
     */
    readonly upgradePolicyState?: UpgradePolicyState
}

/**
 * Request parameters for apiClustersMgmtV1ClustersGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersGetRequest {
    /**
     * Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the cluster instead of the names of the columns of a table. For example, in order to sort the clusters descending by region identifier the value should be:  &#x60;&#x60;&#x60;sql region.id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersGet
     */
    readonly order?: string

    /**
     * Index of the requested page, where one corresponds to the first page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersGet
     */
    readonly page?: number

    /**
     * Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the cluster instead of the names of the columns of a table. For example, in order to retrieve all the clusters with a name starting with &#x60;my&#x60; in the &#x60;us-east-1&#x60; region the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; and region.id &#x3D; \&#39;us-east-1\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the clusters that the user has permission to see will be returned.
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ClustersGet
     */
    readonly search?: string

    /**
     * Maximum number of items that will be contained in the returned page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ClustersGet
     */
    readonly size?: number
}

/**
 * Request parameters for apiClustersMgmtV1ClustersPost operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ClustersPostRequest
 */
export interface DefaultApiApiClustersMgmtV1ClustersPostRequest {
    /**
     * 
     * @type {Cluster}
     * @memberof DefaultApiApiClustersMgmtV1ClustersPost
     */
    readonly cluster?: Cluster
}

/**
 * Request parameters for apiClustersMgmtV1DnsDomainsDnsDomainIdDelete operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1DnsDomainsDnsDomainIdDeleteRequest
 */
export interface DefaultApiApiClustersMgmtV1DnsDomainsDnsDomainIdDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1DnsDomainsDnsDomainIdDelete
     */
    readonly dnsDomainId: string
}

/**
 * Request parameters for apiClustersMgmtV1DnsDomainsDnsDomainIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1DnsDomainsDnsDomainIdGetRequest
 */
export interface DefaultApiApiClustersMgmtV1DnsDomainsDnsDomainIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1DnsDomainsDnsDomainIdGet
     */
    readonly dnsDomainId: string
}

/**
 * Request parameters for apiClustersMgmtV1DnsDomainsDnsDomainIdPatch operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1DnsDomainsDnsDomainIdPatchRequest
 */
export interface DefaultApiApiClustersMgmtV1DnsDomainsDnsDomainIdPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1DnsDomainsDnsDomainIdPatch
     */
    readonly dnsDomainId: string

    /**
     * 
     * @type {DNSDomain}
     * @memberof DefaultApiApiClustersMgmtV1DnsDomainsDnsDomainIdPatch
     */
    readonly dNSDomain?: DNSDomain
}

/**
 * Request parameters for apiClustersMgmtV1DnsDomainsGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1DnsDomainsGetRequest
 */
export interface DefaultApiApiClustersMgmtV1DnsDomainsGetRequest {
    /**
     * Index of the requested page, where one corresponds to the first page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1DnsDomainsGet
     */
    readonly page?: number

    /**
     * Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the dns domain instead of the names of the columns of a table. For example, in order to retrieve all the dns domains with a ID starting with &#x60;02a5&#x60; should be:  &#x60;&#x60;&#x60;sql id like \&#39;02a5%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the dns domains that the user has permission to see will be returned.
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1DnsDomainsGet
     */
    readonly search?: string

    /**
     * Maximum number of items that will be contained in the returned page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1DnsDomainsGet
     */
    readonly size?: number
}

/**
 * Request parameters for apiClustersMgmtV1DnsDomainsPost operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1DnsDomainsPostRequest
 */
export interface DefaultApiApiClustersMgmtV1DnsDomainsPostRequest {
    /**
     * 
     * @type {DNSDomain}
     * @memberof DefaultApiApiClustersMgmtV1DnsDomainsPost
     */
    readonly dNSDomain?: DNSDomain
}

/**
 * Request parameters for apiClustersMgmtV1EnvironmentPatch operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1EnvironmentPatchRequest
 */
export interface DefaultApiApiClustersMgmtV1EnvironmentPatchRequest {
    /**
     * 
     * @type {Environment}
     * @memberof DefaultApiApiClustersMgmtV1EnvironmentPatch
     */
    readonly environment?: Environment
}

/**
 * Request parameters for apiClustersMgmtV1EventsPost operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1EventsPostRequest
 */
export interface DefaultApiApiClustersMgmtV1EventsPostRequest {
    /**
     * 
     * @type {Event}
     * @memberof DefaultApiApiClustersMgmtV1EventsPost
     */
    readonly event?: Event
}

/**
 * Request parameters for apiClustersMgmtV1FlavoursFlavourIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1FlavoursFlavourIdGetRequest
 */
export interface DefaultApiApiClustersMgmtV1FlavoursFlavourIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1FlavoursFlavourIdGet
     */
    readonly flavourId: string
}

/**
 * Request parameters for apiClustersMgmtV1FlavoursFlavourIdPatch operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1FlavoursFlavourIdPatchRequest
 */
export interface DefaultApiApiClustersMgmtV1FlavoursFlavourIdPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1FlavoursFlavourIdPatch
     */
    readonly flavourId: string

    /**
     * 
     * @type {Flavour}
     * @memberof DefaultApiApiClustersMgmtV1FlavoursFlavourIdPatch
     */
    readonly flavour?: Flavour
}

/**
 * Request parameters for apiClustersMgmtV1FlavoursGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1FlavoursGetRequest
 */
export interface DefaultApiApiClustersMgmtV1FlavoursGetRequest {
    /**
     * Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the flavour instead of the names of the columns of a table. For example, in order to sort the flavours descending by name the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1FlavoursGet
     */
    readonly order?: string

    /**
     * Index of the requested page, where one corresponds to the first page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1FlavoursGet
     */
    readonly page?: number

    /**
     * Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the flavour instead of the names of the columns of a table. For example, in order to retrieve all the flavours with a name starting with &#x60;my&#x60;the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the flavours that the user has permission to see will be returned.
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1FlavoursGet
     */
    readonly search?: string

    /**
     * Maximum number of items that will be contained in the returned page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1FlavoursGet
     */
    readonly size?: number
}

/**
 * Request parameters for apiClustersMgmtV1FlavoursPost operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1FlavoursPostRequest
 */
export interface DefaultApiApiClustersMgmtV1FlavoursPostRequest {
    /**
     * 
     * @type {Flavour}
     * @memberof DefaultApiApiClustersMgmtV1FlavoursPost
     */
    readonly flavour?: Flavour
}

/**
 * Request parameters for apiClustersMgmtV1GcpInquiriesEncryptionKeysPost operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1GcpInquiriesEncryptionKeysPostRequest
 */
export interface DefaultApiApiClustersMgmtV1GcpInquiriesEncryptionKeysPostRequest {
    /**
     * Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1GcpInquiriesEncryptionKeysPost
     */
    readonly page?: number

    /**
     * Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1GcpInquiriesEncryptionKeysPost
     */
    readonly size?: number

    /**
     * 
     * @type {CloudProviderData}
     * @memberof DefaultApiApiClustersMgmtV1GcpInquiriesEncryptionKeysPost
     */
    readonly cloudProviderData?: CloudProviderData
}

/**
 * Request parameters for apiClustersMgmtV1GcpInquiriesKeyRingsPost operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1GcpInquiriesKeyRingsPostRequest
 */
export interface DefaultApiApiClustersMgmtV1GcpInquiriesKeyRingsPostRequest {
    /**
     * Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1GcpInquiriesKeyRingsPost
     */
    readonly page?: number

    /**
     * Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of key rings of the provider.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1GcpInquiriesKeyRingsPost
     */
    readonly size?: number

    /**
     * 
     * @type {CloudProviderData}
     * @memberof DefaultApiApiClustersMgmtV1GcpInquiriesKeyRingsPost
     */
    readonly cloudProviderData?: CloudProviderData
}

/**
 * Request parameters for apiClustersMgmtV1GcpInquiriesRegionsPost operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1GcpInquiriesRegionsPostRequest
 */
export interface DefaultApiApiClustersMgmtV1GcpInquiriesRegionsPostRequest {
    /**
     * Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1GcpInquiriesRegionsPost
     */
    readonly page?: number

    /**
     * Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of regions of the provider.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1GcpInquiriesRegionsPost
     */
    readonly size?: number

    /**
     * 
     * @type {CloudProviderData}
     * @memberof DefaultApiApiClustersMgmtV1GcpInquiriesRegionsPost
     */
    readonly cloudProviderData?: CloudProviderData
}

/**
 * Request parameters for apiClustersMgmtV1GcpInquiriesVpcsPost operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1GcpInquiriesVpcsPostRequest
 */
export interface DefaultApiApiClustersMgmtV1GcpInquiriesVpcsPostRequest {
    /**
     * Index of the returned page, where one corresponds to the first page. As this collection doesn\&#39;t support paging the result will always be &#x60;1&#x60;.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1GcpInquiriesVpcsPost
     */
    readonly page?: number

    /**
     * Number of items that will be contained in the returned page. As this collection doesn\&#39;t support paging or searching the result will always be the total number of vpcs of the provider.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1GcpInquiriesVpcsPost
     */
    readonly size?: number

    /**
     * 
     * @type {CloudProviderData}
     * @memberof DefaultApiApiClustersMgmtV1GcpInquiriesVpcsPost
     */
    readonly cloudProviderData?: CloudProviderData
}

/**
 * Request parameters for apiClustersMgmtV1LimitedSupportReasonTemplatesGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1LimitedSupportReasonTemplatesGetRequest
 */
export interface DefaultApiApiClustersMgmtV1LimitedSupportReasonTemplatesGetRequest {
    /**
     * Index of the requested page, where one corresponds to the first page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1LimitedSupportReasonTemplatesGet
     */
    readonly page?: number

    /**
     * Number of items contained in the returned page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1LimitedSupportReasonTemplatesGet
     */
    readonly size?: number
}

/**
 * Request parameters for apiClustersMgmtV1LimitedSupportReasonTemplatesLimitedSupportReasonTemplateIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1LimitedSupportReasonTemplatesLimitedSupportReasonTemplateIdGetRequest
 */
export interface DefaultApiApiClustersMgmtV1LimitedSupportReasonTemplatesLimitedSupportReasonTemplateIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1LimitedSupportReasonTemplatesLimitedSupportReasonTemplateIdGet
     */
    readonly limitedSupportReasonTemplateId: string
}

/**
 * Request parameters for apiClustersMgmtV1MachineTypesGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1MachineTypesGetRequest
 */
export interface DefaultApiApiClustersMgmtV1MachineTypesGetRequest {
    /**
     * Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the machine type instead of the names of the columns of a table. For example, in order to sort the machine types descending by name identifier the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1MachineTypesGet
     */
    readonly order?: string

    /**
     * Index of the requested page, where one corresponds to the first page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1MachineTypesGet
     */
    readonly page?: number

    /**
     * Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the machine type instead of the names of the columns of a table. For example, in order to retrieve all the machine types with a name starting with &#x60;A&#x60; the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;A%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the machine types that the user has permission to see will be returned.
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1MachineTypesGet
     */
    readonly search?: string

    /**
     * Maximum number of items that will be contained in the returned page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1MachineTypesGet
     */
    readonly size?: number
}

/**
 * Request parameters for apiClustersMgmtV1MachineTypesMachineTypeIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1MachineTypesMachineTypeIdGetRequest
 */
export interface DefaultApiApiClustersMgmtV1MachineTypesMachineTypeIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1MachineTypesMachineTypeIdGet
     */
    readonly machineTypeId: string
}

/**
 * Request parameters for apiClustersMgmtV1NetworkVerificationsNetworkVerificationIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1NetworkVerificationsNetworkVerificationIdGetRequest
 */
export interface DefaultApiApiClustersMgmtV1NetworkVerificationsNetworkVerificationIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1NetworkVerificationsNetworkVerificationIdGet
     */
    readonly networkVerificationId: string
}

/**
 * Request parameters for apiClustersMgmtV1NetworkVerificationsPost operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1NetworkVerificationsPostRequest
 */
export interface DefaultApiApiClustersMgmtV1NetworkVerificationsPostRequest {
    /**
     * 
     * @type {NetworkVerification}
     * @memberof DefaultApiApiClustersMgmtV1NetworkVerificationsPost
     */
    readonly networkVerification?: NetworkVerification
}

/**
 * Request parameters for apiClustersMgmtV1OidcConfigsGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1OidcConfigsGetRequest
 */
export interface DefaultApiApiClustersMgmtV1OidcConfigsGetRequest {
    /**
     * Index of the requested page, where one corresponds to the first page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1OidcConfigsGet
     */
    readonly page?: number

    /**
     * Number of items contained in the returned page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1OidcConfigsGet
     */
    readonly size?: number
}

/**
 * Request parameters for apiClustersMgmtV1OidcConfigsOidcConfigIdDelete operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1OidcConfigsOidcConfigIdDeleteRequest
 */
export interface DefaultApiApiClustersMgmtV1OidcConfigsOidcConfigIdDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1OidcConfigsOidcConfigIdDelete
     */
    readonly oidcConfigId: string
}

/**
 * Request parameters for apiClustersMgmtV1OidcConfigsOidcConfigIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1OidcConfigsOidcConfigIdGetRequest
 */
export interface DefaultApiApiClustersMgmtV1OidcConfigsOidcConfigIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1OidcConfigsOidcConfigIdGet
     */
    readonly oidcConfigId: string
}

/**
 * Request parameters for apiClustersMgmtV1OidcConfigsOidcConfigIdPatch operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1OidcConfigsOidcConfigIdPatchRequest
 */
export interface DefaultApiApiClustersMgmtV1OidcConfigsOidcConfigIdPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1OidcConfigsOidcConfigIdPatch
     */
    readonly oidcConfigId: string

    /**
     * 
     * @type {OidcConfig}
     * @memberof DefaultApiApiClustersMgmtV1OidcConfigsOidcConfigIdPatch
     */
    readonly oidcConfig?: OidcConfig
}

/**
 * Request parameters for apiClustersMgmtV1OidcConfigsPost operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1OidcConfigsPostRequest
 */
export interface DefaultApiApiClustersMgmtV1OidcConfigsPostRequest {
    /**
     * 
     * @type {OidcConfig}
     * @memberof DefaultApiApiClustersMgmtV1OidcConfigsPost
     */
    readonly oidcConfig?: OidcConfig
}

/**
 * Request parameters for apiClustersMgmtV1PendingDeleteClustersGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1PendingDeleteClustersGetRequest
 */
export interface DefaultApiApiClustersMgmtV1PendingDeleteClustersGetRequest {
    /**
     * Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the pending delete cluster instead of the names of the columns of a table. For example, in order to sort the pending delete clusters descending by creation timestamp (i.e. their deletion time) the value should be:  &#x60;&#x60;&#x60;sql creation_timestamp desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1PendingDeleteClustersGet
     */
    readonly order?: string

    /**
     * Index of the requested page, where one corresponds to the first page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1PendingDeleteClustersGet
     */
    readonly page?: number

    /**
     * Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the pending delete cluster instead of the names of the columns of a table. For example, in order to retrieve all the pending delete clusters with creation time later than 2023-03-01T00:00:00Z the following is required:  &#x60;&#x60;&#x60;sql creation_timestamp &gt; \&#39;2023-03-01T00:00:00Z\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the pending delete clusters that the user has permission to see will be returned.
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1PendingDeleteClustersGet
     */
    readonly search?: string

    /**
     * Maximum number of items that will be contained in the returned page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1PendingDeleteClustersGet
     */
    readonly size?: number
}

/**
 * Request parameters for apiClustersMgmtV1PendingDeleteClustersPendingDeleteClusterIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1PendingDeleteClustersPendingDeleteClusterIdGetRequest
 */
export interface DefaultApiApiClustersMgmtV1PendingDeleteClustersPendingDeleteClusterIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1PendingDeleteClustersPendingDeleteClusterIdGet
     */
    readonly pendingDeleteClusterId: string
}

/**
 * Request parameters for apiClustersMgmtV1PendingDeleteClustersPendingDeleteClusterIdPatch operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1PendingDeleteClustersPendingDeleteClusterIdPatchRequest
 */
export interface DefaultApiApiClustersMgmtV1PendingDeleteClustersPendingDeleteClusterIdPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1PendingDeleteClustersPendingDeleteClusterIdPatch
     */
    readonly pendingDeleteClusterId: string

    /**
     * 
     * @type {PendingDeleteCluster}
     * @memberof DefaultApiApiClustersMgmtV1PendingDeleteClustersPendingDeleteClusterIdPatch
     */
    readonly pendingDeleteCluster?: PendingDeleteCluster
}

/**
 * Request parameters for apiClustersMgmtV1ProductsGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ProductsGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ProductsGetRequest {
    /**
     * Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the product instead of the names of the columns of a table. For example, in order to sort the products descending by name the value should be:  &#x60;&#x60;&#x60;sql name desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ProductsGet
     */
    readonly order?: string

    /**
     * Index of the requested page, where one corresponds to the first page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ProductsGet
     */
    readonly page?: number

    /**
     * Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the product instead of the names of the columns of a table. For example, in order to retrieve all the products with a name starting with &#x60;my&#x60; the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the products that the user has permission to see will be returned.
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ProductsGet
     */
    readonly search?: string

    /**
     * Maximum number of items that will be contained in the returned page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ProductsGet
     */
    readonly size?: number
}

/**
 * Request parameters for apiClustersMgmtV1ProductsProductIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ProductsProductIdGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ProductsProductIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ProductsProductIdGet
     */
    readonly productId: string
}

/**
 * Request parameters for apiClustersMgmtV1ProvisionShardsGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ProvisionShardsGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ProvisionShardsGetRequest {
    /**
     * Index of the requested page, where one corresponds to the first page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ProvisionShardsGet
     */
    readonly page?: number

    /**
     * Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the cluster instead of the names of the columns of a table. For example, in order to retrieve all the clusters with a name starting with &#x60;my&#x60; in the &#x60;us-east-1&#x60; region the value should be:  &#x60;&#x60;&#x60;sql name like \&#39;my%\&#39; and region.id &#x3D; \&#39;us-east-1\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the provision shards that the user has permission to see will be returned.
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ProvisionShardsGet
     */
    readonly search?: string

    /**
     * Maximum number of items that will be contained in the returned page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1ProvisionShardsGet
     */
    readonly size?: number
}

/**
 * Request parameters for apiClustersMgmtV1ProvisionShardsPost operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ProvisionShardsPostRequest
 */
export interface DefaultApiApiClustersMgmtV1ProvisionShardsPostRequest {
    /**
     * 
     * @type {ProvisionShard}
     * @memberof DefaultApiApiClustersMgmtV1ProvisionShardsPost
     */
    readonly provisionShard?: ProvisionShard
}

/**
 * Request parameters for apiClustersMgmtV1ProvisionShardsProvisionShardIdDelete operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ProvisionShardsProvisionShardIdDeleteRequest
 */
export interface DefaultApiApiClustersMgmtV1ProvisionShardsProvisionShardIdDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ProvisionShardsProvisionShardIdDelete
     */
    readonly provisionShardId: string
}

/**
 * Request parameters for apiClustersMgmtV1ProvisionShardsProvisionShardIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ProvisionShardsProvisionShardIdGetRequest
 */
export interface DefaultApiApiClustersMgmtV1ProvisionShardsProvisionShardIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ProvisionShardsProvisionShardIdGet
     */
    readonly provisionShardId: string
}

/**
 * Request parameters for apiClustersMgmtV1ProvisionShardsProvisionShardIdPatch operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1ProvisionShardsProvisionShardIdPatchRequest
 */
export interface DefaultApiApiClustersMgmtV1ProvisionShardsProvisionShardIdPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1ProvisionShardsProvisionShardIdPatch
     */
    readonly provisionShardId: string

    /**
     * 
     * @type {ProvisionShard}
     * @memberof DefaultApiApiClustersMgmtV1ProvisionShardsProvisionShardIdPatch
     */
    readonly provisionShard?: ProvisionShard
}

/**
 * Request parameters for apiClustersMgmtV1TrustedIpAddressesGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1TrustedIpAddressesGetRequest
 */
export interface DefaultApiApiClustersMgmtV1TrustedIpAddressesGetRequest {
    /**
     * Index of the requested page, where one corresponds to the first page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1TrustedIpAddressesGet
     */
    readonly page?: number

    /**
     * Number of items contained in the returned page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1TrustedIpAddressesGet
     */
    readonly size?: number
}

/**
 * Request parameters for apiClustersMgmtV1TrustedIpAddressesTrustedIpIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1TrustedIpAddressesTrustedIpIdGetRequest
 */
export interface DefaultApiApiClustersMgmtV1TrustedIpAddressesTrustedIpIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1TrustedIpAddressesTrustedIpIdGet
     */
    readonly trustedIpId: string
}

/**
 * Request parameters for apiClustersMgmtV1VersionGatesGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1VersionGatesGetRequest
 */
export interface DefaultApiApiClustersMgmtV1VersionGatesGetRequest {
    /**
     * Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of an SQL statement, but using the names of the attributes of the version gate instead of the names of the columns of a table. For example, in order to sort the version gates descending by identifier the value should be:  &#x60;&#x60;&#x60;sql id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1VersionGatesGet
     */
    readonly order?: string

    /**
     * Index of the requested page, where one corresponds to the first page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1VersionGatesGet
     */
    readonly page?: number

    /**
     * Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of an SQL statement, but using the names of the attributes of the version gate instead of the names of the columns of a table.  If the parameter isn\&#39;t provided, or if the value is empty, then all the version gates that the user has permission to see will be returned.
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1VersionGatesGet
     */
    readonly search?: string

    /**
     * Maximum number of items that will be contained in the returned page.  Default value is &#x60;100&#x60;.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1VersionGatesGet
     */
    readonly size?: number
}

/**
 * Request parameters for apiClustersMgmtV1VersionGatesPost operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1VersionGatesPostRequest
 */
export interface DefaultApiApiClustersMgmtV1VersionGatesPostRequest {
    /**
     * 
     * @type {VersionGate}
     * @memberof DefaultApiApiClustersMgmtV1VersionGatesPost
     */
    readonly versionGate?: VersionGate
}

/**
 * Request parameters for apiClustersMgmtV1VersionGatesVersionGateIdDelete operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1VersionGatesVersionGateIdDeleteRequest
 */
export interface DefaultApiApiClustersMgmtV1VersionGatesVersionGateIdDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1VersionGatesVersionGateIdDelete
     */
    readonly versionGateId: string
}

/**
 * Request parameters for apiClustersMgmtV1VersionGatesVersionGateIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1VersionGatesVersionGateIdGetRequest
 */
export interface DefaultApiApiClustersMgmtV1VersionGatesVersionGateIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1VersionGatesVersionGateIdGet
     */
    readonly versionGateId: string
}

/**
 * Request parameters for apiClustersMgmtV1VersionsGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1VersionsGetRequest
 */
export interface DefaultApiApiClustersMgmtV1VersionsGetRequest {
    /**
     * Order criteria.  The syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the names of the attributes of the version instead of the names of the columns of a table. For example, in order to sort the versions descending by identifier the value should be:  &#x60;&#x60;&#x60;sql id desc &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then the order of the results is undefined.
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1VersionsGet
     */
    readonly order?: string

    /**
     * Index of the requested page, where one corresponds to the first page.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1VersionsGet
     */
    readonly page?: number

    /**
     * Search criteria.  The syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names of the attributes of the version instead of the names of the columns of a table. For example, in order to retrieve all the versions that are enabled:  &#x60;&#x60;&#x60;sql enabled &#x3D; \&#39;t\&#39; &#x60;&#x60;&#x60;  If the parameter isn\&#39;t provided, or if the value is empty, then all the versions that the user has permission to see will be returned.
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1VersionsGet
     */
    readonly search?: string

    /**
     * Maximum number of items that will be contained in the returned page.  Default value is &#x60;100&#x60;.
     * @type {number}
     * @memberof DefaultApiApiClustersMgmtV1VersionsGet
     */
    readonly size?: number
}

/**
 * Request parameters for apiClustersMgmtV1VersionsVersionIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiApiClustersMgmtV1VersionsVersionIdGetRequest
 */
export interface DefaultApiApiClustersMgmtV1VersionsVersionIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApiClustersMgmtV1VersionsVersionIdGet
     */
    readonly versionId: string
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Deletes the add-on.
     * @param {DefaultApiApiClustersMgmtV1AddonsAddonIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1AddonsAddonIdDelete(requestParameters: DefaultApiApiClustersMgmtV1AddonsAddonIdDeleteRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1AddonsAddonIdDelete(requestParameters.addonId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the add-on.
     * @param {DefaultApiApiClustersMgmtV1AddonsAddonIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1AddonsAddonIdGet(requestParameters: DefaultApiApiClustersMgmtV1AddonsAddonIdGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1AddonsAddonIdGet(requestParameters.addonId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the add-on.
     * @param {DefaultApiApiClustersMgmtV1AddonsAddonIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1AddonsAddonIdPatch(requestParameters: DefaultApiApiClustersMgmtV1AddonsAddonIdPatchRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1AddonsAddonIdPatch(requestParameters.addonId, requestParameters.addOn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of add-on versions.
     * @param {DefaultApiApiClustersMgmtV1AddonsAddonIdVersionsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1AddonsAddonIdVersionsGet(requestParameters: DefaultApiApiClustersMgmtV1AddonsAddonIdVersionsGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1AddonsAddonIdVersionsGet(requestParameters.addonId, requestParameters.order, requestParameters.page, requestParameters.search, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new add-on version and add it to the collection of add-ons.
     * @param {DefaultApiApiClustersMgmtV1AddonsAddonIdVersionsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1AddonsAddonIdVersionsPost(requestParameters: DefaultApiApiClustersMgmtV1AddonsAddonIdVersionsPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1AddonsAddonIdVersionsPost(requestParameters.addonId, requestParameters.addOnVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the add-on version.
     * @param {DefaultApiApiClustersMgmtV1AddonsAddonIdVersionsVersionIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1AddonsAddonIdVersionsVersionIdDelete(requestParameters: DefaultApiApiClustersMgmtV1AddonsAddonIdVersionsVersionIdDeleteRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1AddonsAddonIdVersionsVersionIdDelete(requestParameters.addonId, requestParameters.versionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the add-on version.
     * @param {DefaultApiApiClustersMgmtV1AddonsAddonIdVersionsVersionIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1AddonsAddonIdVersionsVersionIdGet(requestParameters: DefaultApiApiClustersMgmtV1AddonsAddonIdVersionsVersionIdGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1AddonsAddonIdVersionsVersionIdGet(requestParameters.addonId, requestParameters.versionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the add-on version.
     * @param {DefaultApiApiClustersMgmtV1AddonsAddonIdVersionsVersionIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1AddonsAddonIdVersionsVersionIdPatch(requestParameters: DefaultApiApiClustersMgmtV1AddonsAddonIdVersionsVersionIdPatchRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1AddonsAddonIdVersionsVersionIdPatch(requestParameters.addonId, requestParameters.versionId, requestParameters.addOnVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of add-ons.
     * @param {DefaultApiApiClustersMgmtV1AddonsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1AddonsGet(requestParameters: DefaultApiApiClustersMgmtV1AddonsGetRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1AddonsGet(requestParameters.order, requestParameters.page, requestParameters.search, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new add-on and add it to the collection of add-ons.
     * @param {DefaultApiApiClustersMgmtV1AddonsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1AddonsPost(requestParameters: DefaultApiApiClustersMgmtV1AddonsPostRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1AddonsPost(requestParameters.addOn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the aws infrastructure access role.
     * @param {DefaultApiApiClustersMgmtV1AwsInfrastructureAccessRolesAwsInfrastructureAccessRoleIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1AwsInfrastructureAccessRolesAwsInfrastructureAccessRoleIdGet(requestParameters: DefaultApiApiClustersMgmtV1AwsInfrastructureAccessRolesAwsInfrastructureAccessRoleIdGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1AwsInfrastructureAccessRolesAwsInfrastructureAccessRoleIdGet(requestParameters.awsInfrastructureAccessRoleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DefaultApiApiClustersMgmtV1AwsInfrastructureAccessRolesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1AwsInfrastructureAccessRolesGet(requestParameters: DefaultApiApiClustersMgmtV1AwsInfrastructureAccessRolesGetRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1AwsInfrastructureAccessRolesGet(requestParameters.order, requestParameters.page, requestParameters.search, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of machine types in the provided region.
     * @param {DefaultApiApiClustersMgmtV1AwsInquiriesMachineTypesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1AwsInquiriesMachineTypesPost(requestParameters: DefaultApiApiClustersMgmtV1AwsInquiriesMachineTypesPostRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1AwsInquiriesMachineTypesPost(requestParameters.page, requestParameters.size, requestParameters.cloudProviderData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of available regions of the cloud provider. IMPORTANT: This list doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider.
     * @param {DefaultApiApiClustersMgmtV1AwsInquiriesRegionsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1AwsInquiriesRegionsPost(requestParameters: DefaultApiApiClustersMgmtV1AwsInquiriesRegionsPostRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1AwsInquiriesRegionsPost(requestParameters.page, requestParameters.size, requestParameters.cloudProviderData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of policies.
     * @param {DefaultApiApiClustersMgmtV1AwsInquiriesStsCredentialRequestsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1AwsInquiriesStsCredentialRequestsGet(requestParameters: DefaultApiApiClustersMgmtV1AwsInquiriesStsCredentialRequestsGetRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1AwsInquiriesStsCredentialRequestsGet(requestParameters.page, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of policies.
     * @param {DefaultApiApiClustersMgmtV1AwsInquiriesStsPoliciesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1AwsInquiriesStsPoliciesGet(requestParameters: DefaultApiApiClustersMgmtV1AwsInquiriesStsPoliciesGetRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1AwsInquiriesStsPoliciesGet(requestParameters.order, requestParameters.page, requestParameters.search, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of available vpcs of the cloud provider for specific region. IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available vpcs of the provider.
     * @param {DefaultApiApiClustersMgmtV1AwsInquiriesVpcsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1AwsInquiriesVpcsPost(requestParameters: DefaultApiApiClustersMgmtV1AwsInquiriesVpcsPostRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1AwsInquiriesVpcsPost(requestParameters.page, requestParameters.size, requestParameters.cloudProviderData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of available regions of the cloud provider.  IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider.
     * @param {DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdAvailableRegionsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1CloudProvidersCloudProviderIdAvailableRegionsPost(requestParameters: DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdAvailableRegionsPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1CloudProvidersCloudProviderIdAvailableRegionsPost(requestParameters.cloudProviderId, requestParameters.page, requestParameters.size, requestParameters.aWS, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the cloud provider.
     * @param {DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1CloudProvidersCloudProviderIdGet(requestParameters: DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1CloudProvidersCloudProviderIdGet(requestParameters.cloudProviderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of regions of the cloud provider.  IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of regions of the provider.
     * @param {DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdRegionsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsGet(requestParameters: DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdRegionsGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsGet(requestParameters.cloudProviderId, requestParameters.page, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a cloud region to the database.
     * @param {DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdRegionsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsPost(requestParameters: DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdRegionsPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsPost(requestParameters.cloudProviderId, requestParameters.cloudRegion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the region.
     * @param {DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdDelete(requestParameters: DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdDeleteRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdDelete(requestParameters.cloudProviderId, requestParameters.regionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the region.
     * @param {DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdGet(requestParameters: DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdGet(requestParameters.cloudProviderId, requestParameters.regionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the region.
     * @param {DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdPatch(requestParameters: DefaultApiApiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdPatchRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1CloudProvidersCloudProviderIdRegionsRegionIdPatch(requestParameters.cloudProviderId, requestParameters.regionId, requestParameters.cloudRegion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of cloud providers.
     * @param {DefaultApiApiClustersMgmtV1CloudProvidersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1CloudProvidersGet(requestParameters: DefaultApiApiClustersMgmtV1CloudProvidersGetRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1CloudProvidersGet(requestParameters.fetchRegions, requestParameters.order, requestParameters.page, requestParameters.search, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAddonInquiriesAddonInquiryIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdAddonInquiriesAddonInquiryIdGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAddonInquiriesAddonInquiryIdGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdAddonInquiriesAddonInquiryIdGet(requestParameters.clusterId, requestParameters.addonInquiryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAddonInquiriesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdAddonInquiriesGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAddonInquiriesGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdAddonInquiriesGet(requestParameters.clusterId, requestParameters.order, requestParameters.page, requestParameters.search, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the addon upgrade policy.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdDelete(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdDeleteRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdDelete(requestParameters.clusterId, requestParameters.addonUpgradePolicyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the addon upgrade policy.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdGet(requestParameters.clusterId, requestParameters.addonUpgradePolicyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the addon upgrade policy.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdPatch(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdPatchRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdPatch(requestParameters.clusterId, requestParameters.addonUpgradePolicyId, requestParameters.addonUpgradePolicy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the upgrade policy state.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdStateGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdStateGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdStateGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdStateGet(requestParameters.clusterId, requestParameters.addonUpgradePolicyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the upgrade policy state.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdStatePatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdStatePatch(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdStatePatchRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesAddonUpgradePolicyIdStatePatch(requestParameters.clusterId, requestParameters.addonUpgradePolicyId, requestParameters.addonUpgradePolicyState, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of addon upgrade policies.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesGet(requestParameters.clusterId, requestParameters.page, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new addon upgrade policy to the cluster.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesPost(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdAddonUpgradePoliciesPost(requestParameters.clusterId, requestParameters.addonUpgradePolicy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an add-on installation and remove it from the collection of add-on installations on the cluster.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdDelete(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdDeleteRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdDelete(requestParameters.clusterId, requestParameters.addoninstallationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the add-on installation.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdGet(requestParameters.clusterId, requestParameters.addoninstallationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the add-on installation.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdPatch(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdPatchRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdAddonsAddoninstallationIdPatch(requestParameters.clusterId, requestParameters.addoninstallationId, requestParameters.addOnInstallation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of add-on installations.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAddonsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdAddonsGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAddonsGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdAddonsGet(requestParameters.clusterId, requestParameters.order, requestParameters.page, requestParameters.search, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new add-on installation and add it to the collection of add-on installations on the cluster.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAddonsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdAddonsPost(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAddonsPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdAddonsPost(requestParameters.clusterId, requestParameters.addOnInstallation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the cluster autoscaler.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAutoscalerDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdAutoscalerDelete(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAutoscalerDeleteRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdAutoscalerDelete(requestParameters.clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the autoscaler of a cluster.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAutoscalerGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdAutoscalerGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAutoscalerGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdAutoscalerGet(requestParameters.clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the cluster autoscaler.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAutoscalerPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdAutoscalerPatch(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAutoscalerPatchRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdAutoscalerPatch(requestParameters.clusterId, requestParameters.clusterAutoscaler, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new cluster autoscaler object.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAutoscalerPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdAutoscalerPost(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAutoscalerPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdAutoscalerPost(requestParameters.clusterId, requestParameters.clusterAutoscaler, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the AWS infrastructure access role grant.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdDelete(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdDeleteRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdDelete(requestParameters.clusterId, requestParameters.awsInfrastructureAccessRoleGrantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the AWS infrastructure access role grant.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsAwsInfrastructureAccessRoleGrantIdGet(requestParameters.clusterId, requestParameters.awsInfrastructureAccessRoleGrantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of AWS infrastructure access role grants.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsGet(requestParameters.clusterId, requestParameters.order, requestParameters.page, requestParameters.search, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new AWS infrastructure access role grant and add it to the collection of AWS infrastructure access role grants on the cluster.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsPost(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdAwsInfrastructureAccessRoleGrantsPost(requestParameters.clusterId, requestParameters.aWSInfrastructureAccessRoleGrant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the configuration for the Private Link.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationGet(requestParameters.clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of principals.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsGet(requestParameters.clusterId, requestParameters.page, requestParameters.search, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new principal for the Private Link.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPost(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPost(requestParameters.clusterId, requestParameters.privateLinkPrincipal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the principal.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPrincipalIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPrincipalIdDelete(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPrincipalIdDeleteRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPrincipalIdDelete(requestParameters.clusterId, requestParameters.principalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the principal.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPrincipalIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPrincipalIdGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPrincipalIdGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdAwsPrivateLinkConfigurationPrincipalsPrincipalIdGet(requestParameters.clusterId, requestParameters.principalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the clusterdeployment.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdClusterdeploymentDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdClusterdeploymentDelete(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdClusterdeploymentDeleteRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdClusterdeploymentDelete(requestParameters.clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the upgrade policy for the control plane.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdDelete(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdDeleteRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdDelete(requestParameters.clusterId, requestParameters.controlPlaneUpgradePolicyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the upgrade policy for the control plane.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdGet(requestParameters.clusterId, requestParameters.controlPlaneUpgradePolicyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the upgrade policy for the control plane.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdPatch(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdPatchRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesControlPlaneUpgradePolicyIdPatch(requestParameters.clusterId, requestParameters.controlPlaneUpgradePolicyId, requestParameters.controlPlaneUpgradePolicy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of upgrade policies for the control plane.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesGet(requestParameters.clusterId, requestParameters.page, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new upgrade policy to the control plane of the cluster.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesPost(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdControlPlaneUpgradePoliciesPost(requestParameters.clusterId, requestParameters.controlPlaneUpgradePolicy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the credentials of a cluster.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdCredentialsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdCredentialsGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdCredentialsGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdCredentialsGet(requestParameters.clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the cluster.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdDelete(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdDeleteRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdDelete(requestParameters.clusterId, requestParameters.deprovision, requestParameters.dryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdDeleteProtectionGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdDeleteProtectionGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdDeleteProtectionGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdDeleteProtectionGet(requestParameters.clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdDeleteProtectionPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdDeleteProtectionPatch(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdDeleteProtectionPatchRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdDeleteProtectionPatch(requestParameters.clusterId, requestParameters.deleteProtection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the external configuration.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdExternalConfigurationGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdExternalConfigurationGet(requestParameters.clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of labels.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsGet(requestParameters.clusterId, requestParameters.page, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the label.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdDelete(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdDeleteRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdDelete(requestParameters.clusterId, requestParameters.labelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the label.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdGet(requestParameters.clusterId, requestParameters.labelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the label.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdPatch(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdPatchRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsLabelIdPatch(requestParameters.clusterId, requestParameters.labelId, requestParameters.label, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new label to the cluster.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsPost(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdExternalConfigurationLabelsPost(requestParameters.clusterId, requestParameters.label, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of manifests.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsGet(requestParameters.clusterId, requestParameters.page, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the manifest.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdDelete(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdDeleteRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdDelete(requestParameters.clusterId, requestParameters.manifestId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the manifest.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdGet(requestParameters.clusterId, requestParameters.manifestId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the manifest.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdPatch(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdPatchRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsManifestIdPatch(requestParameters.clusterId, requestParameters.manifestId, requestParameters.manifest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new manifest to a cluster.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsPost(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdExternalConfigurationManifestsPost(requestParameters.clusterId, requestParameters.manifest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of syncsets.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsGet(requestParameters.clusterId, requestParameters.page, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new syncset to the cluster.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsPost(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsPost(requestParameters.clusterId, requestParameters.syncset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the syncset.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdDelete(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdDeleteRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdDelete(requestParameters.clusterId, requestParameters.syncsetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the syncset.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdGet(requestParameters.clusterId, requestParameters.syncsetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the syncset.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdPatch(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdPatchRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdExternalConfigurationSyncsetsSyncsetIdPatch(requestParameters.clusterId, requestParameters.syncsetId, requestParameters.syncset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of reasons.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdGateAgreementsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdGateAgreementsGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdGateAgreementsGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdGateAgreementsGet(requestParameters.clusterId, requestParameters.page, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new agreed version gate to the cluster.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdGateAgreementsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdGateAgreementsPost(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdGateAgreementsPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdGateAgreementsPost(requestParameters.clusterId, requestParameters.versionGateAgreement, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the version gate agreement.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdDelete(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdDeleteRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdDelete(requestParameters.clusterId, requestParameters.versionGateAgreementId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the version gate agreement.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdGateAgreementsVersionGateAgreementIdGet(requestParameters.clusterId, requestParameters.versionGateAgreementId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the cluster.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdGet(requestParameters.clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of groups.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdGroupsGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdGroupsGet(requestParameters.clusterId, requestParameters.page, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the group.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGroupIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdGroupsGroupIdGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGroupIdGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdGroupsGroupIdGet(requestParameters.clusterId, requestParameters.groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of users.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersGet(requestParameters.clusterId, requestParameters.groupId, requestParameters.page, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new user to the group.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersPost(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersPost(requestParameters.clusterId, requestParameters.groupId, requestParameters.user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the user.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdDelete(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdDeleteRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdDelete(requestParameters.clusterId, requestParameters.groupId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the user.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdGroupsGroupIdUsersUserIdGet(requestParameters.clusterId, requestParameters.groupId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Initiates cluster hibernation. While hibernating a cluster will not consume any cloud provider infrastructure but will be counted for quota.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdHibernatePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdHibernatePost(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdHibernatePostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdHibernatePost(requestParameters.clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the Hypershift details for a single cluster.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdHypershiftGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdHypershiftGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdHypershiftGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdHypershiftGet(requestParameters.clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of identity providers.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdIdentityProvidersGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdIdentityProvidersGet(requestParameters.clusterId, requestParameters.page, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the identity provider.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdDelete(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdDeleteRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdDelete(requestParameters.clusterId, requestParameters.identityProviderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the identity provider.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdGet(requestParameters.clusterId, requestParameters.identityProviderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of _HTPasswd_ IDP users.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersGet(requestParameters.clusterId, requestParameters.identityProviderId, requestParameters.page, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the user.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdDelete(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdDeleteRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdDelete(requestParameters.clusterId, requestParameters.identityProviderId, requestParameters.htpasswdUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the user.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdGet(requestParameters.clusterId, requestParameters.identityProviderId, requestParameters.htpasswdUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the user\'s password. The username is not editable
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdPatch(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdPatchRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersHtpasswdUserIdPatch(requestParameters.clusterId, requestParameters.identityProviderId, requestParameters.htpasswdUserId, requestParameters.hTPasswdUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds multiple new users to the _HTPasswd_ file.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersImportPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersImportPost(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersImportPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersImportPost(requestParameters.clusterId, requestParameters.identityProviderId, requestParameters.apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersImportPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new user to the _HTPasswd_ file.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersPost(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdHtpasswdUsersPost(requestParameters.clusterId, requestParameters.identityProviderId, requestParameters.hTPasswdUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update identity provider in the cluster.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdPatch(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdPatchRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdIdentityProvidersIdentityProviderIdPatch(requestParameters.clusterId, requestParameters.identityProviderId, requestParameters.identityProvider, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new identity provider to the cluster.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdIdentityProvidersPost(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdIdentityProvidersPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdIdentityProvidersPost(requestParameters.clusterId, requestParameters.identityProvider, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of inflight checks.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdInflightChecksGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdInflightChecksGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdInflightChecksGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdInflightChecksGet(requestParameters.clusterId, requestParameters.page, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the inflight check.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdInflightChecksInflightCheckIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdInflightChecksInflightCheckIdGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdInflightChecksInflightCheckIdGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdInflightChecksInflightCheckIdGet(requestParameters.clusterId, requestParameters.inflightCheckId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of ingresses.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdIngressesGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdIngressesGet(requestParameters.clusterId, requestParameters.page, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the ingress.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesIngressIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdIngressesIngressIdDelete(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesIngressIdDeleteRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdIngressesIngressIdDelete(requestParameters.clusterId, requestParameters.ingressId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the ingress.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesIngressIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdIngressesIngressIdGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesIngressIdGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdIngressesIngressIdGet(requestParameters.clusterId, requestParameters.ingressId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the ingress.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesIngressIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdIngressesIngressIdPatch(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesIngressIdPatchRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdIngressesIngressIdPatch(requestParameters.clusterId, requestParameters.ingressId, requestParameters.ingress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates all ingresses
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdIngressesPatch(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesPatchRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdIngressesPatch(requestParameters.clusterId, requestParameters.ingress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new ingress to the cluster.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdIngressesPost(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdIngressesPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdIngressesPost(requestParameters.clusterId, requestParameters.ingress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of reasons.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsGet(requestParameters.clusterId, requestParameters.page, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the reason.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdDelete(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdDeleteRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdDelete(requestParameters.clusterId, requestParameters.limitedSupportReasonId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the reason.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsLimitedSupportReasonIdGet(requestParameters.clusterId, requestParameters.limitedSupportReasonId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new reason to the cluster.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsPost(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdLimitedSupportReasonsPost(requestParameters.clusterId, requestParameters.limitedSupportReason, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of log links.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdLogsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdLogsGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdLogsGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdLogsGet(requestParameters.clusterId, requestParameters.page, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the log.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdLogsInstallGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdLogsInstallGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdLogsInstallGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdLogsInstallGet(requestParameters.clusterId, requestParameters.offset, requestParameters.tail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the log.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdLogsUninstallGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdLogsUninstallGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdLogsUninstallGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdLogsUninstallGet(requestParameters.clusterId, requestParameters.offset, requestParameters.tail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of machine pools.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdMachinePoolsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdMachinePoolsGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdMachinePoolsGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdMachinePoolsGet(requestParameters.clusterId, requestParameters.page, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the machine pool.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdDelete(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdDeleteRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdDelete(requestParameters.clusterId, requestParameters.machinePoolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the machine pool.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdGet(requestParameters.clusterId, requestParameters.machinePoolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the machine pool.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdPatch(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdPatchRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdMachinePoolsMachinePoolIdPatch(requestParameters.clusterId, requestParameters.machinePoolId, requestParameters.machinePool, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new machine pool to the cluster.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdMachinePoolsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdMachinePoolsPost(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdMachinePoolsPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdMachinePoolsPost(requestParameters.clusterId, requestParameters.machinePool, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdMetricQueriesAlertsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdMetricQueriesAlertsGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdMetricQueriesAlertsGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdMetricQueriesAlertsGet(requestParameters.clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdMetricQueriesClusterOperatorsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdMetricQueriesClusterOperatorsGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdMetricQueriesClusterOperatorsGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdMetricQueriesClusterOperatorsGet(requestParameters.clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the metrics.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdMetricQueriesCpuTotalByNodeRolesOsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdMetricQueriesCpuTotalByNodeRolesOsGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdMetricQueriesCpuTotalByNodeRolesOsGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdMetricQueriesCpuTotalByNodeRolesOsGet(requestParameters.clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdMetricQueriesNodesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdMetricQueriesNodesGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdMetricQueriesNodesGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdMetricQueriesNodesGet(requestParameters.clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the metrics.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdMetricQueriesSocketTotalByNodeRolesOsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdMetricQueriesSocketTotalByNodeRolesOsGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdMetricQueriesSocketTotalByNodeRolesOsGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdMetricQueriesSocketTotalByNodeRolesOsGet(requestParameters.clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of node pools.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdNodePoolsGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdNodePoolsGet(requestParameters.clusterId, requestParameters.page, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the node pool.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdDelete(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdDeleteRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdDelete(requestParameters.clusterId, requestParameters.nodePoolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the node pool.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdGet(requestParameters.clusterId, requestParameters.nodePoolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the node pool.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdPatch(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdPatchRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdPatch(requestParameters.clusterId, requestParameters.nodePoolId, requestParameters.nodePool, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of upgrade policies for the node pool.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesGet(requestParameters.clusterId, requestParameters.nodePoolId, requestParameters.page, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the upgrade policy for the node pool.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdDelete(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdDeleteRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdDelete(requestParameters.clusterId, requestParameters.nodePoolId, requestParameters.nodePoolUpgradePolicyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the upgrade policy for the node pool.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdGet(requestParameters.clusterId, requestParameters.nodePoolId, requestParameters.nodePoolUpgradePolicyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the upgrade policy for the node pool.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdPatch(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdPatchRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesNodePoolUpgradePolicyIdPatch(requestParameters.clusterId, requestParameters.nodePoolId, requestParameters.nodePoolUpgradePolicyId, requestParameters.nodePoolUpgradePolicy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new upgrade policy to the node pool of the cluster.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesPost(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdNodePoolsNodePoolIdUpgradePoliciesPost(requestParameters.clusterId, requestParameters.nodePoolId, requestParameters.nodePoolUpgradePolicy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new node pool to the cluster.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdNodePoolsPost(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdNodePoolsPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdNodePoolsPost(requestParameters.clusterId, requestParameters.nodePool, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the cluster.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdPatch(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdPatchRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdPatch(requestParameters.clusterId, requestParameters.cluster, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the product.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdProductGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdProductGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdProductGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdProductGet(requestParameters.clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the provision shard.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdProvisionShardDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdProvisionShardDelete(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdProvisionShardDeleteRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdProvisionShardDelete(requestParameters.clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the provision shard.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdProvisionShardGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdProvisionShardGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdProvisionShardGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdProvisionShardGet(requestParameters.clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the details of the provision shard.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdProvisionShardPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdProvisionShardPatch(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdProvisionShardPatchRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdProvisionShardPatch(requestParameters.clusterId, requestParameters.provisionShard, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of resources for a cluster in error state
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdResourcesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdResourcesGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdResourcesGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdResourcesGet(requestParameters.clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves currently available cluster resources
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdResourcesLiveGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdResourcesLiveGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdResourcesLiveGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdResourcesLiveGet(requestParameters.clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resumes from Hibernation.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdResumePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdResumePost(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdResumePostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdResumePost(requestParameters.clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdStatusGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdStatusGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdStatusGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdStatusGet(requestParameters.clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of operator roles.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdStsOperatorRolesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdStsOperatorRolesGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdStsOperatorRolesGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdStsOperatorRolesGet(requestParameters.clusterId, requestParameters.page, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the operator role.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdStsOperatorRolesOperatorIamRoleIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdStsOperatorRolesOperatorIamRoleIdDelete(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdStsOperatorRolesOperatorIamRoleIdDeleteRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdStsOperatorRolesOperatorIamRoleIdDelete(requestParameters.clusterId, requestParameters.operatorIamRoleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new operator role to the cluster.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdStsOperatorRolesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdStsOperatorRolesPost(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdStsOperatorRolesPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdStsOperatorRolesPost(requestParameters.clusterId, requestParameters.operatorIAMRole, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdStsSupportJumpRoleGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdStsSupportJumpRoleGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdStsSupportJumpRoleGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdStsSupportJumpRoleGet(requestParameters.clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of tuning configs.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdTuningConfigsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdTuningConfigsGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdTuningConfigsGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdTuningConfigsGet(requestParameters.clusterId, requestParameters.page, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new tuning config to the cluster.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdTuningConfigsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdTuningConfigsPost(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdTuningConfigsPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdTuningConfigsPost(requestParameters.clusterId, requestParameters.tuningConfig, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the tuning config.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdDelete(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdDeleteRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdDelete(requestParameters.clusterId, requestParameters.tuningConfigId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the tuning config.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdGet(requestParameters.clusterId, requestParameters.tuningConfigId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the tuning config.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdPatch(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdPatchRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdTuningConfigsTuningConfigIdPatch(requestParameters.clusterId, requestParameters.tuningConfigId, requestParameters.tuningConfig, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of upgrade policies.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdUpgradePoliciesGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdUpgradePoliciesGet(requestParameters.clusterId, requestParameters.page, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new upgrade policy to the cluster.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdUpgradePoliciesPost(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdUpgradePoliciesPost(requestParameters.clusterId, requestParameters.upgradePolicy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the upgrade policy.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdDelete(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdDeleteRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdDelete(requestParameters.clusterId, requestParameters.upgradePolicyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the upgrade policy.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdGet(requestParameters.clusterId, requestParameters.upgradePolicyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the upgrade policy.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdPatch(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdPatchRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdPatch(requestParameters.clusterId, requestParameters.upgradePolicyId, requestParameters.upgradePolicy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the upgrade policy state.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStateGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStateGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStateGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStateGet(requestParameters.clusterId, requestParameters.upgradePolicyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the upgrade policy state.
     * @param {DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStatePatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStatePatch(requestParameters: DefaultApiApiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStatePatchRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersClusterIdUpgradePoliciesUpgradePolicyIdStatePatch(requestParameters.clusterId, requestParameters.upgradePolicyId, requestParameters.upgradePolicyState, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of clusters.
     * @param {DefaultApiApiClustersMgmtV1ClustersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersGet(requestParameters: DefaultApiApiClustersMgmtV1ClustersGetRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersGet(requestParameters.order, requestParameters.page, requestParameters.search, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provision a new cluster and add it to the collection of clusters.  See the `register_cluster` method for adding an existing cluster.
     * @param {DefaultApiApiClustersMgmtV1ClustersPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ClustersPost(requestParameters: DefaultApiApiClustersMgmtV1ClustersPostRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ClustersPost(requestParameters.cluster, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the DNS domain.
     * @param {DefaultApiApiClustersMgmtV1DnsDomainsDnsDomainIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1DnsDomainsDnsDomainIdDelete(requestParameters: DefaultApiApiClustersMgmtV1DnsDomainsDnsDomainIdDeleteRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1DnsDomainsDnsDomainIdDelete(requestParameters.dnsDomainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the DNS domain.
     * @param {DefaultApiApiClustersMgmtV1DnsDomainsDnsDomainIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1DnsDomainsDnsDomainIdGet(requestParameters: DefaultApiApiClustersMgmtV1DnsDomainsDnsDomainIdGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1DnsDomainsDnsDomainIdGet(requestParameters.dnsDomainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the details of the DNS domain.
     * @param {DefaultApiApiClustersMgmtV1DnsDomainsDnsDomainIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1DnsDomainsDnsDomainIdPatch(requestParameters: DefaultApiApiClustersMgmtV1DnsDomainsDnsDomainIdPatchRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1DnsDomainsDnsDomainIdPatch(requestParameters.dnsDomainId, requestParameters.dNSDomain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DefaultApiApiClustersMgmtV1DnsDomainsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1DnsDomainsGet(requestParameters: DefaultApiApiClustersMgmtV1DnsDomainsGetRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1DnsDomainsGet(requestParameters.page, requestParameters.search, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a DNS domain.
     * @param {DefaultApiApiClustersMgmtV1DnsDomainsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1DnsDomainsPost(requestParameters: DefaultApiApiClustersMgmtV1DnsDomainsPostRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1DnsDomainsPost(requestParameters.dNSDomain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the environment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1EnvironmentGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1EnvironmentGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the environment.  Attributes that can be updated are:  - `last_upgrade_available_check` - `last_limited_support_check`
     * @param {DefaultApiApiClustersMgmtV1EnvironmentPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1EnvironmentPatch(requestParameters: DefaultApiApiClustersMgmtV1EnvironmentPatchRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1EnvironmentPatch(requestParameters.environment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new event to be tracked. When sending a new event request, it gets tracked in Prometheus, Pendo, CloudWatch, or whichever analytics client is configured as part of clusters service. This allows for reporting on events that happen outside of a regular API request, but are found to be useful for understanding customer needs and possible blockers.
     * @param {DefaultApiApiClustersMgmtV1EventsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1EventsPost(requestParameters: DefaultApiApiClustersMgmtV1EventsPostRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1EventsPost(requestParameters.event, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the cluster flavour.
     * @param {DefaultApiApiClustersMgmtV1FlavoursFlavourIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1FlavoursFlavourIdGet(requestParameters: DefaultApiApiClustersMgmtV1FlavoursFlavourIdGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1FlavoursFlavourIdGet(requestParameters.flavourId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the flavour.  Attributes that can be updated are:  - `aws.infra_volume` - `aws.infra_instance_type` - `gcp.infra_instance_type`
     * @param {DefaultApiApiClustersMgmtV1FlavoursFlavourIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1FlavoursFlavourIdPatch(requestParameters: DefaultApiApiClustersMgmtV1FlavoursFlavourIdPatchRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1FlavoursFlavourIdPatch(requestParameters.flavourId, requestParameters.flavour, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DefaultApiApiClustersMgmtV1FlavoursGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1FlavoursGet(requestParameters: DefaultApiApiClustersMgmtV1FlavoursGetRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1FlavoursGet(requestParameters.order, requestParameters.page, requestParameters.search, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new cluster flavour.
     * @param {DefaultApiApiClustersMgmtV1FlavoursPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1FlavoursPost(requestParameters: DefaultApiApiClustersMgmtV1FlavoursPostRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1FlavoursPost(requestParameters.flavour, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of encryption keys. IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider.
     * @param {DefaultApiApiClustersMgmtV1GcpInquiriesEncryptionKeysPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1GcpInquiriesEncryptionKeysPost(requestParameters: DefaultApiApiClustersMgmtV1GcpInquiriesEncryptionKeysPostRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1GcpInquiriesEncryptionKeysPost(requestParameters.page, requestParameters.size, requestParameters.cloudProviderData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of available key rings of the cloud provider. IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider.
     * @param {DefaultApiApiClustersMgmtV1GcpInquiriesKeyRingsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1GcpInquiriesKeyRingsPost(requestParameters: DefaultApiApiClustersMgmtV1GcpInquiriesKeyRingsPostRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1GcpInquiriesKeyRingsPost(requestParameters.page, requestParameters.size, requestParameters.cloudProviderData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of available regions of the cloud provider. IMPORTANT: This list doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available regions of the provider.
     * @param {DefaultApiApiClustersMgmtV1GcpInquiriesRegionsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1GcpInquiriesRegionsPost(requestParameters: DefaultApiApiClustersMgmtV1GcpInquiriesRegionsPostRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1GcpInquiriesRegionsPost(requestParameters.page, requestParameters.size, requestParameters.cloudProviderData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of available vpcs of the cloud provider for specific region. IMPORTANT: This collection doesn\'t currently support paging or searching, so the returned `page` will always be 1 and `size` and `total` will always be the total number of available vpcs of the provider.
     * @param {DefaultApiApiClustersMgmtV1GcpInquiriesVpcsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1GcpInquiriesVpcsPost(requestParameters: DefaultApiApiClustersMgmtV1GcpInquiriesVpcsPostRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1GcpInquiriesVpcsPost(requestParameters.page, requestParameters.size, requestParameters.cloudProviderData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the version metadata.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1Get(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1Get(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of templates.
     * @param {DefaultApiApiClustersMgmtV1LimitedSupportReasonTemplatesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1LimitedSupportReasonTemplatesGet(requestParameters: DefaultApiApiClustersMgmtV1LimitedSupportReasonTemplatesGetRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1LimitedSupportReasonTemplatesGet(requestParameters.page, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the template.
     * @param {DefaultApiApiClustersMgmtV1LimitedSupportReasonTemplatesLimitedSupportReasonTemplateIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1LimitedSupportReasonTemplatesLimitedSupportReasonTemplateIdGet(requestParameters: DefaultApiApiClustersMgmtV1LimitedSupportReasonTemplatesLimitedSupportReasonTemplateIdGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1LimitedSupportReasonTemplatesLimitedSupportReasonTemplateIdGet(requestParameters.limitedSupportReasonTemplateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of machine types.
     * @param {DefaultApiApiClustersMgmtV1MachineTypesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1MachineTypesGet(requestParameters: DefaultApiApiClustersMgmtV1MachineTypesGetRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1MachineTypesGet(requestParameters.order, requestParameters.page, requestParameters.search, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the machine type.
     * @param {DefaultApiApiClustersMgmtV1MachineTypesMachineTypeIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1MachineTypesMachineTypeIdGet(requestParameters: DefaultApiApiClustersMgmtV1MachineTypesMachineTypeIdGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1MachineTypesMachineTypeIdGet(requestParameters.machineTypeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of a subnet network verification.
     * @param {DefaultApiApiClustersMgmtV1NetworkVerificationsNetworkVerificationIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1NetworkVerificationsNetworkVerificationIdGet(requestParameters: DefaultApiApiClustersMgmtV1NetworkVerificationsNetworkVerificationIdGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1NetworkVerificationsNetworkVerificationIdGet(requestParameters.networkVerificationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates an entry for a network verification for each subnet supplied setting then to initial state.
     * @param {DefaultApiApiClustersMgmtV1NetworkVerificationsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1NetworkVerificationsPost(requestParameters: DefaultApiApiClustersMgmtV1NetworkVerificationsPostRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1NetworkVerificationsPost(requestParameters.networkVerification, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of oidc configs.
     * @param {DefaultApiApiClustersMgmtV1OidcConfigsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1OidcConfigsGet(requestParameters: DefaultApiApiClustersMgmtV1OidcConfigsGetRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1OidcConfigsGet(requestParameters.page, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the OidcConfig.
     * @param {DefaultApiApiClustersMgmtV1OidcConfigsOidcConfigIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1OidcConfigsOidcConfigIdDelete(requestParameters: DefaultApiApiClustersMgmtV1OidcConfigsOidcConfigIdDeleteRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1OidcConfigsOidcConfigIdDelete(requestParameters.oidcConfigId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of an OidcConfig.
     * @param {DefaultApiApiClustersMgmtV1OidcConfigsOidcConfigIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1OidcConfigsOidcConfigIdGet(requestParameters: DefaultApiApiClustersMgmtV1OidcConfigsOidcConfigIdGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1OidcConfigsOidcConfigIdGet(requestParameters.oidcConfigId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates attributes of an OidcConfig.
     * @param {DefaultApiApiClustersMgmtV1OidcConfigsOidcConfigIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1OidcConfigsOidcConfigIdPatch(requestParameters: DefaultApiApiClustersMgmtV1OidcConfigsOidcConfigIdPatchRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1OidcConfigsOidcConfigIdPatch(requestParameters.oidcConfigId, requestParameters.oidcConfig, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a hosting under Red Hat\'s S3 bucket for byo oidc configuration.
     * @param {DefaultApiApiClustersMgmtV1OidcConfigsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1OidcConfigsPost(requestParameters: DefaultApiApiClustersMgmtV1OidcConfigsPostRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1OidcConfigsPost(requestParameters.oidcConfig, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of pending delete clusters.
     * @param {DefaultApiApiClustersMgmtV1PendingDeleteClustersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1PendingDeleteClustersGet(requestParameters: DefaultApiApiClustersMgmtV1PendingDeleteClustersGetRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1PendingDeleteClustersGet(requestParameters.order, requestParameters.page, requestParameters.search, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the pending delete cluster.
     * @param {DefaultApiApiClustersMgmtV1PendingDeleteClustersPendingDeleteClusterIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1PendingDeleteClustersPendingDeleteClusterIdGet(requestParameters: DefaultApiApiClustersMgmtV1PendingDeleteClustersPendingDeleteClusterIdGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1PendingDeleteClustersPendingDeleteClusterIdGet(requestParameters.pendingDeleteClusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the pending delete cluster entry.
     * @param {DefaultApiApiClustersMgmtV1PendingDeleteClustersPendingDeleteClusterIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1PendingDeleteClustersPendingDeleteClusterIdPatch(requestParameters: DefaultApiApiClustersMgmtV1PendingDeleteClustersPendingDeleteClusterIdPatchRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1PendingDeleteClustersPendingDeleteClusterIdPatch(requestParameters.pendingDeleteClusterId, requestParameters.pendingDeleteCluster, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of products.
     * @param {DefaultApiApiClustersMgmtV1ProductsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ProductsGet(requestParameters: DefaultApiApiClustersMgmtV1ProductsGetRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ProductsGet(requestParameters.order, requestParameters.page, requestParameters.search, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the product.
     * @param {DefaultApiApiClustersMgmtV1ProductsProductIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ProductsProductIdGet(requestParameters: DefaultApiApiClustersMgmtV1ProductsProductIdGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ProductsProductIdGet(requestParameters.productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DefaultApiApiClustersMgmtV1ProvisionShardsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ProvisionShardsGet(requestParameters: DefaultApiApiClustersMgmtV1ProvisionShardsGetRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ProvisionShardsGet(requestParameters.page, requestParameters.search, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a provision shard.
     * @param {DefaultApiApiClustersMgmtV1ProvisionShardsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ProvisionShardsPost(requestParameters: DefaultApiApiClustersMgmtV1ProvisionShardsPostRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ProvisionShardsPost(requestParameters.provisionShard, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the provision shard.
     * @param {DefaultApiApiClustersMgmtV1ProvisionShardsProvisionShardIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ProvisionShardsProvisionShardIdDelete(requestParameters: DefaultApiApiClustersMgmtV1ProvisionShardsProvisionShardIdDeleteRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ProvisionShardsProvisionShardIdDelete(requestParameters.provisionShardId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the provision shard.
     * @param {DefaultApiApiClustersMgmtV1ProvisionShardsProvisionShardIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ProvisionShardsProvisionShardIdGet(requestParameters: DefaultApiApiClustersMgmtV1ProvisionShardsProvisionShardIdGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ProvisionShardsProvisionShardIdGet(requestParameters.provisionShardId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the details of the provision shard.
     * @param {DefaultApiApiClustersMgmtV1ProvisionShardsProvisionShardIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1ProvisionShardsProvisionShardIdPatch(requestParameters: DefaultApiApiClustersMgmtV1ProvisionShardsProvisionShardIdPatchRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1ProvisionShardsProvisionShardIdPatch(requestParameters.provisionShardId, requestParameters.provisionShard, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of trusted ip addresses.
     * @param {DefaultApiApiClustersMgmtV1TrustedIpAddressesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1TrustedIpAddressesGet(requestParameters: DefaultApiApiClustersMgmtV1TrustedIpAddressesGetRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1TrustedIpAddressesGet(requestParameters.page, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the trusted ip adresses.
     * @param {DefaultApiApiClustersMgmtV1TrustedIpAddressesTrustedIpIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1TrustedIpAddressesTrustedIpIdGet(requestParameters: DefaultApiApiClustersMgmtV1TrustedIpAddressesTrustedIpIdGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1TrustedIpAddressesTrustedIpIdGet(requestParameters.trustedIpId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of version gates.
     * @param {DefaultApiApiClustersMgmtV1VersionGatesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1VersionGatesGet(requestParameters: DefaultApiApiClustersMgmtV1VersionGatesGetRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1VersionGatesGet(requestParameters.order, requestParameters.page, requestParameters.search, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new version gate
     * @param {DefaultApiApiClustersMgmtV1VersionGatesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1VersionGatesPost(requestParameters: DefaultApiApiClustersMgmtV1VersionGatesPostRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1VersionGatesPost(requestParameters.versionGate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the version gate.
     * @param {DefaultApiApiClustersMgmtV1VersionGatesVersionGateIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1VersionGatesVersionGateIdDelete(requestParameters: DefaultApiApiClustersMgmtV1VersionGatesVersionGateIdDeleteRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1VersionGatesVersionGateIdDelete(requestParameters.versionGateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the version gate.
     * @param {DefaultApiApiClustersMgmtV1VersionGatesVersionGateIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1VersionGatesVersionGateIdGet(requestParameters: DefaultApiApiClustersMgmtV1VersionGatesVersionGateIdGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1VersionGatesVersionGateIdGet(requestParameters.versionGateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of versions.
     * @param {DefaultApiApiClustersMgmtV1VersionsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1VersionsGet(requestParameters: DefaultApiApiClustersMgmtV1VersionsGetRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1VersionsGet(requestParameters.order, requestParameters.page, requestParameters.search, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of the version.
     * @param {DefaultApiApiClustersMgmtV1VersionsVersionIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiClustersMgmtV1VersionsVersionIdGet(requestParameters: DefaultApiApiClustersMgmtV1VersionsVersionIdGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiClustersMgmtV1VersionsVersionIdGet(requestParameters.versionId, options).then((request) => request(this.axios, this.basePath));
    }
}

